From a8c9d96b564458ad7239db74413ba04928f6f1e3 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 22 Nov 2021 23:38:10 +0200
Subject: [PATCH] gameboy files moved to different folder

---
 TKPEmu/gb_tkp/CMakeLists.txt     |    5 +
 TKPEmu/gb_tkp/gameboy.cpp        |  283 ++++
 TKPEmu/gb_tkp/gameboy.h          |   58 +
 TKPEmu/gb_tkp/gb_addresses.h     |   85 ++
 TKPEmu/gb_tkp/gb_breakpoint.h    |   63 +
 TKPEmu/gb_tkp/gb_bus.cpp         |  318 ++++
 TKPEmu/gb_tkp/gb_bus.h           |  127 ++
 TKPEmu/gb_tkp/gb_cartridge.cpp   |   75 +
 TKPEmu/gb_tkp/gb_cartridge.h     |   63 +
 TKPEmu/gb_tkp/gb_cpu.cpp         | 2942 ++++++++++++++++++++++++++++++++++++++
 TKPEmu/gb_tkp/gb_cpu.h           |  158 ++
 TKPEmu/gb_tkp/gb_disassembler.h  |  347 +++++
 TKPEmu/gb_tkp/gb_ppu.cpp         |  301 ++++
 TKPEmu/gb_tkp/gb_ppu.h           |   42 +
 TKPEmu/gb_tkp/gb_tracelogger.cpp |   25 +
 TKPEmu/gb_tkp/gb_tracelogger.h   |   16 +
 16 files changed, 4908 insertions(+)

diff --git a/TKPEmu/gb_tkp/CMakeLists.txt b/TKPEmu/gb_tkp/CMakeLists.txt
new file mode 100644
index 0000000000000000000000000000000000000000..0073613e53ecaed7380ddb64ca76837e44ff59b5
--- /dev/null
+++ b/TKPEmu/gb_tkp/CMakeLists.txt
@@ -0,0 +1,5 @@
+cmake_minimum_required(VERSION 3.19)
+project(gb_tkp)
+file(GLOB SRC_FILES "*.cpp")
+file(GLOB HDR_FILES "*.h")
+add_library(gb_tkp ${HDR_FILES} ${SRC_FILES})
diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..e676b06a398e19689b192625eb49b6b3f32fe57a
--- /dev/null
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -0,0 +1,283 @@
+#include <iostream>
+#include <atomic>
+#include "../glad/glad/glad.h"
+#include "gameboy.h"
+namespace TKPEmu::Gameboy {
+	void Gameboy::limit_fps() {
+		// TODO: speedhack that sleeps for less time
+		a = std::chrono::system_clock::now();
+		std::chrono::duration<double, std::milli> work_time = a - b;
+		if (work_time.count() < sleep_time_) {
+			std::chrono::duration<double, std::milli> delta_ms(sleep_time_ - work_time.count());
+			auto delta_ms_duration = std::chrono::duration_cast<std::chrono::milliseconds>(delta_ms);
+			std::this_thread::sleep_for(std::chrono::milliseconds(delta_ms_duration.count()));
+		}
+		b = std::chrono::system_clock::now();
+		std::chrono::duration<double, std::milli> sleep_time = b - a;
+	}
+	Gameboy::Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys) :
+		bus_(Instructions),
+		cpu_(&bus_),
+		ppu_(&bus_, &DrawMutex),
+		direction_keys_(direction_keys),
+		action_keys_(action_keys),
+		joypad_(bus_.GetReference(addr_joy)),
+		interrupt_flag_(bus_.GetReference(addr_if))
+	{
+		GLuint image_texture;
+		glGenTextures(1, &image_texture);
+		glBindTexture(GL_TEXTURE_2D, image_texture);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glBindTexture(GL_TEXTURE_2D, image_texture);
+		glTexImage2D(
+			GL_TEXTURE_2D,
+			0,
+			GL_RGBA,
+			160,
+			144,
+			0,
+			GL_RGBA,
+			GL_FLOAT,
+			NULL
+		);
+		glBindTexture(GL_TEXTURE_2D, 0);
+		EmulatorImage.texture = image_texture;
+		EmulatorImage.width = 160;
+		EmulatorImage.height = 144;
+	}
+	Gameboy::~Gameboy() {
+		Stopped.store(true);
+		glDeleteTextures(1, &EmulatorImage.texture);
+	}
+	void Gameboy::SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr) {
+		log_types_ptr_ = std::move(types_ptr);
+	}
+	void Gameboy::v_log_state() {
+		*ofstream_ptr_ << std::setfill('0');
+		bool first_type = true;
+		for (const auto& t : *log_types_ptr_) {
+			switch (t) {
+				case LogType::PC: {
+					*ofstream_ptr_ << "PC:" << std::setw(4) << std::hex <<  cpu_.PC;
+					break;
+				}
+				case LogType::SP: {
+					*ofstream_ptr_ << "SP:" << std::setw(4) << std::hex <<  cpu_.SP;
+					break;
+				}
+				case LogType::A: {
+					*ofstream_ptr_ << "A:" << std::setw(2) << std::hex << (int)cpu_.A;
+					break;
+				}
+				case LogType::B: {
+					*ofstream_ptr_ << "B:" << std::setw(2) << std::hex << (int)cpu_.B;
+					break;
+				}
+				case LogType::C: {
+					*ofstream_ptr_ << "C:" << std::setw(2) <<  std::hex << (int)cpu_.C;
+					break;
+				}
+				case LogType::D: {
+					*ofstream_ptr_ << "D:" << std::setw(2) << std::hex << (int)cpu_.D;
+					break;
+				}
+				case LogType::E: {
+					*ofstream_ptr_ << "E:" << std::setw(2) << std::hex << (int)cpu_.A;
+					break;
+				}
+				case LogType::F: {
+					*ofstream_ptr_ << "F:" <<  std::setw(2) << std::hex << (int)cpu_.F;
+					break;
+				}
+				case LogType::H: {
+					*ofstream_ptr_ << "H:" << std::setw(2) << std::hex << (int)cpu_.H;
+					break;
+				}
+				case LogType::L: {
+					*ofstream_ptr_ << "L:" << std::setw(2) << std::hex << (int)cpu_.L;
+					break;
+				}
+			}
+			*ofstream_ptr_ << " ";
+		}
+		*ofstream_ptr_ << "\n";
+	}
+	void Gameboy::start_normal() { 
+		Reset();
+		auto func = [this]() {
+			while (!Stopped.load()) {
+				if (!Paused.load()) {
+					update();
+				}
+			}
+		};
+		UpdateThread = std::thread(func);
+		UpdateThread.detach();
+	}
+	void Gameboy::start_debug() {
+		auto func = [this]() {
+			std::lock_guard<std::mutex> lguard(ThreadStartedMutex);
+			Reset();
+			Paused = true;
+			Stopped = false;
+			Step = false;
+			// Emulation doesn't break on first instruction
+			bool first_instr = true;
+			while (!Stopped.load()) {
+				if (!Paused.load()) {
+					bool broken = false;
+					if (!first_instr) {
+						for (const auto& bp : Breakpoints) {
+							bool brk = bp.Check();
+							if (brk) {
+								InstructionBreak.store(cpu_.PC);
+								Paused.store(true);
+								broken = true;
+							}
+						}
+					}
+					first_instr = false;
+					if (!broken)
+						update();
+				}
+				else {
+					Step.wait(false);
+					Step.store(false);
+					update();
+					InstructionBreak.store(cpu_.PC);
+				}
+			}
+			return;
+		};
+		UpdateThread = std::thread(func);
+		UpdateThread.detach();
+	}
+	void Gameboy::Reset() {
+		bus_.SoftReset();
+		cpu_.Reset();
+		ppu_.Reset();
+	}
+	void Gameboy::update() {
+		if (cpu_.PC == 0x100) {
+			bus_.BiosEnabled = false;
+		}
+		int clk = cpu_.Update();
+		ppu_.Update(clk);
+		if (cpu_.TClock >= cpu_.MaxCycles) {
+			cpu_.TClock = 0;
+			cpu_.TimerCounter = cpu_.ClockSpeed / 0x400;
+			limit_fps();
+		}
+		log_state();
+	}
+	std::string Gameboy::print() const { 
+		return "GameboyTKP for TKPEmu\n"
+		       "Read more: https://github.com/OFFTKP/TKPEmu/blob/master/gb_README.md";
+	}
+	void Gameboy::HandleKeyDown(SDL_Keycode key) {
+		static const uint8_t joy_direction = 0b1110'1111;
+		static const uint8_t joy_action = 0b1101'1111;
+		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
+			int index = it_dir - direction_keys_.begin();
+			bus_.DirectionKeys = (~(1UL << index)) & joy_direction;
+			interrupt_flag_ = TKPEmu::Gameboy::Devices::Bus::JOYPAD;
+		}
+		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
+			int index = it_dir - action_keys_.begin();
+			bus_.ActionKeys = (~(1UL << index)) & joy_action;
+			interrupt_flag_ = TKPEmu::Gameboy::Devices::Bus::JOYPAD;
+		}
+	}
+	void Gameboy::HandleKeyUp(SDL_Keycode key) {
+		static const uint8_t joy_direction = 0b1110'1111;
+		static const uint8_t joy_action = 0b1101'1111;
+		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
+			int index = it_dir - direction_keys_.begin();
+			bus_.DirectionKeys = (1UL << index) | joy_direction;
+		}
+		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
+			int index = it_dir - action_keys_.begin();
+			bus_.ActionKeys = (1UL << index) | joy_action;
+		}
+	}
+	void Gameboy::LoadFromFile(std::string&& path) {
+		bus_.LoadCartridge(std::forward<std::string>(path));
+	}
+	DisInstr Gameboy::GetInstruction(uint16_t address) {
+		uint8_t ins = bus_.Read(address);
+		auto time = InstrTimes[ins];
+		auto instr = DisInstr(address, ins, time);
+		uint8_t p1 = 0, p2 = 0;
+		if (time == 1) {
+			p1 = bus_.Read(address + 1);
+			instr.Params[0] = p1;
+			return instr;
+		}
+		else if (time == 2) {
+			p1 = bus_.Read(address + 1);
+			p2 = bus_.Read(address + 2);
+			instr.Params[0] = p1;
+			instr.Params[1] = p2;
+			return instr;
+		}
+		else {
+			return instr;
+		}
+	}
+	bool Gameboy::AddBreakpoint(GBBPArguments bp) {
+		using RegCheckVector = std::vector<std::function<bool()>>;
+		RegCheckVector register_checks;
+		// TODO: Check if breakpoint already exists before adding it
+		// We calculate which of these checks we need, and add them all to a vector to save execution time
+		// Before being copied to the lambda, the values are decremented, as to keep them (1-256) -> (0-255)
+		// because we used the value of 0 to check whether this is used or not.
+		if (bp.A_using) { register_checks.push_back([this, gbbp = bp.A_value]() { return cpu_.A == gbbp; }); }
+		if (bp.B_using) { register_checks.push_back([this, gbbp = bp.B_value]() { return cpu_.B == gbbp; }); }
+		if (bp.C_using) { register_checks.push_back([this, gbbp = bp.C_value]() { return cpu_.C == gbbp; }); }
+		if (bp.D_using) { register_checks.push_back([this, gbbp = bp.D_value]() { return cpu_.D == gbbp; }); }
+		if (bp.E_using) { register_checks.push_back([this, gbbp = bp.E_value]() { return cpu_.E == gbbp; }); }
+		if (bp.F_using) { register_checks.push_back([this, gbbp = bp.F_value]() { return cpu_.F == gbbp; }); }
+		if (bp.H_using) { register_checks.push_back([this, gbbp = bp.H_value]() { return cpu_.H == gbbp; }); }
+		if (bp.L_using) { register_checks.push_back([this, gbbp = bp.L_value]() { return cpu_.L == gbbp; }); }
+		if (bp.PC_using) { register_checks.push_back([this, gbbp = bp.PC_value]() { return cpu_.PC == gbbp; }); }
+		if (bp.SP_using) { register_checks.push_back([this, gbbp = bp.SP_value]() { return cpu_.SP == gbbp; }); }
+		if (bp.SP_using) { register_checks.push_back([this, gbbp = bp.SP_value]() { return cpu_.SP == gbbp; }); }
+		if (bp.Ins_using) { register_checks.push_back([this, gbbp = bp.Ins_value]() { return (bus_.Read(cpu_.PC)) == gbbp; }); }
+		auto lamb = [rc = std::move(register_checks)]() {
+			for (auto& check : rc) {
+				if (!check()) {
+					// If any of the checks fails, that means the breakpoint shouldn't trigger
+					return false;
+				}
+			}
+			// Every check is passed, trigger breakpoint
+			return true;
+		};
+		GameboyBreakpoint gbp;
+		gbp.Args = std::move(bp);
+		gbp.SetChecks(std::move(lamb));
+		std::cout << "Breakpoint added:\n" << gbp.GetName() << std::endl;
+		bool ret = false;
+		if (gbp.BPFromTable)
+			ret = true;
+		Breakpoints.push_back(std::move(gbp));
+		return ret;
+	}
+	void Gameboy::RemoveBreakpoint(int index) {
+		Breakpoints.erase(Breakpoints.begin() + index);
+	}
+	float* Gameboy::GetScreenData()
+	{
+		return ppu_.GetScreenData();
+	}
+	const auto& Gameboy::GetOpcodeDescription(uint8_t opc) {
+		return cpu_.Instructions[opc].name;
+	}
+
+	GameboyPalettes& Gameboy::GetPalette() {
+		return bus_.Palette;
+	}
+}
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
new file mode 100644
index 0000000000000000000000000000000000000000..972af16ecfb07ccf9096b8a50bb4e8336b45c26d
--- /dev/null
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -0,0 +1,58 @@
+#pragma once
+#ifndef TKP_GB_GAMEBOY_H
+#define TKP_GB_GAMEBOY_H
+#include <array>
+#include "emulator.h"
+#include "disassembly_instr.h"
+#include "gb_breakpoint.h"
+#include "gb_addresses.h"
+#include "gb_cpu.h"
+namespace TKPEmu::Gameboy {
+	using GameboyPalettes = std::array<std::array<float, 3>,4>;
+	using GameboyKeys = std::array<SDL_Keycode, 4>;
+	class Gameboy : public Emulator {
+	private:
+		using CPU = TKPEmu::Gameboy::Devices::CPU;
+		using PPU = TKPEmu::Gameboy::Devices::PPU;
+		using Bus = TKPEmu::Gameboy::Devices::Bus;
+		using Cartridge = TKPEmu::Gameboy::Devices::Cartridge;
+		using DisInstr = TKPEmu::Tools::DisInstr;
+		using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
+	public:
+		Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys);
+		~Gameboy();
+		void Reset() override;
+		void HandleKeyDown(SDL_Keycode key) override;
+		void HandleKeyUp(SDL_Keycode key) override;
+		void LoadFromFile(std::string&& path) override;
+		float* GetScreenData() override;
+		void SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr);
+        DisInstr GetInstruction(uint16_t address);
+		bool AddBreakpoint(GBBPArguments bp);
+		void RemoveBreakpoint(int index);
+		const auto& GetOpcodeDescription(uint8_t opc);
+		GameboyPalettes& GetPalette();
+		CPU& GetCPU() { return cpu_; }
+		std::vector<GameboyBreakpoint> Breakpoints{};
+		std::vector<DisInstr> Instructions{};
+	private:
+		Bus bus_;
+		CPU cpu_;
+		PPU ppu_;
+		Cartridge cartridge_;
+		GameboyKeys& direction_keys_;
+		GameboyKeys& action_keys_;
+		uint8_t& joypad_, &interrupt_flag_;
+		std::chrono::system_clock::time_point a = std::chrono::system_clock::now();
+		std::chrono::system_clock::time_point b = std::chrono::system_clock::now();
+		std::unique_ptr<std::vector<LogType>> log_types_ptr_;
+		float sleep_time_ = 16.75f;
+		void v_log_state() override;
+		void start_normal() override;
+		void start_debug() override;
+		void update() override;
+		std::string print() const override;
+		void limit_fps();
+	};
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
new file mode 100644
index 0000000000000000000000000000000000000000..cb4f940ed0b2f27aebc2642981c12e908cc08717
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -0,0 +1,85 @@
+#pragma once
+#ifndef TKP_TOOLS_GBADDR_H
+#define TKP_TOOLS_GBADDR_H
+#include "disassembly_instr.h"
+#include "gb_breakpoint.h"
+#include <cstdint>
+using DisInstr = TKPEmu::Tools::DisInstr;
+using GBBPArguments = TKPEmu::Gameboy::Utils::GBBPArguments;
+constexpr size_t LogTypeSize = 10;
+enum class LogType {
+    A, B, C, D, 
+    E, F, H, L,
+    PC, SP,
+};
+constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
+    LogType::A, LogType::B, LogType::C, LogType::D,
+    LogType::E, LogType::F, LogType::H, LogType::L,
+    LogType::PC, LogType::SP
+};
+const static std::array<std::string, LogTypeSize> LogTypeNames {
+    "A   ", "B   ", "C   ", "D   ",
+    "E   ", "F   ", "H   ", "L   ",
+    "PC  ", "SP  "
+};
+constexpr std::array<uint8_t, 0x100> InstrTimes = {
+    0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
+    0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
+    1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
+    1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 2, 2, 2, 0, 1, 0, 0, 0, 2, 1, 2, 2, 2, 0,
+    0, 0, 2, 0, 2, 0, 1, 0, 0, 0, 2, 0, 2, 0, 1, 1,
+    0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 2,
+    1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0
+};
+constexpr auto cl_white = 0;
+constexpr auto cl_lgray = 1;
+constexpr auto cl_dgray = 2;
+constexpr auto cl_black = 3;
+constexpr auto addr_joy = 0xFF00;
+// Serial registers
+constexpr auto addr_std = 0xFF01;
+constexpr auto addr_stc = 0xFF02;
+// Timer registers
+constexpr auto addr_div = 0xFF04;
+constexpr auto addr_tac = 0xFF07;
+// Interrupt flag
+constexpr auto addr_ifl = 0xFF0F;
+// Sound registers
+constexpr auto addr_s1s = 0xFF10;
+constexpr auto addr_s3e = 0xFF1A;
+constexpr auto addr_s3o = 0xFF1C;
+constexpr auto addr_s4l = 0xFF20;
+constexpr auto addr_s4c = 0xFF23;
+constexpr auto addr_snd = 0xFF26;
+// PPU & OAM related registers
+constexpr auto addr_lcd = 0xFF40;
+constexpr auto addr_sta = 0xFF41;
+constexpr auto addr_lly = 0xFF44;
+constexpr auto addr_dma = 0xFF46;
+constexpr auto addr_bgp = 0xFF47;
+constexpr auto addr_ob0 = 0xFF48;
+constexpr auto addr_ob1 = 0xFF49;
+
+constexpr auto addr_if = 0xFF0F;
+constexpr auto addr_ie = 0xFFFF;
+
+// CPU flag masks and shifts
+constexpr uint8_t FLAG_ZERO_MASK = 0b10000000;
+constexpr uint8_t FLAG_NEG_MASK = 0b01000000;
+constexpr uint8_t FLAG_HCARRY_MASK = 0b00100000;
+constexpr uint8_t FLAG_CARRY_MASK = 0b00010000;
+constexpr uint8_t FLAG_EMPTY_MASK = 0b00000000;
+constexpr uint8_t FLAG_ZERO_SHIFT = 7;
+constexpr uint8_t FLAG_NEG_SHIFT = 6;
+constexpr uint8_t FLAG_HCARRY_SHIFT = 5;
+constexpr uint8_t FLAG_CARRY_SHIFT = 4;
+#endif
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_breakpoint.h b/TKPEmu/gb_tkp/gb_breakpoint.h
new file mode 100644
index 0000000000000000000000000000000000000000..ef60051fdeac4d7a7a38d10a9388f07cc2e13f6c
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_breakpoint.h
@@ -0,0 +1,63 @@
+#pragma once
+#ifndef TKP_TOOLS_GBBP_H
+#define TKP_TOOLS_GBBP_H
+#include <functional>
+namespace TKPEmu::Gameboy::Utils {
+	struct GBBPArguments {
+		bool A_using = false; uint16_t A_value = 0;
+		bool B_using = false; uint16_t B_value = 0;
+		bool C_using = false; uint16_t C_value = 0;
+		bool D_using = false; uint16_t D_value = 0;
+		bool E_using = false; uint16_t E_value = 0;
+		bool F_using = false; uint16_t F_value = 0;
+		bool H_using = false; uint16_t H_value = 0;
+		bool L_using = false; uint16_t L_value = 0;
+		bool PC_using = false; uint16_t PC_value = 0;
+		bool SP_using = false; uint16_t SP_value = 0;
+		bool Ins_using = false; uint16_t Ins_value = 0;
+	};
+	struct GameboyBreakpoint {
+	public:
+		using BreakFunction = std::function<bool()>;
+		bool Loaded = false;
+		bool BPFromTable = true;
+		GBBPArguments Args;
+		GameboyBreakpoint() = default;
+		GameboyBreakpoint(const GameboyBreakpoint&) = delete;
+		GameboyBreakpoint& operator=(const GameboyBreakpoint&) = delete;
+		GameboyBreakpoint(GameboyBreakpoint&&) = default;
+		GameboyBreakpoint& operator=(GameboyBreakpoint&&) = default;
+		void SetChecks(BreakFunction func) {
+			checks = std::move(func);
+		}
+		bool Check() const {
+			return checks();
+		}
+		const std::string& GetName() {
+			if (!Loaded) {
+				std::stringstream ss;
+				ss << std::setfill('0');
+				if (Args.A_using) { ss << "A=" << std::hex << std::setw(2) << Args.A_value << "&&"; BPFromTable = false; }
+				if (Args.B_using) { ss << "B=" << std::hex << std::setw(2) << Args.B_value << "&&"; BPFromTable = false; }
+				if (Args.C_using) { ss << "C=" << std::hex << std::setw(2) << Args.C_value << "&&"; BPFromTable = false; }
+				if (Args.D_using) { ss << "D=" << std::hex << std::setw(2) << Args.D_value << "&&"; BPFromTable = false; }
+				if (Args.E_using) { ss << "E=" << std::hex << std::setw(2) << Args.E_value << "&&"; BPFromTable = false; }
+				if (Args.F_using) { ss << "F=" << std::hex << std::setw(2) << Args.F_value << "&&"; BPFromTable = false; }
+				if (Args.H_using) { ss << "H=" << std::hex << std::setw(2) << Args.H_value << "&&"; BPFromTable = false; }
+				if (Args.L_using) { ss << "L=" << std::hex << std::setw(2) << Args.L_value << "&&"; BPFromTable = false; }
+				if (Args.PC_using) { ss << "PC=" << std::hex << std::setw(4) << Args.PC_value << "&&"; }
+				if (Args.SP_using) { ss << "SP=" << std::hex << std::setw(4) << Args.SP_value << "&&"; BPFromTable = false; }
+				if (Args.Ins_using) { ss << "Ins=" << std::hex << std::setw(2) << Args.Ins_value << "&&"; BPFromTable = false; }
+				ss.seekp(-2, ss.cur);
+				ss << "  ";
+				name = ss.str();
+				Loaded = true;
+			}
+			return name;
+		}
+	private:
+		std::string name = "error-breakpoint";
+		BreakFunction checks;
+	};
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..41da174173f8ea02f4fafb3225b17852bf01f08e
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -0,0 +1,318 @@
+#include <iostream>
+#include <iomanip>
+#include <algorithm>
+#include <bitset>
+#include "../include/gb_bus.h"
+#include "../include/gb_addresses.h"
+namespace TKPEmu::Gameboy::Devices {
+
+	Bus::Bus(std::vector<DisInstr>& instrs) : instructions_(instrs) {}
+
+	uint8_t& Bus::redirect_address(uint16_t address) {
+		using CT = Cartridge::CartridgeType;
+		// Return address from ROM banks
+		// TODO: create better exceptions
+		// TODO: make bios optional, can be disabled in settings
+		switch (address & 0xF000) {
+			case 0x0000: {
+				if (BiosEnabled) {
+					static constexpr uint16_t bios_verify_start = 0xA8;
+					static constexpr uint16_t bios_verify_end = 0xD7;
+					static constexpr uint16_t logo_cartridge_start = 0x104;
+					static constexpr uint16_t logo_cartridge_end = 0x133;
+					// The logo is hardcoded in the bios normally to check validity of cartridges, so
+					// these two ifs allow us to circmvent the validity check and provide our own logo
+					if (address >= bios_verify_start && address <= bios_verify_end) {
+						return logo[address - bios_verify_start];
+					}
+					if (address >= logo_cartridge_start && address <= logo_cartridge_end) {
+						return logo[address - logo_cartridge_start];
+					}
+					if (address < 0x100) {
+						return bios[address];
+					}
+				}
+				// If gameboy is not in bios mode, or if the address >= 0x100, we fallthrough
+				// to the next case
+				[[fallthrough]];  // This avoids a compiler warning. Fallthrough is intentional
+			}
+			case 0x1000:
+			case 0x2000:
+			case 0x3000:
+			case 0x4000:
+			case 0x5000:
+			case 0x6000:
+			case 0x7000: {
+				auto ct = cartridge_->GetCartridgeType();
+				switch (ct) {
+					case CT::ROM_ONLY: {
+						int index = address / 0x4000;
+						return (rom_banks_[index])[address % 0x4000];
+					}
+					case CT::MBC1:
+					case CT::MBC1_RAM:
+					case CT::MBC1_RAM_BATTERY: {
+						if (address <= 0x3FFF) {
+							return (rom_banks_[0])[address % 0x4000];
+						}
+						else {
+							return (rom_banks_[selected_rom_bank_])[address % 0x4000];
+						}
+						break;
+					}
+				}
+				throw("Bad cartridge type");
+				break;
+			}
+			case 0x8000:
+			case 0x9000: {
+				return vram_[address % 0x2000];
+			}
+			case 0xA000:
+			case 0xB000: {
+				if (cartridge_->GetRamSize() == 0)
+					return eram_default_[address % 0x2000];
+
+				return (ram_banks_[selected_ram_bank_])[address % 0x2000];
+			}
+			case 0xC000:
+			case 0xD000: {
+				return wram_[address % 0x2000];
+			}
+			case 0xE000: {
+				return redirect_address(address - 0x2000);
+			}
+			case 0xF000: {
+				if (address <= 0xFDFF) {
+					return redirect_address(address - 0x2000);
+				}
+				else if (address <= 0xFE9F) {
+					// OAM
+					return oam_[address & 0x9F];
+				}
+				else if (address <= 0xFEFF) {
+					// TODO: check if this is actually unused area
+					unused_mem_area_ = 1;
+					return unused_mem_area_;
+				}
+				else if (address <= 0xFFFF) {
+					return hram_[address % 0xFF00];
+				}
+				else {
+					throw("Bad memory address");
+				}
+			}
+		}
+	}
+
+	uint8_t Bus::Read(uint16_t address) {
+		// Making copy so you can't write to this
+		switch(address) {
+			case addr_joy: {
+				if (action_key_mode_) { 
+					return ActionKeys;
+				} else {
+					return DirectionKeys;
+				}
+			}
+		}
+		uint8_t read = redirect_address(address);
+		return read;
+	}
+
+	uint16_t Bus::ReadL(uint16_t address) {
+		return Read(address) + (Read(address + 1) << 8);
+	}
+
+	uint8_t& Bus::GetReference(uint16_t address) {
+		return redirect_address(address);
+	}
+
+	void Bus::Write(uint16_t address, uint8_t data) {	
+		if (address <= 0x7FFF) {
+			if (address <= 0x1FFF) {
+				// Any value "written" here with lower 4 bits == 0xA enables eram,
+				// other values disable eram
+				if ((data & 0xF) == 0xA) {
+					ram_enabled_ = true;
+				}
+				else {
+					ram_enabled_ = false;
+				}
+			}
+			else if (address <= 0x3FFF) {
+				// Keep 3 highest bits
+				// TODO: this only happens on mbc1
+				selected_rom_bank_ &= 0b11100000;
+				selected_rom_bank_ |= data & 0b11111;
+				selected_rom_bank_ %= rom_banks_size_;
+				if (selected_rom_bank_ == 0)
+					selected_rom_bank_ = 1;
+			}
+			else if (address <= 0x5FFF) {
+				selected_rom_bank_ &= 0b11111;
+				selected_rom_bank_ |= (data << 5);
+				selected_rom_bank_ %= rom_banks_size_;
+			}
+			else if (address <= 0x7FFF) {
+				// TODO: MBC1 1MB multi-carts might have different behavior, investigate
+				// This enables mbc1 1mb mode?
+			}
+		}
+		else {
+			switch (address) {
+				case addr_std: {
+					// TODO: implement serial
+					break;
+				}
+				case addr_bgp: {
+					for (int i = 0; i < 4; i++) {
+						BGPalette[i] = (data >> (i * 2)) & 0b11;
+					}
+					break;
+				}
+				case addr_ob0: {
+					for (int i = 0; i < 4; i++) {
+						OBJ0Palette[i] = (data >> (i * 2)) & 0b11;
+					}
+					break;
+				}
+				case addr_ob1: {
+					for (int i = 0; i < 4; i++) {
+						OBJ1Palette[i] = (data >> (i * 2)) & 0b11;
+					}
+					break;
+				}
+				case addr_dma: {
+					// DMA transfer, load oam up.
+					uint16_t dma_addr = data << 8;
+					for (int i = 0; i <= (0x9F - 4); i += 4) {
+						uint16_t source = dma_addr | i;
+						// Each sprite is 4 bytes, so the array has size of 160/4 = 40 
+						OAM[i / 4].y_pos      = Read(source);
+						OAM[i / 4].x_pos      = Read(source + 1);
+						OAM[i / 4].tile_index = Read(source + 2);
+						OAM[i / 4].flags      = Read(source + 3);
+					}
+					break;
+				}
+				case addr_lcd: {
+					if (data & 0b1000'0000) {
+						hram_[0x41] &= 0b1111'1100;
+						hram_[0x44] = 0;
+						NextMode = 2;
+					}
+					break;
+				}
+
+				// Any unused bits in these registers are set, passes unused_hwio-GS.gb test (mooneye)
+				case addr_div: {
+					DIVReset = true;
+					break;
+				}
+				case addr_tac: {
+					TACChanged = true;
+					data |= 0b1111'1000;
+					break;
+				}
+				case addr_joy: {
+					action_key_mode_ = (data == 0x10);
+					return;
+				}
+				case addr_stc: {
+					data |= 0b0111'1110;
+					break;
+				}
+				case addr_ifl: {
+					data |= 0b1110'0000;
+					break;
+				}
+				case addr_sta: {
+					data |= 0b1000'0000;
+					break;
+				}
+				case addr_s1s: {
+					data |= 0b1000'0000;
+					break;
+				}
+				case addr_s3e: {
+					data |= 0b0111'1111;
+					break;
+				}
+				case addr_s3o: {
+					data |= 0b1001'1111;
+					break;
+				}
+				case addr_s4l: {
+					data |= 0b1110'0000;
+					break;
+				}
+				case addr_s4c: {
+					data |= 0b0011'1111;
+					break;
+				}
+				case addr_snd: {
+					data |= 0b0111'0000;
+					break;
+				}
+				// Unused HWIO registers
+				// Writing to these sets all the bits
+				case 0xFF03: case 0xFF08: case 0xFF09: case 0xFF0A: case 0xFF0B:
+				case 0xFF0C: case 0xFF0D: case 0xFF0E: case 0xFF15: case 0xFF1F:
+				case 0xFF27: case 0xFF28: case 0xFF29: case 0xFF4C: case 0xFF4D:
+				case 0xFF4E: case 0xFF4F: case 0xFF50: case 0xFF51: case 0xFF52:
+				case 0xFF53: case 0xFF54: case 0xFF55: case 0xFF56: case 0xFF57:
+				case 0xFF58: case 0xFF59: case 0xFF5A: case 0xFF5B: case 0xFF5C:
+				case 0xFF5D: case 0xFF5E: case 0xFF5F: case 0xFF60: case 0xFF61:
+				case 0xFF62: case 0xFF63: case 0xFF64: case 0xFF65: case 0xFF66:
+				case 0xFF67: case 0xFF68: case 0xFF69: case 0xFF6A: case 0xFF6B:
+				case 0xFF6C: case 0xFF6D: case 0xFF6E: case 0xFF6F: case 0xFF70:
+				case 0xFF71: case 0xFF72: case 0xFF73: case 0xFF74: case 0xFF75:
+				case 0xFF76: case 0xFF77: case 0xFF78: case 0xFF79: case 0xFF7A:
+				case 0xFF7B: case 0xFF7C: case 0xFF7D: case 0xFF7E: case 0xFF7F: {
+					data |= 0b1111'1111;
+					break;
+				}
+			}
+			if (address >= 0xFE00 && address <= 0xFE9F) {
+				switch (address % 4) { 
+					case 0: OAM[(address & 0xFF) / 4].y_pos      = data; break;
+					case 1: OAM[(address & 0xFF) / 4].x_pos      = data; break;
+					case 2: OAM[(address & 0xFF) / 4].tile_index = data; break;
+					case 3: OAM[(address & 0xFF) / 4].flags      = data; break;
+				}
+			}
+			redirect_address(address) = data;
+		}
+	}
+
+	void Bus::WriteL(uint16_t address, uint16_t data) {
+		Write(address, data & 0xFF);
+		Write(address + 1, data >> 8);
+	}
+
+	void Bus::Reset() {
+		SoftReset();
+		for (auto& rom : rom_banks_) {
+			rom.fill(0);
+		}	
+	}
+
+	void Bus::SoftReset() {
+		for (auto& ram : ram_banks_) {
+			ram.fill(0);
+		}
+		hram_.fill(0);
+		oam_.fill(0);
+		selected_rom_bank_ = 1;
+		selected_ram_bank_ = 0;
+		BiosEnabled = true;
+	}
+
+	void Bus::LoadCartridge(std::string&& fileName) {
+		Reset();
+		cartridge_ = std::unique_ptr<Cartridge>(new Cartridge());
+		cartridge_->Load(fileName, rom_banks_, ram_banks_);
+		rom_banks_size_ = cartridge_->GetRomSize();
+	}
+}
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
new file mode 100644
index 0000000000000000000000000000000000000000..5faa5dce142f34ab6e08d56e0bf393fccae2f02b
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -0,0 +1,127 @@
+#pragma once
+#ifndef TKP_GB_BUS_H
+#define TKP_GB_BUS_H
+#include <string>
+#include <cstdint>
+#include <array>
+#include <vector>
+#include <fstream>
+#include <iterator>
+#include <memory>
+#include "gb_cartridge.h"
+#include "gb_addresses.h"
+namespace TKPEmu::Gameboy::Devices {
+    class Bus {
+    private:
+        using RamBank = std::array<uint8_t, 0x2000>;
+        using RomBank = std::array<uint8_t, 0x4000>;
+        bool ram_enabled_ = false;
+        uint8_t selected_ram_bank_ = 0;
+        uint8_t selected_rom_bank_ = 1;
+        uint8_t rom_banks_size_ = 2;
+        bool action_key_mode_ = false;
+        uint8_t unused_mem_area_ = 0;
+        std::vector<RamBank> ram_banks_;
+        std::vector<RomBank> rom_banks_;
+        std::unique_ptr<Cartridge> cartridge_ = NULL;
+        std::array<uint8_t, 0xA0> oam_{};
+        std::array<uint8_t, 0x100> hram_{};
+        std::array<uint8_t, 0x2000> eram_default_{};
+        std::array<uint8_t, 0x2000> wram_{}; // TODO: cgb uses larger wram, maybe change, maybe inherit
+        std::array<uint8_t, 0x2000> vram_{};
+        std::vector<DisInstr>& instructions_;
+        uint8_t& redirect_address(uint16_t address);
+    public:
+        enum LCDCFlag {
+            BG_ENABLE = 1 << 0,
+            OBJ_ENABLE = 1 << 1,
+            OBJ_SIZE = 1 << 2,
+            BG_TILEMAP = 1 << 3,
+            BG_TILES = 1 << 4,
+            WND_ENABLE = 1 << 5,
+            WND_TILEMAP = 1 << 6,
+            LCD_ENABLE = 1 << 7
+        };
+        enum STATFlag {
+            MODE = 0b11,
+            COINCIDENCE = 1 << 2,
+            MODE0_INTER = 1 << 3,
+            MODE1_INTER = 1 << 4,
+            MODE2_INTER = 1 << 5,
+            COINC_INTER = 1 << 6
+        };
+        enum IFInterrupt {
+            VBLANK = 1 << 0,
+            LCDSTAT = 1 << 1,
+            TIMER = 1 << 2,
+            SERIAL = 1 << 3,
+            JOYPAD = 1 << 4
+        };
+        struct Sprite {
+            uint8_t y_pos = 0;
+            uint8_t x_pos = 0;
+            uint8_t tile_index = 0;
+            uint8_t flags = 0;
+        };
+        struct Pixel {
+            uint8_t color : 2;
+            uint8_t palette : 2;
+            // TODO: CGB Sprite priority
+            uint8_t bg_prio : 1;
+        };
+        struct Tile {
+            Pixel pixels[64];
+        };
+        bool BiosEnabled = true;
+        uint8_t logo[0x30] = {
+            // Every 2 bytes is an 8x8 tile. If you convert the hex to binary, each bit is a 2x2 pixel
+            // And within the byte each 4 bits is a new line
+            0x22, 0x72, 0x22, 0xA3, 0x55, 0x99, 0xE1, 0x11, 0x74, 0x47, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x05, 0x55, 0x00, 0x12, 0x00, 0x4A,
+            0x22, 0x23, 0x32, 0x2A, 0x19, 0x55, 0xE0, 0x00, 0x44, 0x47, 0x01, 0x1D, 0xA5, 0x11, 0x44, 0x43, 0x88, 0x84, 0x08, 0x70, 0x29, 0x00, 0x24, 0x80,
+        };
+        uint8_t bios[0x100] = {
+            0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
+            0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
+            0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
+            0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
+            0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
+            0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
+            0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
+            0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
+            0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
+            0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
+            0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
+            // After the logo is scrolled down in the gameboy, these bytes are checked for validity.
+            // We set these to 0 and read from the logo array above instead, so we can customize our logo.
+            // Range: [0xA8,0xD8)
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            // These bytes are normally the little copyright symbol
+            0x7E, 0x81, 0xA5, 0x81, 0xA5, 0xBD, 0x81, 0x7E,
+            // Back to normal instructions
+            0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
+            0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
+        };
+        Bus(std::vector<DisInstr>& instrs);
+        uint8_t Read(uint16_t address);
+        uint16_t ReadL(uint16_t address);
+        uint8_t& GetReference(uint16_t address);
+        void Write(uint16_t address, uint8_t data);
+        void WriteL(uint16_t address, uint16_t data);
+        void Reset();
+        void SoftReset();
+        void LoadCartridge(std::string&& fileName);
+        std::array<std::array<float, 3>, 4> Palette;
+        std::array<uint8_t, 4> BGPalette{};
+        std::array<uint8_t, 4> OBJ0Palette{};
+        std::array<uint8_t, 4> OBJ1Palette{};
+        std::array<Sprite, 40> OAM;
+        bool DIVReset = false;
+        bool TACChanged = false;
+        uint8_t NextMode = 0;
+        uint8_t DirectionKeys = 0b1110'1111;
+        uint8_t ActionKeys = 0b1101'1111;
+    };
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..67683ca541c5cd71936e502dd97ddfc4665a04ad
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -0,0 +1,75 @@
+#include <fstream>
+#include <iostream>
+#include <cmath>
+#include "../include/gb_cartridge.h"
+namespace TKPEmu::Gameboy::Devices {
+	void Cartridge::Load(const std::string& fileName, std::vector<std::array<uint8_t, 0x4000>>& romBanks, std::vector<std::array<uint8_t, 0x2000>>& ramBanks) {
+		std::ifstream is;
+		is.open(fileName, std::ios::binary);
+		if (is.is_open()) {
+			is.seekg(ENTRY_POINT, std::ios_base::beg);
+			is.read((char*)&header_, sizeof(Header));
+			loaded = true;
+			is.seekg(0, std::ios_base::beg);
+			auto ct = GetCartridgeType();
+			switch (ct) {
+				case CartridgeType::ROM_ONLY:
+				case CartridgeType::MBC1:
+				case CartridgeType::MBC1_RAM:
+				case CartridgeType::MBC1_RAM_BATTERY: {
+					auto sz = GetRomSize();
+					romBanks.resize(sz);
+					for (int i = 0; i < sz; i++) {
+						is.read((char*)(&romBanks[i]), sizeof(uint8_t) * 0x4000);
+					}
+					break;
+				}
+				default: {
+					// TODO: better error or implement all cartridge types
+					throw("error rom not implemented");
+				}
+			}
+			is.close();
+			// Empty init the rambanks
+			ramBanks.resize(GetRamSize());
+			PrintHeader();
+		}
+	}
+
+	Cartridge::CartridgeType Cartridge::GetCartridgeType() {
+		if (loaded) {
+			return (CartridgeType)header_.cartridgeType;
+		}
+	}
+
+	// Returns the number of 8KB RAM banks
+	int Cartridge::GetRamSize() {
+		switch (header_.ramSize) {
+			case 0: return 0;
+			case 2: return 1;
+			case 3: return 4;
+			case 4: return 16;
+			case 5: return 8;
+		}
+	}
+
+	// Returns the number of 16kb ROM banks
+	int Cartridge::GetRomSize() {
+		switch (header_.romSize) {
+		// Likely inaccurate according to pandocs, no roms using these are known
+		[[unlikely]] case 0x52: return 72;
+		[[unlikely]] case 0x53: return 80;
+		[[unlikely]] case 0x54: return 96;
+		[[likely]] default:
+			return std::pow(2, (header_.romSize + 1));
+		}
+	}
+	void Cartridge::PrintHeader() {
+		std::cout << "Header: {"
+				<< "\nname: " << header_.name
+				<< "\ncartridge_type:" << (int)header_.cartridgeType
+				<< "\nrom_size: " << (int)header_.romSize
+				<< "\nram_size: " << (int)header_.ramSize
+				<< "\n}" << std::endl;
+	}
+}
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
new file mode 100644
index 0000000000000000000000000000000000000000..0c89a80d975659257bafae27862f7dce3c38979e
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -0,0 +1,63 @@
+#pragma once
+#ifndef TKP_GB_CARTRIDGE_H
+#define TKP_GB_CARTRIDGE_H
+#include <string>
+#include <vector>
+#include <array>
+#define ENTRY_POINT 0x100
+namespace TKPEmu::Gameboy::Devices {
+	class Cartridge
+	{
+	public:
+		enum class CartridgeType {
+			ROM_ONLY = 0x0,
+			MBC1 = 0x1,
+			MBC1_RAM = 0x2,
+			MBC1_RAM_BATTERY = 0x3,
+			MBC2 = 0x5,
+			MBC2_BATTERY = 0x6,
+			ROM_RAM = 0x8,
+			ROM_RAM_BATTERY = 0x9,
+			MMM01 = 0xB,
+			MMM01_RAM = 0xC,
+			MMM01_RAM_BATTERY = 0xD,
+			MBC3_TIMER_RAM_BATTERY = 0x10,
+			MBC3 = 0x11,
+			MBC3_RAM = 0x12,
+			MBC3_RAM_BATTERY = 0x13,
+			MBC4 = 0x15,
+			MBC4_RAM = 0x16,
+			MBC4_RAM_BATTERY = 0x17,
+			MBC5 = 0x19,
+			MBC5_RAM = 0x1A,
+			MBC5_RAM_BATTERY = 0x1B,
+			MBC5_RUMBLE = 0x1C,
+			MBC5_RUMBLE_RAM = 0x1D,
+			MBC5_RUMBLE_RAM_BATTERY = 0x1E,
+			POCKET_CAMERA = 0xFC,
+			BANDAITAMA5 = 0xFD,
+			HuC3 = 0xFE,
+			HuC1_RAM_BATTERY = 0xFF
+		};
+	private:
+		struct Header {
+			char unusedData1[0x34];
+			char name[14];
+			char gameboyColor;
+			char unusedData2[4];
+			char cartridgeType;
+			char romSize;
+			char ramSize;
+			char unusedData3[6];
+		} header_;
+		bool loaded;
+	public:
+		void Load(const std::string& fileName, std::vector<std::array<uint8_t, 0x4000>>& romBanks, std::vector<std::array<uint8_t, 0x2000>>& ramBanks);
+		CartridgeType GetCartridgeType();
+		int GetRamSize();
+		int GetRomSize();
+		// TODO: return string&&, make window that shows the string
+		void PrintHeader();
+	};
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..4c3cfa549decc19747db21f6cee375215e0d5882
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -0,0 +1,2942 @@
+#include "../include/gb_cpu.h"
+#include <stdexcept>
+#include <iostream>
+namespace TKPEmu::Gameboy::Devices {
+	CPU::CPU(Bus* bus) : bus_(bus),
+		IF(bus->GetReference(0xFF0F)),
+		IE(bus->GetReference(0xFFFF)),
+		DIVIDER(bus->GetReference(0xFF04)),
+		TIMA(bus->GetReference(0xFF05)),
+		TMA(bus->GetReference(0xFF06)),
+		TAC(bus->GetReference(0xFF07)),
+		LY(bus->GetReference(0xFF44)),
+		JOYP(bus->GetReference(0xFF00))
+	{
+		A = 0; B = 0; C = 0; D = 0; E = 0; H = 0; L = 0;
+		F = 0; SP = 0; PC = 0x0; ime_ = true;
+		TClock = 0;
+		halt_ = false; stop_ = false;
+		bus_->Write(0xFF00, 0b11011111);
+	}
+	inline void CPU::reg_dec(RegisterType& reg) {
+		auto temp = reg - 1;
+		auto flag = FLAG_NEG_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((reg & 0xF) - (1 & 0xF)) < 0) << FLAG_HCARRY_SHIFT;
+		// Carry doesn't reset after DEC
+		F &= FLAG_CARRY_MASK;
+		F |= flag;
+		reg = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_inc(RegisterType& reg) {
+		auto temp = reg + 1;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((reg & 0xF) + (1 & 0xF)) > 0xF) << FLAG_HCARRY_SHIFT;
+		// Carry doesn't reset after INC 
+		F &= FLAG_CARRY_MASK;
+		F |= flag;
+		temp &= 0xFF;
+		reg = temp;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_sub(RegisterType& reg) {
+		auto temp = A - reg;
+		auto flag = FLAG_NEG_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0xF) - (reg & 0xF)) < 0) << FLAG_HCARRY_SHIFT;
+		flag |= (temp < 0) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_sbc(RegisterType& reg) {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = A - reg - carry;
+		auto flag = FLAG_NEG_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0xF) - (reg & 0xF) - carry) < 0) << FLAG_HCARRY_SHIFT;
+		flag |= (temp < 0) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_and(RegisterType& reg) {
+		auto temp = A & reg;
+		auto flag = FLAG_HCARRY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_add(RegisterType& reg) {
+		auto temp = A + reg;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0xF) + (reg & 0xF)) > 0xF) << FLAG_HCARRY_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_adc(RegisterType& reg) {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = A + reg + carry;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0xF) + (reg & 0xF) + carry) > 0xF) << FLAG_HCARRY_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_cmp(RegisterType& reg) {
+		auto temp = A - reg;
+		auto flag = FLAG_NEG_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0xF) - (reg & 0xF)) < 0) << FLAG_HCARRY_SHIFT;
+		flag |= (temp < 0) << FLAG_CARRY_SHIFT;
+		F = flag;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_or(RegisterType& reg) {
+		auto temp = A | reg;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::reg_xor(RegisterType& reg) {
+		auto temp = A ^ reg;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	inline void CPU::hl_add(BigRegisterType& big_reg) {
+		uint16_t t = (H << 8) | L;
+		auto temp = t + big_reg;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= (((t & 0xFFF) + (big_reg & 0xFFF)) > 0xFFF) << FLAG_HCARRY_SHIFT;
+		flag |= (temp > 0xFFFF) << FLAG_CARRY_SHIFT;
+		F &= FLAG_ZERO_MASK;
+		F |= flag;
+		temp &= 0xFFFF;
+		H = temp >> 8;
+		L = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_ch(RegisterType reg, unsigned shift) {
+		auto temp = reg & (1 << shift);
+		auto flag = FLAG_HCARRY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		F &= FLAG_CARRY_MASK;
+		F |= flag;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_res(RegisterType& reg, unsigned shift) {
+		reg &= ~(1 << shift);
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_swap(RegisterType& reg) {
+		auto temp = ((reg & 0xF0) >> 4) | ((reg & 0x0F) << 4);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_rrc(RegisterType& reg) {
+		auto temp = (reg >> 1) + ((reg & 0x1) << 7) + ((reg & 0x1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_rl(RegisterType& reg) {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = (reg << 1) + carry;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_rr(RegisterType& reg) {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = (reg >> 1) + (carry << 7) + ((reg & 0x1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_sl(RegisterType& reg) {
+		auto temp = (reg << 1);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_sr(RegisterType& reg) {
+		auto temp = ((reg >> 1) | (reg & 0x80)) + ((reg & 0x1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::bit_srl(RegisterType& reg) {
+		auto temp = (reg >> 1) + ((reg & 0x1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		reg = temp & 0xFF;
+		tTemp = 8;
+	}
+
+	inline void CPU::rst(RegisterType addr) {
+		SP -= 2;
+		bus_->WriteL(SP, PC);
+		PC = addr;
+		tTemp = 16;
+	}
+
+	inline void CPU::bit_set(RegisterType& reg, unsigned shift) {
+		reg |= 1 << shift;
+		tTemp = 8;
+	}
+
+	#pragma region Instructions
+
+	void CPU::ADDAA() {
+		reg_add(A);
+	}
+
+	void CPU::ADDAB() {
+		reg_add(B);
+	}
+
+	void CPU::ADDAC() {
+		reg_add(C);
+	}
+
+	void CPU::ADDAD() {
+		reg_add(D);
+	}
+
+	void CPU::ADDAE() {
+		reg_add(E);
+	}
+
+	void CPU::ADDAH() {
+		reg_add(H);
+	}
+
+	void CPU::ADDAL() {
+		reg_add(L);
+	}
+
+	void CPU::ADDAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_add(t);
+		tTemp = 8;
+	}
+
+	void CPU::ADDA8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_add(t);
+		tTemp = 8;
+	}
+
+	void CPU::ADDHLBC() {
+		uint16_t t = (B << 8) | C;
+		hl_add(t);
+	}
+
+	void CPU::ADDHLDE() {
+		uint16_t t = (D << 8) | E;
+		hl_add(t);
+	}
+
+	void CPU::ADDHLHL() {
+		uint16_t t = (H << 8) | L;
+		hl_add(t);
+	}
+
+	void CPU::ADDHLSP() {
+		hl_add(SP);
+	}
+
+	void CPU::ADDSPD() {
+		int val = bus_->Read(PC);
+		auto temp = SP + ((val ^ 0x80) - 0x80);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= (((SP & 0xF) + (val & 0xF)) > 0xF) << FLAG_HCARRY_SHIFT;
+		flag |= (((SP & 0xFF) + (val & 0xFF)) > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		temp &= 0xFFFF;
+		SP = temp;
+		PC++;
+		tTemp = 16;
+	}
+
+	void CPU::ADCAA() {
+		reg_adc(A);
+	}
+
+	void CPU::ADCAB() {
+		reg_adc(B);
+	}
+
+	void CPU::ADCAC() {
+		reg_adc(C);
+	}
+
+	void CPU::ADCAD() {
+		reg_adc(D);
+	}
+
+	void CPU::ADCAE() {
+		reg_adc(E);
+	}
+
+	void CPU::ADCAH() {
+		reg_adc(H);
+	}
+
+	void CPU::ADCAL() {
+		reg_adc(L);
+	}
+
+	void CPU::ADCAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_adc(t);
+		tTemp = 8;
+	}
+
+	void CPU::ADCA8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_adc(t);
+		tTemp = 8;
+	}
+
+	void CPU::SUBAA() {
+		reg_sub(A);
+	}
+
+	void CPU::SUBAB() {
+		reg_sub(B);
+	}
+
+	void CPU::SUBAC() {
+		reg_sub(C);
+	}
+
+	void CPU::SUBAD() {
+		reg_sub(D);
+	}
+
+	void CPU::SUBAE() {
+		reg_sub(E);
+	}
+
+	void CPU::SUBAH() {
+		reg_sub(H);
+	}
+
+	void CPU::SUBAL() {
+		reg_sub(L);
+	}
+
+	void CPU::SUBAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_sub(t);
+		tTemp = 8;
+	}
+
+	void CPU::SUBA8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_sub(t);
+		tTemp = 8;
+	}
+
+	void CPU::SBCAA() {
+		reg_sbc(A);
+	}
+
+	void CPU::SBCAB() {
+		reg_sbc(B);
+	}
+
+	void CPU::SBCAC() {
+		reg_sbc(C);
+	}
+
+	void CPU::SBCAD() {
+		reg_sbc(D);
+	}
+
+	void CPU::SBCAE() {
+		reg_sbc(E);
+	}
+
+	void CPU::SBCAH() {
+		reg_sbc(H);
+	}
+
+	void CPU::SBCAL() {
+		reg_sbc(L);
+	}
+
+	void CPU::SBCAHL() {
+		uint8_t t = bus_->Read(H << 8 | L);
+		reg_sbc(t);
+		tTemp = 8;
+	}
+
+	void CPU::SBCA8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_sbc(t);
+		tTemp = 8;
+	}
+
+	void CPU::CPAA() {
+		reg_cmp(A);
+	}
+
+	void CPU::CPAB() {
+		reg_cmp(B);
+	}
+
+	void CPU::CPAC() {
+		reg_cmp(C);
+	}
+
+	void CPU::CPAD() {
+		reg_cmp(D);
+	}
+
+	void CPU::CPAE() {
+		reg_cmp(E);
+	}
+
+	void CPU::CPAH() {
+		reg_cmp(H);
+	}
+
+	void CPU::CPAL() {
+		reg_cmp(L);
+	}
+
+
+	void CPU::PUSHBC() {
+		SP -= 2;
+		bus_->WriteL(SP, (B << 8) | C);
+		tTemp = 16;
+	}
+
+	void CPU::PUSHAF() {
+		SP -= 2;
+		bus_->WriteL(SP, (A << 8) | F);
+		tTemp = 16;
+	}
+
+	void CPU::PUSHDE() {
+		SP -= 2;
+		bus_->WriteL(SP, (D << 8) | E);
+		tTemp = 16;
+	}
+
+	void CPU::PUSHHL() {
+		SP -= 2;
+		bus_->WriteL(SP, (H << 8) | L);
+		tTemp = 16;
+	}
+
+	void CPU::POPBC() {
+		B = bus_->Read(SP + 1);
+		C = bus_->Read(SP);
+		SP += 2;
+		tTemp = 12;
+	}
+
+	void CPU::POPAF() {
+		auto temp = bus_->ReadL(SP);
+		A = (temp >> 8) & 0xFF;
+		F = temp & 0xF0;
+		SP += 2;
+		tTemp = 12;
+	}
+
+	void CPU::POPDE() {
+		E = bus_->Read(SP);
+		D = bus_->Read(SP + 1);
+		SP += 2;
+		tTemp = 12;
+	}
+
+	void CPU::POPHL() {
+		L = bus_->Read(SP);
+		H = bus_->Read(SP + 1);
+		SP += 2;
+		tTemp = 12;
+	}
+
+
+	void CPU::LDABC() {
+		int addr = C | (B << 8);
+		A = bus_->Read(addr);
+		tTemp = 8;
+	}
+
+	void CPU::LDADE() {
+		int addr = E | (D << 8);
+		A = bus_->Read(addr);
+		tTemp = 8;
+	}
+
+	void CPU::LDAA() {
+		A = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDAB() {
+		A = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDAC() {
+		A = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDAD() {
+		A = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDAE() {
+		A = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDAH() {
+		A = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDAL() {
+		A = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDBA() {
+		B = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDBB() {
+		B = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDBC() {
+		B = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDBD() {
+		B = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDBE() {
+		B = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDBH() {
+		B = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDBL() {
+		B = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDCA() {
+		C = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDCB() {
+		C = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDCC() {
+		C = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDCD() {
+		C = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDCE() {
+		C = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDCH() {
+		C = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDCL() {
+		C = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDDA() {
+		D = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDDB() {
+		D = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDDC() {
+		D = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDDD() {
+		D = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDDE() {
+		D = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDDH() {
+		D = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDDL() {
+		D = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDEA() {
+		E = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDEB() {
+		E = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDEC() {
+		E = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDED() {
+		E = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDEE() {
+		E = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDEH() {
+		E = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDEL() {
+		E = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDHA() {
+		H = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDHB() {
+		H = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDHC() {
+		H = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDHD() {
+		H = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDHE() {
+		H = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDHH() {
+		H = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDHL() {
+		H = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDLA() {
+		L = A;
+		tTemp = 4;
+	}
+
+	void CPU::LDLB() {
+		L = B;
+		tTemp = 4;
+	}
+
+	void CPU::LDLC() {
+		L = C;
+		tTemp = 4;
+	}
+
+	void CPU::LDLD() {
+		L = D;
+		tTemp = 4;
+	}
+
+	void CPU::LDLE() {
+		L = E;
+		tTemp = 4;
+	}
+
+	void CPU::LDLH() {
+		L = H;
+		tTemp = 4;
+	}
+
+	void CPU::LDLL() {
+		L = L;
+		tTemp = 4;
+	}
+
+	void CPU::LDAHL() {
+		A = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDBHL() {
+		B = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDCHL() {
+		C = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDDHL() {
+		D = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDEHL() {
+		E = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDHHL() {
+		H = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDLHL() {
+		L = bus_->Read((H << 8) | L);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLA() {
+		bus_->Write((H << 8) | L, A);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLB() {
+		bus_->Write((H << 8) | L, B);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLC() {
+		bus_->Write((H << 8) | L, C);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLD() {
+		bus_->Write((H << 8) | L, D);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLE() {
+		bus_->Write((H << 8) | L, E);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLH() {
+		bus_->Write((H << 8) | L, H);
+		tTemp = 8;
+	}
+
+	void CPU::LDHLL() {
+		bus_->Write((H << 8) | L, L);
+		tTemp = 8;
+	}
+
+	void CPU::LDA8() {
+		A = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDB8() {
+		B = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDC8() {
+		C = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDD8() {
+		D = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDE8() {
+		E = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDH8() {
+		H = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDL8() {
+		L = bus_->Read(PC);
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::LDHL8() {
+		bus_->Write((H << 8) | L, bus_->Read(PC));
+		PC++;
+		tTemp = 12;
+	}
+
+	void CPU::LDBCA() {
+		bus_->Write((B << 8) | C, A);
+		tTemp = 8;
+	}
+
+	void CPU::LDDEA() {
+		bus_->Write((D << 8) | E, A);
+		tTemp = 8;
+	}
+
+	void CPU::LD16A() {
+		bus_->Write(bus_->ReadL(PC), A);
+		PC += 2;
+		tTemp = 16;
+	}
+
+	void CPU::LDA16() {
+		A = bus_->Read(bus_->ReadL(PC));
+		PC += 2;
+		tTemp = 16;
+	}
+
+	void CPU::LDBC16() {
+		C = bus_->Read(PC);
+		B = bus_->Read(PC + 1);
+		PC += 2;
+		tTemp = 12;
+	}
+
+	void CPU::LDDE16() {
+		E = bus_->Read(PC);
+		D = bus_->Read(PC + 1);
+		PC += 2;
+		tTemp = 12;
+	}
+
+	void CPU::LDHL16() {
+		L = bus_->Read(PC);
+		H = bus_->Read(PC + 1);
+		PC += 2;
+		tTemp = 12;
+	}
+
+	void CPU::LD16SP() {
+		bus_->Write(bus_->ReadL(PC), SP & 0xFF);
+		bus_->Write(bus_->ReadL(PC) + 1, (SP >> 8) & 0xFF);
+		PC += 2;
+		tTemp = 20;
+	}
+
+	void CPU::INCA() {
+		reg_inc(A);
+	}
+
+	void CPU::INCB() {
+		reg_inc(B);
+	}
+
+	void CPU::INCC() {
+		reg_inc(C);
+	}
+
+	void CPU::INCD() {
+		reg_inc(D);
+	}
+
+	void CPU::INCE() {
+		reg_inc(E);
+	}
+
+	void CPU::INCH() {
+		reg_inc(H);
+	}
+
+	void CPU::INCL() {
+		reg_inc(L);
+	}
+
+	void CPU::INCHLR() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_inc(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 12;
+	}
+
+	void CPU::DECA() {
+		reg_dec(A);
+	}
+
+	void CPU::DECB() {
+		reg_dec(B);
+	}
+
+	void CPU::DECC() {
+		reg_dec(C);
+	}
+
+	void CPU::DECD() {
+		reg_dec(D);
+	}
+
+	void CPU::DECE() {
+		reg_dec(E);
+	}
+
+	void CPU::DECH() {
+		reg_dec(H);
+	}
+
+	void CPU::DECL() {
+		reg_dec(L);
+	}
+
+	void CPU::DECHLR() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_dec(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 12;
+	}
+
+	void CPU::INCBC() {
+		// TODO: big reg inc
+		C = (C + 1) & 0xFF;
+		if (!C) {
+			B = (B + 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::INCDE() {
+		E = (E + 1) & 0xFF;
+		if (!E) {
+			D = (D + 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::INCHL() {
+		L = (L + 1) & 0xFF;
+		if (!L) {
+			H = (H + 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::INCSP() {
+		SP++;
+		tTemp = 8;
+	}
+
+	void CPU::DECBC() {
+		C = (C - 1) & 0xFF;
+		if (C == 0xFF) {
+			B = (B - 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::DECDE() {
+		E = (E - 1) & 0xFF;
+		if (E == 0xFF) {
+			D = (D - 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::DECHL() {
+		L = (L - 1) & 0xFF;
+		if (L == 0xFF) {
+			H = (H - 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::DECSP() {
+		SP = (SP - 1) & 0xFFFF;
+		tTemp = 8;
+	}
+
+	void CPU::JP16() {
+		PC = bus_->ReadL(PC);
+		tTemp = 16;
+	}
+
+	void CPU::JPHL() {
+		PC = (H << 8) | L;
+		tTemp = 4;
+	}
+
+	void CPU::JPNZ16() {
+		tTemp = 12;
+		if ((F & 0x80) == 0x00) {
+			PC = bus_->ReadL(PC);
+			tTemp += 4;
+		}
+		else
+			PC += 2;
+	}
+
+	void CPU::JPZ16() {
+		tTemp = 12;
+		if ((F & 0x80) == 0x80) {
+			PC = bus_->ReadL(PC);
+			tTemp += 4;
+		}
+		else
+			PC += 2;
+	}
+
+	void CPU::JPNC16() {
+		tTemp = 12;
+		if ((F & 0x10) == 0x00) {
+			PC = bus_->ReadL(PC);
+			tTemp += 4;
+		}
+		else
+			PC += 2;
+	}
+
+	void CPU::JPC16() {
+		tTemp = 12;
+		if ((F & 0x10) == 0x10) {
+			PC = bus_->ReadL(PC);
+			tTemp += 4;
+		}
+		else
+			PC += 2;
+	}
+
+	void CPU::JR8() {
+		int i = bus_->Read(PC);
+		if (i >= 0x80)
+			i = -((~i + 1) & 255);
+		PC++;
+		tTemp = 8;
+		PC += i;
+		tTemp += 4;
+	}
+
+	void CPU::JRNZ8() {
+		int i = bus_->Read(PC);
+		PC++;
+		if ((F & (FLAG_ZERO_MASK)) == 0) {
+			PC += ((i ^ 0x80) - 0x80);
+			tTemp = 12;
+		}
+		else {
+			tTemp = 8;
+		}
+	}
+
+	void CPU::JRZ8() {
+		int i = bus_->Read(PC);
+		if (i >= 0x80)
+			i = -((~i + 1) & 255);
+		PC++;
+		tTemp = 8;
+		if ((F & 0x80) == 0x80) {
+			PC += i;
+			; tTemp += 4;
+		}
+	}
+
+	void CPU::JRNC8() {
+		int i = bus_->Read(PC);
+		if (i >= 0x80)
+			i = -((~i + 1) & 255);
+		PC++;
+		tTemp = 8;
+		if ((F & 0x10) == 0x00) {
+			PC += i;
+			tTemp += 4;
+		}
+	}
+
+	void CPU::JRC8() {
+		int i = bus_->Read(PC);
+		if (i >= 0x80)
+			i = -((~i + 1) & 255);
+		PC++;
+		tTemp = 8;
+		if ((F & 0x10) == 0x10) {
+			PC += i;
+			tTemp += 4;
+		}
+	}
+
+	void CPU::ANDA() {
+		reg_and(A);
+	}
+
+	void CPU::ANDB() {
+		reg_and(B);
+	}
+
+	void CPU::ANDC() {
+		reg_and(C);
+	}
+
+	void CPU::ANDD() {
+		reg_and(D);
+	}
+
+	void CPU::ANDE() {
+		reg_and(E);
+	}
+
+	void CPU::ANDH() {
+		reg_and(H);
+	}
+
+	void CPU::ANDL() {
+		reg_and(L);
+	}
+
+	void CPU::ANDHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_and(t);
+		tTemp = 8;
+	}
+
+	void CPU::AND8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_and(t);
+		tTemp = 8;
+	}
+
+	void CPU::ORA() {
+		reg_or(A);
+	}
+
+	void CPU::ORB() {
+		reg_or(B);
+	}
+
+	void CPU::ORC() {
+		reg_or(C);
+	}
+
+	void CPU::ORD() {
+		reg_or(D);
+	}
+
+	void CPU::ORE() {
+		reg_or(E);
+	}
+
+	void CPU::ORH() {
+		reg_or(H);
+	}
+
+	void CPU::ORL() {
+		reg_or(L);
+	}
+
+	void CPU::ORHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_or(t);
+		tTemp = 8;
+	}
+
+	void CPU::OR8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_or(t);
+		tTemp = 8;
+	}
+
+	void CPU::XORA() {
+		reg_xor(A);
+	}
+
+	void CPU::XORB() {
+		reg_xor(B);
+	}
+
+	void CPU::XORC() {
+		reg_xor(C);
+	}
+
+	void CPU::XORD() {
+		reg_xor(D);
+	}
+
+	void CPU::XORE() {
+		reg_xor(E);
+	}
+
+	void CPU::XORH() {
+		reg_xor(H);
+	}
+
+	void CPU::XORL() {
+		reg_xor(L);
+	}
+
+	void CPU::XORHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_xor(t);
+		tTemp = 8;
+	}
+
+	void CPU::XOR8() {
+		uint8_t t = bus_->Read(PC++);
+		reg_xor(t);
+		tTemp = 8;
+	}
+
+	void CPU::NOP() {
+		tTemp = 4;
+	}
+
+	void CPU::STOP() {
+		PC++;
+	}
+
+	void CPU::RET() {
+		PC = bus_->ReadL(SP);
+		SP += 2;
+		tTemp = 12;
+	}
+
+	void CPU::RETI() {
+		ime_ = true;
+		PC = bus_->ReadL(SP);
+		SP += 2;
+		tTemp = 16;
+	}
+
+	void CPU::RETNZ() {
+		tTemp = 8;
+		if ((F & 0x80) == 0x00) {
+			PC = bus_->ReadL(SP);
+			SP += 2;
+			; tTemp += 12;
+		}
+	}
+
+	void CPU::RETZ() {
+		tTemp = 8;
+		if ((F & 0x80) == 0x80) {
+			PC = bus_->ReadL(SP);
+			SP += 2;
+			; tTemp += 12;
+		}
+	}
+
+	void CPU::RETNC() {
+		tTemp = 8;
+		if ((F & 0x10) == 0x00) {
+			PC = bus_->ReadL(SP);
+			SP += 2;
+			; tTemp += 12;
+		}
+	}
+
+	void CPU::RETC() {
+		tTemp = 8;
+		if ((F & 0x10) == 0x10) {
+			PC = bus_->ReadL(SP);
+			SP += 2;
+			; tTemp += 12;
+		}
+	}
+
+	void CPU::RST0() {
+		rst(0x00);
+	}
+
+	void CPU::RST8() {
+		rst(0x08);
+	}
+
+	void CPU::RST10() {
+		rst(0x10);
+	}
+
+	void CPU::RST18() {
+		rst(0x18);
+	}
+
+	void CPU::RST20() {
+		rst(0x20);
+	}
+
+	void CPU::RST28() {
+		rst(0x28);
+	}
+
+	void CPU::RST30() {
+		rst(0x30);
+	}
+
+	void CPU::RST38() {
+		rst(0x38);
+	}
+
+	void CPU::LDSPHL() {
+		SP = (H << 8) | L;
+		tTemp = 8;
+	}
+
+	void CPU::LDAMC() {
+		A = bus_->Read(0xFF00 + C);
+		tTemp = 8;
+	}
+
+	void CPU::DI() {
+		ime_ = false; tTemp = 4;
+	}
+
+	void CPU::EI() {
+		ime_ = true; tTemp = 4;
+	}
+
+	void CPU::RLA() {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = (A << 1) + carry;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	void CPU::RLCA() {
+		auto temp = (A << 1) + (A >> 7);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		A = temp & 0xFF;
+		tTemp = 4;
+	}
+
+	void CPU::RRA() {
+		bool carry = F & FLAG_CARRY_MASK;
+		auto temp = (A >> 1) + ((carry) << 7) + ((A & 1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag |= (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		temp &= 0xFF;
+		A = temp;
+		tTemp = 4;
+	}
+
+	void CPU::RRCA() {
+		auto temp = (A >> 1) + ((A & 1) << 7) + ((A & 1) << 8);
+		auto flag = FLAG_EMPTY_MASK;
+		flag += (temp > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		temp &= 0xFF;
+		A = temp;
+		tTemp = 4;
+	}
+
+	void CPU::CALL16() {
+		SP -= 2;
+		bus_->WriteL(SP, PC + 2);
+		PC = bus_->ReadL(PC);
+		tTemp = 24;
+	}
+
+	void CPU::CALLNZ16() {
+		if (!(F & FLAG_ZERO_MASK)) {
+			SP -= 2;
+			bus_->WriteL(SP, PC + 2);
+			PC = bus_->ReadL(PC);
+			; tTemp += 12;
+		}
+		else {
+			PC += 2;
+		}
+		; tTemp += 12;
+	}
+
+	void CPU::CALLZ16() {
+		if ((F & 0x80) == 0x80) {
+			SP -= 2;
+			bus_->WriteL(SP, PC + 2);
+			PC = bus_->ReadL(PC);
+			; tTemp += 8;
+		}
+		else {
+			PC += 2;
+		}
+		tTemp = 12;
+	}
+
+	void CPU::CALLNC16() {
+		if ((F & 0x10) == 0x00) {
+			SP -= 2;
+			bus_->WriteL(SP, PC + 2);
+			PC = bus_->ReadL(PC);
+			; tTemp += 8;
+		}
+		else {
+			PC += 2;
+		}
+		tTemp = 12;
+	}
+
+	void CPU::CALLC16() {
+		if ((F & 0x10) == 0x10) {
+			SP -= 2;
+			bus_->WriteL(SP, PC + 2);
+			PC = bus_->ReadL(PC);
+			; tTemp += 8;
+		}
+		else {
+			PC += 2;
+		}
+		tTemp = 12;
+	}
+
+	void CPU::LDSP16() {
+		SP = bus_->ReadL(PC);
+		PC += 2;
+		tTemp = 12;
+	}
+
+	void CPU::LDDHLA() {
+		bus_->Write((H << 8) | L, A);
+		L = (L - 1) & 0xFF;
+		if (L == 0xFF) {
+			H = (H - 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::LDDAHL() {
+		A = bus_->Read((H << 8) | L);
+		L = (L - 1) & 0xFF;
+		if (L == 0xFF) {
+			H = (H - 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::LDIHLA() {
+		bus_->Write((H << 8) | L, A);
+		L = (L + 1) & 0xFF;
+		if (!L) {
+			H = (H + 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::LDIAHL() {
+		A = bus_->Read((H << 8) | L);
+		L = (L + 1) & 0xFF;
+		if (!L) {
+			H = (H + 1) & 0xFF;
+		}
+		tTemp = 8;
+	}
+
+	void CPU::DAA() {
+		int temp = A;
+		uint16_t corr = 0;
+		corr |= ((F & FLAG_HCARRY_MASK) ? 0x06 : 0x00);
+		corr |= ((F & FLAG_CARRY_MASK) ? 0x60 : 0x00);
+		if (F & FLAG_NEG_MASK) {
+			temp -= corr;
+		}
+		else {
+			corr |= ((temp & 0x0F) > 0x09) ? 0x06 : 0;
+			corr |= (temp > 0x99) ? 0x60 : 0;
+			temp += corr;
+		}
+		uint16_t flag = FLAG_EMPTY_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= ((corr & 0x60) != 0) << FLAG_CARRY_SHIFT;
+		F &= FLAG_NEG_MASK;
+		F |= flag;
+		temp &= 0xFF;
+		A = temp;
+		tTemp = 4;
+	}
+
+	void CPU::CPL() {
+		A = (~A) & 0xFF;
+		F &= 0b1001'0000;
+		F |= 0b0110'0000;
+		tTemp = 4;
+	}
+
+	void CPU::SCF() {
+		F &= 0b1000'0000;
+		F |= 0b0001'0000;
+		tTemp = 4;
+	}
+
+	void CPU::CCF() {
+		auto flag = (F & 0b0001'0000) ^ 0b0001'0000;
+		F &= 0b1000'0000;
+		F |= flag;
+		tTemp = 4;
+	}
+
+	void CPU::LDHLSPD() {
+		auto val = bus_->Read(PC);
+		auto HL = SP + ((val ^ 0x80) - 0x80);
+		H = (HL >> 8) & 0xFF;
+		L = HL & 0xFF;
+		auto flag = FLAG_EMPTY_MASK;
+		flag |=	(((SP & 0xF) + (val & 0xF)) > 0xF) << FLAG_HCARRY_SHIFT;
+		flag |= (((SP & 0xFF) + (val & 0xFF)) > 0xFF) << FLAG_CARRY_SHIFT;
+		F = flag;
+		PC++;
+		tTemp = 12;
+	}
+
+	void CPU::LDHA8() {
+		A = bus_->Read(0xFF00 + bus_->Read(PC));
+		PC++;
+		tTemp = 12;
+	}
+
+	void CPU::LDH8A() {
+		bus_->Write(0xFF00 + bus_->Read(PC), A);
+		PC++;
+		tTemp = 12;
+	}
+
+	void CPU::LDHCA() {
+		bus_->Write(0xFF00 + C, A);
+		tTemp = 8;
+	}
+
+	void CPU::EXT() {
+		int i = bus_->Read(PC);
+		PC++;
+		PC &= 0xFFFF;
+		if (i <= 0xFF) {
+			(this->*CBInstructions[i].op)();
+		}
+	}
+
+	void CPU::CPAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		reg_cmp(t);
+		tTemp = 8;
+	}
+
+	void CPU::CP8() {
+		uint16_t m = bus_->Read(PC);
+		int temp = A - m;
+		auto flag = FLAG_NEG_MASK;
+		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
+		flag |= (((A & 0x0F) - (m & 0x0F)) < 0) << FLAG_HCARRY_SHIFT;
+		flag |= (temp < 0) << FLAG_CARRY_SHIFT;
+		F = flag;
+		PC++;
+		tTemp = 8;
+	}
+
+	void CPU::HALT() {
+		halt_ = true;
+	}
+
+	void CPU::XXX() {
+		stop_ = true;
+	}
+
+	void CPU::RLCB() {
+		int i = B & 0x80 ? 1 : 0;
+		int o = B & 0x80 ? 0x10 : 0;
+		B = (B << 1) + i;
+		B &= 0xFF;
+		F = B ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCC() {
+		int i = C & 0x80 ? 1 : 0;
+		int o = C & 0x80 ? 0x10 : 0;
+		C = (C << 1) + i;
+		C &= 0xFF;
+		F = C ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCD() {
+		int i = D & 0x80 ? 1 : 0;
+		int o = D & 0x80 ? 0x10 : 0;
+		D = (D << 1) + i;
+		D &= 0xFF;
+		F = D ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCE() {
+		int i = E & 0x80 ? 1 : 0;
+		int o = E & 0x80 ? 0x10 : 0;
+		E = (E << 1) + i;
+		E &= 0xFF;
+		F = E ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCH() {
+		int i = H & 0x80 ? 1 : 0;
+		int o = H & 0x80 ? 0x10 : 0;
+		H = (H << 1) + i;
+		H &= 0xFF;
+		F = H ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCL() {
+		int i = L & 0x80 ? 1 : 0;
+		int o = L & 0x80 ? 0x10 : 0;
+		L = (L << 1) + i;
+		L &= 0xFF;
+		F = L ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCAr() {
+		int i = A & 0x80 ? 1 : 0;
+		int o = A & 0x80 ? 0x10 : 0;
+		A = (A << 1) + i;
+		A &= 0xFF;
+		F = A ? 0 : 0x80;
+		F = (F & 0xEF) + o;
+		tTemp = 8;
+	}
+
+	void CPU::RLCHL() {
+		int i = bus_->Read((H << 8) | L);
+		int ci = (i & 0x80) ? 1 : 0;
+		int co = (i & 0x80) ? 0x10 : 0;
+		i = (i << 1) + ci;
+		i &= 0xFF;
+		F = (i) ? 0 : 0x80;
+		bus_->Write((H << 8) | L, i);
+		F = (F & 0xEF) + co;
+		tTemp = 16;
+	}
+
+	void CPU::RRCB() {
+		bit_rrc(B);
+	}
+
+	void CPU::RRCC() {
+		bit_rrc(C);
+	}
+
+	void CPU::RRCD() {
+		bit_rrc(D);
+	}
+
+	void CPU::RRCE() {
+		bit_rrc(E);
+	}
+
+	void CPU::RRCH() {
+		bit_rrc(H);
+	}
+
+	void CPU::RRCL() {
+		bit_rrc(L);
+	}
+
+	void CPU::RRCAr() {
+		bit_rrc(A);
+	}
+
+	void CPU::RRCHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_rrc(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::RLB() {
+		bit_rl(B);
+	}
+
+	void CPU::RLC() {
+		bit_rl(C);
+	}
+
+	void CPU::RLD() {
+		bit_rl(D);
+	}
+
+	void CPU::RLE() {
+		bit_rl(E);
+	}
+
+	void CPU::RLH() {
+		bit_rl(H);
+	}
+
+	void CPU::RLL() {
+		bit_rl(L);
+	}
+
+	void CPU::RLAr() {
+		bit_rl(A);
+	}
+
+	void CPU::RLHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_rl(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::RRB() {
+		bit_rr(B);
+	}
+
+	void CPU::RRC() {
+		bit_rr(C);
+	}
+
+	void CPU::RRD() {
+		bit_rr(D);
+	}
+
+	void CPU::RRE() {
+		bit_rr(E);
+	}
+
+	void CPU::RRH() {
+		bit_rr(H);
+	}
+
+	void CPU::RRL() {
+		bit_rr(L);
+	}
+
+	void CPU::RRAr() {
+		bit_rr(A);
+	}
+
+	void CPU::RRHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_rr(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::SLAB() {
+		bit_sl(B);
+	}
+
+	void CPU::SLAC() {
+		bit_sl(C);
+	}
+
+	void CPU::SLAD() {
+		bit_sl(D);
+	}
+
+	void CPU::SLAE() {
+		bit_sl(E);
+	}
+
+	void CPU::SLAH() {
+		bit_sl(H);
+	}
+
+	void CPU::SLAL() {
+		bit_sl(L);
+	}
+
+	void CPU::SLAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_sl(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::SLAA() {
+		bit_sl(A);
+	}
+
+	void CPU::SRAB() {
+		bit_sr(B);
+	}
+
+	void CPU::SRAC() {
+		bit_sr(C);
+	}
+
+	void CPU::SRAD() {
+		bit_sr(D);
+	}
+
+	void CPU::SRAE() {
+		bit_sr(E);
+	}
+
+	void CPU::SRAH() {
+		bit_sr(H);
+	}
+
+	void CPU::SRAL() {
+		bit_sr(L);
+	}
+
+	void CPU::SRAHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_sr(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::SRAA() {
+		bit_sr(A);
+	}
+
+	void CPU::SWAPB() {
+		bit_swap(B);
+	}
+
+	void CPU::SWAPC() {
+		bit_swap(C);
+	}
+
+	void CPU::SWAPD() {
+		bit_swap(D);
+	}
+
+	void CPU::SWAPE() {
+		bit_swap(E);
+	}
+
+	void CPU::SWAPH() {
+		bit_swap(H);
+	}
+
+	void CPU::SWAPL() {
+		bit_swap(L);
+	}
+
+	void CPU::SWAPHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_swap(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::SWAPA() {
+		bit_swap(A);
+	}
+
+	void CPU::SRLB() {
+		bit_srl(B);
+	}
+
+	void CPU::SRLC() {
+		bit_srl(C);
+	}
+
+	void CPU::SRLD() {
+		bit_srl(D);
+	}
+
+	void CPU::SRLE() {
+		bit_srl(E);
+	}
+
+	void CPU::SRLH() {
+		bit_srl(H);
+	}
+
+	void CPU::SRLL() {
+		bit_srl(L);
+	}
+
+	void CPU::SRLHL() {
+		uint8_t t = bus_->Read((H << 8) | L);
+		bit_srl(t);
+		bus_->Write((H << 8) | L, t);
+		tTemp = 16;
+	}
+
+	void CPU::SRLA() {
+		bit_srl(A);
+	}
+
+	void CPU::BIT0B() {
+		bit_ch(B, 0);
+	}
+
+	void CPU::BIT0C() {
+		bit_ch(C, 0);
+	}
+
+	void CPU::BIT0D() {
+		bit_ch(D, 0);
+	}
+
+	void CPU::BIT0E() {
+		bit_ch(E, 0);
+	}
+
+	void CPU::BIT0H() {
+		bit_ch(H, 0);
+	}
+
+	void CPU::BIT0L() {
+		bit_ch(L, 0);
+	}
+
+	void CPU::BIT0A() {
+		bit_ch(A, 0);
+	}
+
+	void CPU::BIT0M() {
+		bit_ch(bus_->Read((H << 8) | L), 0);
+		tTemp = 12;
+	}
+
+	void CPU::BIT1B() {
+		bit_ch(B, 1);
+	}
+
+	void CPU::BIT1C() {
+		bit_ch(C, 1);
+	}
+
+	void CPU::BIT1D() {
+		bit_ch(D, 1);
+	}
+
+	void CPU::BIT1E() {
+		bit_ch(E, 1);
+	}
+
+	void CPU::BIT1H() {
+		bit_ch(H, 1);
+	}
+
+	void CPU::BIT1L() {
+		bit_ch(L, 1);
+	}
+
+	void CPU::BIT1A() {
+		bit_ch(A, 1);
+	}
+
+	void CPU::BIT1M() {
+		bit_ch(bus_->Read((H << 8) | L), 1);
+		tTemp = 12;
+	}
+
+	void CPU::BIT2B() {
+		bit_ch(B, 2);
+	}
+
+	void CPU::BIT2C() {
+		bit_ch(C, 2);
+	}
+
+	void CPU::BIT2D() {
+		bit_ch(D, 2);
+	}
+
+	void CPU::BIT2E() {
+		bit_ch(E, 2);
+	}
+
+	void CPU::BIT2H() {
+		bit_ch(H, 2);
+	}
+
+	void CPU::BIT2L() {
+		bit_ch(L, 2);
+	}
+
+	void CPU::BIT2A() {
+		bit_ch(A, 2);
+	}
+
+	void CPU::BIT2M() {
+		bit_ch(bus_->Read((H << 8) | L), 2);
+		tTemp = 12;
+	}
+
+	void CPU::BIT3B() {
+		bit_ch(B, 3);
+	}
+
+	void CPU::BIT3C() {
+		bit_ch(C, 3);
+	}
+
+	void CPU::BIT3D() {
+		bit_ch(D, 3);
+	}
+
+	void CPU::BIT3E() {
+		bit_ch(E, 3);
+	}
+
+	void CPU::BIT3H() {
+		bit_ch(H, 3);
+	}
+
+	void CPU::BIT3L() {
+		bit_ch(L, 3);
+	}
+
+	void CPU::BIT3A() {
+		bit_ch(A, 3);
+	}
+
+	void CPU::BIT3M() {
+		bit_ch(bus_->Read((H << 8) | L), 3);
+		tTemp = 12;
+	}
+
+	void CPU::BIT4B() {
+		bit_ch(B, 4);
+	}
+
+	void CPU::BIT4C() {
+		bit_ch(C, 4);
+	}
+
+	void CPU::BIT4D() {
+		bit_ch(D, 4);
+	}
+
+	void CPU::BIT4E() {
+		bit_ch(E, 4);
+	}
+
+	void CPU::BIT4H() {
+		bit_ch(H, 4);
+	}
+
+	void CPU::BIT4L() {
+		bit_ch(L, 4);
+	}
+
+	void CPU::BIT4A() {
+		bit_ch(A, 4);
+	}
+
+	void CPU::BIT4M() {
+		bit_ch(bus_->Read((H << 8) | L), 4);
+		tTemp = 12;
+	}
+
+	void CPU::BIT5B() {
+		bit_ch(B, 5);
+	}
+
+	void CPU::BIT5C() {
+		bit_ch(C, 5);
+	}
+
+	void CPU::BIT5D() {
+		bit_ch(D, 5);
+	}
+
+	void CPU::BIT5E() {
+		bit_ch(E, 5);
+	}
+
+	void CPU::BIT5H() {
+		bit_ch(H, 5);
+	}
+
+	void CPU::BIT5L() {
+		bit_ch(L, 5);
+	}
+
+	void CPU::BIT5A() {
+		bit_ch(A, 5);
+	}
+
+	void CPU::BIT5M() {
+		bit_ch(bus_->Read((H << 8) | L), 5);
+		tTemp = 12;
+	}
+
+	void CPU::BIT6B() {
+		bit_ch(B, 6);
+	}
+
+	void CPU::BIT6C() {
+		bit_ch(C, 6);
+	}
+
+	void CPU::BIT6D() {
+		bit_ch(D, 6);
+	}
+
+	void CPU::BIT6E() {
+		bit_ch(E, 6);
+	}
+
+	void CPU::BIT6H() {
+		bit_ch(H, 6);
+	}
+
+	void CPU::BIT6L() {
+		bit_ch(L, 6);
+	}
+
+	void CPU::BIT6A() {
+		bit_ch(A, 6);
+	}
+
+	void CPU::BIT6M() {
+		bit_ch(bus_->Read((H << 8) | L), 6);
+		tTemp = 12;
+	}
+
+	void CPU::BIT7B() {
+		bit_ch(B, 7);
+	}
+
+	void CPU::BIT7C() {
+		bit_ch(C, 7);
+	}
+
+	void CPU::BIT7D() {
+		bit_ch(D, 7);
+	}
+
+	void CPU::BIT7E() {
+		bit_ch(E, 7);
+	}
+
+	void CPU::BIT7H() {
+		bit_ch(H, 7);
+	}
+
+	void CPU::BIT7L() {
+		bit_ch(L, 7);
+	}
+
+	void CPU::BIT7A() {
+		bit_ch(A, 7);
+	}
+
+	void CPU::BIT7M() {
+		bit_ch(bus_->Read((H << 8) | L), 7);
+		tTemp = 12;
+	}
+
+	void CPU::RES0B(){
+		bit_res(B, 0);
+	}
+
+	void CPU::RES0C() {
+		bit_res(C, 0);
+	}
+
+	void CPU::RES0D() {
+		bit_res(D, 0);
+	}
+
+	void CPU::RES0E() {
+		bit_res(E, 0);
+	}
+
+	void CPU::RES0H() {
+		bit_res(H, 0);
+	}
+
+	void CPU::RES0L() {
+		bit_res(L, 0);
+	}
+
+	void CPU::RES0HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 0);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES0A() {
+		bit_res(A, 0);
+	}
+
+	void CPU::RES1B() {
+		bit_res(B, 1);
+	}
+
+	void CPU::RES1C() {
+		bit_res(C, 1);
+	}
+
+	void CPU::RES1D() {
+		bit_res(D, 1);
+	}
+
+	void CPU::RES1E() {
+		bit_res(E, 1);
+	}
+
+	void CPU::RES1H() {
+		bit_res(H, 1);
+	}
+
+	void CPU::RES1L() {
+		bit_res(L, 1);
+	}
+
+	void CPU::RES1HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 1);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES1A() {
+		bit_res(A, 1);
+	}
+
+	void CPU::RES2B() {
+		bit_res(B, 2);
+	}
+
+	void CPU::RES2C() {
+		bit_res(C, 2);
+	}
+
+	void CPU::RES2D() {
+		bit_res(D, 2);
+	}
+
+	void CPU::RES2E() {
+		bit_res(E, 2);
+	}
+
+	void CPU::RES2H() {
+		bit_res(H, 2);
+	}
+
+	void CPU::RES2L() {
+		bit_res(L, 2);
+	}
+
+	void CPU::RES2HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 2);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES2A() {
+		bit_res(A, 2);
+	}
+
+	void CPU::RES3B() {
+		bit_res(B, 3);
+	}
+
+	void CPU::RES3C() {
+		bit_res(C, 3);
+	}
+
+	void CPU::RES3D() {
+		bit_res(D, 3);
+	}
+
+	void CPU::RES3E() {
+		bit_res(E, 3);
+	}
+
+	void CPU::RES3H() {
+		bit_res(H, 3);
+	}
+
+	void CPU::RES3L() {
+		bit_res(L, 3);
+	}
+
+	void CPU::RES3HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 3);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES3A() {
+		bit_res(A, 3);
+	}
+
+	void CPU::RES4B() {
+		bit_res(B, 4);
+	}
+
+	void CPU::RES4C() {
+		bit_res(C, 4);
+	}
+
+	void CPU::RES4D() {
+		bit_res(D, 4);
+	}
+
+	void CPU::RES4E() {
+		bit_res(E, 4);
+	}
+
+	void CPU::RES4H() {
+		bit_res(H, 4);
+	}
+
+	void CPU::RES4L() {
+		bit_res(L, 4);
+	}
+
+	void CPU::RES4HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 4);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES4A() {
+		bit_res(A, 4);
+	}
+
+	void CPU::RES5B() {
+		bit_res(B, 5);
+	}
+
+	void CPU::RES5C() {
+		bit_res(C, 5);
+	}
+
+	void CPU::RES5D() {
+		bit_res(D, 5);
+	}
+
+	void CPU::RES5E() {
+		bit_res(E, 5);
+	}
+
+	void CPU::RES5H() {
+		bit_res(H, 5);
+	}
+
+	void CPU::RES5L() {
+		bit_res(L, 5);
+	}
+
+	void CPU::RES5HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 5);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES5A() {
+		bit_res(A, 5);
+	}
+
+	void CPU::RES6B() {
+		bit_res(B, 6);
+	}
+
+	void CPU::RES6C() {
+		bit_res(C, 6);
+	}
+
+	void CPU::RES6D() {
+		bit_res(D, 6);
+	}
+
+	void CPU::RES6E() {
+		bit_res(E, 6);
+	}
+
+	void CPU::RES6H() {
+		bit_res(H, 6);
+	}
+
+	void CPU::RES6L() {
+		bit_res(L, 6);
+	}
+
+	void CPU::RES6HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 6);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES6A() {
+		bit_res(A, 6);
+	}
+
+	void CPU::RES7B() {
+		bit_res(B, 7);
+	}
+
+	void CPU::RES7C() {
+		bit_res(C, 7);
+	}
+
+	void CPU::RES7D() {
+		bit_res(D, 7);
+	}
+
+	void CPU::RES7E() {
+		bit_res(E, 7);
+	}
+
+	void CPU::RES7H() {
+		bit_res(H, 7);
+	}
+
+	void CPU::RES7L() {
+		bit_res(L, 7);
+	}
+
+	void CPU::RES7HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_res(t, 7);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::RES7A() {
+		bit_res(A, 7);
+	}
+
+	void CPU::SET0B() {
+		bit_set(B, 0);
+	}
+
+	void CPU::SET0C() {
+		bit_set(C, 0);
+	}
+
+	void CPU::SET0D() {
+		bit_set(D, 0);
+	}
+
+	void CPU::SET0E() {
+		bit_set(E, 0);
+	}
+
+	void CPU::SET0H() {
+		bit_set(H, 0);
+	}
+
+	void CPU::SET0L() {
+		bit_set(L, 0);
+	}
+
+	void CPU::SET0HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 0);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET0A() {
+		bit_set(A, 0);
+	}
+
+	void CPU::SET1B() {
+		bit_set(B, 1);
+	}
+
+	void CPU::SET1C() {
+		bit_set(C, 1);
+	}
+
+	void CPU::SET1D() {
+		bit_set(D, 1);
+	}
+
+	void CPU::SET1E() {
+		bit_set(E, 1);
+	}
+
+	void CPU::SET1H() {
+		bit_set(H, 1);
+	}
+
+	void CPU::SET1L() {
+		bit_set(L, 1);
+	}
+
+	void CPU::SET1HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 1);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET1A() {
+		bit_set(A, 1);
+	}
+
+	void CPU::SET2B() {
+		bit_set(B, 2);
+	}
+
+	void CPU::SET2C() {
+		bit_set(C, 2);
+	}
+
+	void CPU::SET2D() {
+		bit_set(D, 2);
+	}
+
+	void CPU::SET2E() {
+		bit_set(E, 2);
+	}
+
+	void CPU::SET2H() {
+		bit_set(H, 2);
+	}
+
+	void CPU::SET2L() {
+		bit_set(L, 2);
+	}
+
+	void CPU::SET2HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 2);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET2A() {
+		bit_set(A, 2);
+	}
+
+	void CPU::SET3B() {
+		bit_set(B, 3);
+	}
+
+	void CPU::SET3C() {
+		bit_set(C, 3);
+	}
+
+	void CPU::SET3D() {
+		bit_set(D, 3);
+	}
+
+	void CPU::SET3E() {
+		bit_set(E, 3);
+	}
+
+	void CPU::SET3H() {
+		bit_set(H, 3);
+	}
+
+	void CPU::SET3L() {
+		bit_set(L, 3);
+	}
+
+	void CPU::SET3HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 3);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET3A() {
+		bit_set(A, 3);
+	}
+
+	void CPU::SET4B() {
+		bit_set(B, 4);
+	}
+
+	void CPU::SET4C() {
+		bit_set(C, 4);
+	}
+
+	void CPU::SET4D() {
+		bit_set(D, 4);
+	}
+
+	void CPU::SET4E() {
+		bit_set(E, 4);
+	}
+
+	void CPU::SET4H() {
+		bit_set(H, 4);
+	}
+
+	void CPU::SET4L() {
+		bit_set(L, 4);
+	}
+
+	void CPU::SET4HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 4);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET4A() {
+		bit_set(A, 4);
+	}
+
+	void CPU::SET5B() {
+		bit_set(B, 5);
+	}
+
+	void CPU::SET5C() {
+		bit_set(C, 5);
+	}
+
+	void CPU::SET5D() {
+		bit_set(D, 5);
+	}
+
+	void CPU::SET5E() {
+		bit_set(E, 5);
+	}
+
+	void CPU::SET5H() {
+		bit_set(H, 5);
+	}
+
+	void CPU::SET5L() {
+		bit_set(L, 5);
+	}
+
+	void CPU::SET5HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 5);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET5A() {
+		bit_set(A, 5);
+	}
+
+	void CPU::SET6B() {
+		bit_set(B, 6);
+	}
+
+	void CPU::SET6C() {
+		bit_set(C, 6);
+	}
+
+	void CPU::SET6D() {
+		bit_set(D, 6);
+	}
+
+	void CPU::SET6E() {
+		bit_set(E, 6);
+	}
+
+	void CPU::SET6H() {
+		bit_set(H, 6);
+	}
+
+	void CPU::SET6L() {
+		bit_set(L, 6);
+	}
+
+	void CPU::SET6HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 6);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET6A() {
+		bit_set(A, 6);
+	}
+
+	void CPU::SET7B() {
+		bit_set(B, 7);
+	}
+
+	void CPU::SET7C() {
+		bit_set(C, 7);
+	}
+
+	void CPU::SET7D() {
+		bit_set(D, 7);
+	}
+
+	void CPU::SET7E() {
+		bit_set(E, 7);
+	}
+
+	void CPU::SET7H() {
+		bit_set(H, 7);
+	}
+
+	void CPU::SET7L() {
+		bit_set(L, 7);
+	}
+
+	void CPU::SET7HL() {
+		auto t = bus_->Read((H << 8) | L);
+		bit_set(t, 7);
+		bus_->Write((H << 8) | L, t);
+		; tTemp += 8;
+	}
+
+	void CPU::SET7A() {
+		bit_set(A, 7);
+	}
+	#pragma endregion
+
+	void CPU::Reset() {
+		A = 0; F = 0;
+		B = 0; C = 0;
+		D = 0; E = 0;
+		H = 0; L = 0;
+		SP = 0;
+		PC = 0;
+		TClock = 0;
+		halt_ = false; stop_ = false;
+		JOYP = 0b1110'1111;
+		Oscillator = 0;
+		DIVIDER = 0;
+		div_reset_index_ = -1;
+		TimerCounter = 0;
+		old_tac_ = 0;
+	}
+
+	int CPU::Update() {
+		if (halt_) {
+			PC--;
+		}
+		auto old_if = IF;
+		(this->*Instructions[bus_->Read(PC++)].op)();
+		// Maybe needed to confirm tTemp == 4 also?
+		if (tima_overflow_) {
+			// TIMA might've changed in this strange cycle (see the comment below)
+			// If it changes in that cycle, it doesn't update to be equal to TMA
+			if (TIMA == 0) {
+				TIMA = TMA;
+				// If this isn't true, IF has changed during this instruction so the new value persists
+				if (IF == old_if) {
+					IF |= 1 << 2;
+					halt_ = false;
+				}
+			}
+			tima_overflow_ = false;
+		}
+		update_timers(tTemp);
+		handle_interrupts();
+		TClock += tTemp;
+		TotalClocks += tTemp;
+		return tTemp;
+	}
+
+	void CPU::handle_interrupts() {
+		if (auto temp = IE & IF; ime_ && IF) {
+			// Starting from the lowest bit (highest priority) and going up,
+			// we are effectively queueing interrupts in case there's multiple.
+			for (int i = 0; i < 5; i++) {
+				if (auto bit = (temp >> i) & 0x1; bit) {
+					execute_interrupt(i);
+					return;
+				}
+			}
+		}
+	}
+
+	void CPU::execute_interrupt(int bit) {
+		ime_ = false;
+		IF &= ~(1U << bit);
+		bus_->WriteL(SP, PC);
+		SP -= 2;
+		PC = 0x40 + bit * 0x8;
+	}
+
+	void CPU::update_timers(int cycles) {
+		int freq = get_clk_freq();
+		if (bus_->DIVReset) {
+			bus_->DIVReset = false;
+			if (div_reset_index_ >= freq / 2) {
+				TIMA++;
+			}
+			Oscillator = 0;
+			TimerCounter = 0;
+			div_reset_index_ = 0;
+		}
+		if (bus_->TACChanged) {
+			bus_->TACChanged = false;
+			uint8_t new_tac = TAC;
+			TAC = old_tac_;
+			int old_freq = get_clk_freq();
+			TAC = new_tac;
+			if ((old_tac_ >> 2) & 1) {
+				// If old tac was enabled
+				// TODO: prettify timer after its fully implemented
+				if (!((new_tac >> 2) & 1)) {
+					if ((div_reset_index_ & (old_freq / 2)) != 0) {
+						TIMA++;
+					}
+				}
+				else {
+					if ((div_reset_index_ & (old_freq / 2)) != 0 && ((div_reset_index_ & (freq / 2)) == 0)) {
+						TIMA++;
+					}
+				}
+			}
+			old_tac_ = new_tac;
+		}
+		bool enabled = (TAC >> 2) & 0x1;
+		Oscillator += cycles;
+		// Divider always equals the top 8 bits of the oscillator
+		DIVIDER = Oscillator >> 8;
+		if (div_reset_index_ != -1)
+			div_reset_index_ += cycles;
+		if (div_reset_index_ > freq) {
+			TIMA++;
+			div_reset_index_ = -1;
+		}
+		if (enabled) {
+			TimerCounter += cycles;
+			while (TimerCounter >= freq) {
+				TimerCounter -= freq;
+				//TimerCounter = get_clk_freq();
+				if (TIMA == 0xFF) {
+					/*TIMA = TMA;
+					IF |= 1 << 2;
+					halt_ = false;*/
+					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
+					TIMA = 0;
+					tima_overflow_ = true;
+				}
+				else {
+					TIMA++;
+				}
+			}
+		}
+	}
+	int CPU::get_clk_freq() {
+		switch (TAC & 0b11) {
+			case 0: return 1024;
+			case 1: return 16;
+			case 2: return 64;
+			case 3: return 256;
+		}
+	}
+}
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
new file mode 100644
index 0000000000000000000000000000000000000000..e2bc1b6a9f21ced0f81de4ab90eede47c3dcd5cd
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -0,0 +1,158 @@
+#pragma once
+#ifndef TKP_GB_CPU_H
+#define TKP_GB_CPU_H
+#include <cstdint>
+#include <string>
+#include <array>
+#include <iomanip>
+#include <fstream>
+#include "gb_bus.h"
+#include "gb_ppu.h"
+#include "gb_addresses.h"
+#include "disassembly_instr.h"
+namespace TKPEmu::Gameboy::Devices {
+	class CPU {
+	private:
+		using RegisterType = uint8_t;
+		using BigRegisterType = uint16_t;
+	private:
+		Bus* bus_;
+		bool ime_ = false;
+		int tTemp = 0;
+		int div_reset_index_ = -1;
+		int old_tac_ = 0;
+		int tac_index_ = 0x1000;
+		int tima_overflow_ = false;
+		bool halt_ = false;
+		bool stop_ = false;
+
+		// Instruction functions
+		void NOP(); void LDBC16(); void LDBCA(); void INCBC(); void INCB(); void DECB(); void LDB8(); void RLCA(); void LD16SP(); void ADDHLBC(); void LDABC(); void DECBC(); void INCC(); void DECC(); void LDC8(); void RRCA();
+		void STOP(); void LDDE16(); void LDDEA(); void INCDE(); void INCD(); void DECD(); void LDD8(); void RLA(); void JR8(); void ADDHLDE(); void LDADE(); void DECDE(); void INCE(); void DECE(); void LDE8(); void RRA();
+		void JRNZ8(); void LDHL16(); void LDIHLA(); void INCHL(); void INCH(); void DECH(); void LDH8(); void DAA(); void JRZ8(); void ADDHLHL(); void LDIAHL(); void DECHL(); void INCL(); void DECL(); void LDL8(); void CPL();
+		void JRNC8(); void LDSP16(); void LDDHLA(); void INCSP(); void INCHLR(); void DECHLR(); void LDHL8(); void SCF(); void JRC8(); void ADDHLSP(); void LDDAHL(); void DECSP(); void INCA(); void DECA(); void LDA8(); void CCF();
+		void LDBB(); void LDBC(); void LDBD(); void LDBE(); void LDBH(); void LDBL(); void LDBHL(); void LDBA(); void LDCB(); void LDCC(); void LDCD(); void LDCE(); void LDCH(); void LDCL(); void LDCHL(); void LDCA();
+		void LDDB(); void LDDC(); void LDDD(); void LDDE(); void LDDH(); void LDDL(); void LDDHL(); void LDDA(); void LDEB(); void LDEC(); void LDED(); void LDEE(); void LDEH(); void LDEL(); void LDEHL(); void LDEA();
+		void LDHB(); void LDHC(); void LDHD(); void LDHE(); void LDHH(); void LDHL(); void LDHHL(); void LDHA(); void LDLB(); void LDLC(); void LDLD(); void LDLE(); void LDLH(); void LDLL(); void LDLHL(); void LDLA();
+		void LDHLB(); void LDHLC(); void LDHLD(); void LDHLE(); void LDHLH(); void LDHLL(); void HALT(); void LDHLA(); void LDAB(); void LDAC(); void LDAD(); void LDAE(); void LDAH(); void LDAL(); void LDAHL(); void LDAA();
+		void ADDAB(); void ADDAC(); void ADDAD(); void ADDAE(); void ADDAH(); void ADDAL(); void ADDAHL(); void ADDAA(); void ADCAB(); void ADCAC(); void ADCAD(); void ADCAE(); void ADCAH(); void ADCAL(); void ADCAHL(); void ADCAA();
+		void SUBAB(); void SUBAC(); void SUBAD(); void SUBAE(); void SUBAH(); void SUBAL(); void SUBAHL(); void SUBAA(); void SBCAB(); void SBCAC(); void SBCAD(); void SBCAE(); void SBCAH(); void SBCAL(); void SBCAHL(); void SBCAA();
+		void ANDB(); void ANDC(); void ANDD(); void ANDE(); void ANDH(); void ANDL(); void ANDHL(); void ANDA(); void XORB(); void XORC(); void XORD(); void XORE(); void XORH(); void XORL(); void XORHL(); void XORA();
+		void ORB(); void ORC(); void ORD(); void ORE(); void ORH(); void ORL(); void ORHL(); void ORA(); void CPAB(); void CPAC(); void CPAD(); void CPAE(); void CPAH(); void CPAL(); void CPAHL(); void CPAA();
+		void RETNZ(); void POPBC(); void JPNZ16(); void JP16(); void CALLNZ16(); void PUSHBC(); void ADDA8(); void RST0(); void RETZ(); void RET(); void JPZ16(); void EXT(); void CALLZ16(); void CALL16(); void ADCA8(); void RST8();
+		void RETNC(); void POPDE(); void JPNC16(); void CALLNC16(); void PUSHDE(); void SUBA8(); void RST10(); void RETC(); void RETI(); void JPC16();  void CALLC16();  void SBCA8(); void RST18();
+		void LDH8A(); void POPHL(); void LDHCA(); void PUSHHL(); void AND8(); void RST20(); void ADDSPD(); void JPHL(); void LD16A(); void XOR8(); void RST28();
+		void LDHA8(); void POPAF();  void LDAMC(); void DI();  void PUSHAF(); void OR8(); void RST30(); void LDHLSPD(); void LDSPHL(); void LDA16(); void EI(); void CP8(); void RST38();
+
+		// Two byte instructions
+		void RLCB(); void RLCC(); void RLCD(); void RLCE(); void RLCH(); void RLCL(); void RLCHL(); void RLCAr(); void RRCB(); void RRCC(); void RRCD(); void RRCE(); void RRCH(); void RRCL(); void RRCHL(); void RRCAr();
+		void RLB(); void RLC(); void RLD(); void RLE(); void RLH(); void RLL(); void RLHL(); void RLAr(); void RRB(); void RRC(); void RRD(); void RRE(); void RRH(); void RRL(); void RRHL(); void RRAr();
+		void SLAB(); void SLAC(); void SLAD(); void SLAE(); void SLAH(); void SLAL(); void SLAHL(); void SLAA(); void SRAB(); void SRAC(); void SRAD(); void SRAE(); void SRAH(); void SRAL(); void SRAHL(); void SRAA();
+		void SWAPB(); void SWAPC(); void SWAPD(); void SWAPE(); void SWAPH(); void SWAPL(); void SWAPHL();  void SWAPA(); void SRLB(); void SRLC(); void SRLD(); void SRLE(); void SRLH(); void SRLL(); void SRLHL(); void SRLA();
+		void BIT0B(); void BIT0C(); void BIT0D(); void BIT0E(); void BIT0H(); void BIT0L(); void BIT0M(); void BIT0A(); void BIT1B(); void BIT1C(); void BIT1D(); void BIT1E(); void BIT1H(); void BIT1L(); void BIT1M(); void BIT1A();
+		void BIT2B(); void BIT2C(); void BIT2D(); void BIT2E(); void BIT2H(); void BIT2L(); void BIT2M(); void BIT2A(); void BIT3B(); void BIT3C(); void BIT3D(); void BIT3E(); void BIT3H(); void BIT3L(); void BIT3M(); void BIT3A();
+		void BIT4B(); void BIT4C(); void BIT4D(); void BIT4E(); void BIT4H(); void BIT4L(); void BIT4M(); void BIT4A(); void BIT5B(); void BIT5C(); void BIT5D(); void BIT5E(); void BIT5H(); void BIT5L(); void BIT5M(); void BIT5A();
+		void BIT6B(); void BIT6C(); void BIT6D(); void BIT6E(); void BIT6H(); void BIT6L(); void BIT6M(); void BIT6A(); void BIT7B(); void BIT7C(); void BIT7D(); void BIT7E(); void BIT7H(); void BIT7L(); void BIT7M(); void BIT7A();
+		void RES0B(); void RES0C(); void RES0D(); void RES0E(); void RES0H(); void RES0L(); void RES0HL(); void RES0A(); void RES1B(); void RES1C(); void RES1D(); void RES1E(); void RES1H(); void RES1L(); void RES1HL(); void RES1A();
+		void RES2B(); void RES2C(); void RES2D(); void RES2E(); void RES2H(); void RES2L(); void RES2HL(); void RES2A(); void RES3B(); void RES3C(); void RES3D(); void RES3E(); void RES3H(); void RES3L(); void RES3HL(); void RES3A();
+		void RES4B(); void RES4C(); void RES4D(); void RES4E(); void RES4H(); void RES4L(); void RES4HL(); void RES4A(); void RES5B(); void RES5C(); void RES5D(); void RES5E(); void RES5H(); void RES5L(); void RES5HL(); void RES5A();
+		void RES6B(); void RES6C(); void RES6D(); void RES6E(); void RES6H(); void RES6L(); void RES6HL(); void RES6A(); void RES7B(); void RES7C(); void RES7D(); void RES7E(); void RES7H(); void RES7L(); void RES7HL(); void RES7A();
+		void SET0B(); void SET0C(); void SET0D(); void SET0E(); void SET0H(); void SET0L(); void SET0HL(); void SET0A(); void SET1B(); void SET1C(); void SET1D(); void SET1E(); void SET1H(); void SET1L(); void SET1HL(); void SET1A();
+		void SET2B(); void SET2C(); void SET2D(); void SET2E(); void SET2H(); void SET2L(); void SET2HL(); void SET2A(); void SET3B(); void SET3C(); void SET3D(); void SET3E(); void SET3H(); void SET3L(); void SET3HL(); void SET3A();
+		void SET4B(); void SET4C(); void SET4D(); void SET4E(); void SET4H(); void SET4L(); void SET4HL(); void SET4A(); void SET5B(); void SET5C(); void SET5D(); void SET5E(); void SET5H(); void SET5L(); void SET5HL(); void SET5A();
+		void SET6B(); void SET6C(); void SET6D(); void SET6E(); void SET6H(); void SET6L(); void SET6HL(); void SET6A(); void SET7B(); void SET7C(); void SET7D(); void SET7E(); void SET7H(); void SET7L(); void SET7HL(); void SET7A();
+
+		// Undefined instructions
+		void XXX();
+
+		// Helper functions that also deal with the flags
+		inline void reg_dec(RegisterType& reg);
+		inline void reg_inc(RegisterType& reg);
+		inline void reg_sub(RegisterType& reg);
+		inline void reg_sbc(RegisterType& reg);
+		inline void reg_and(RegisterType& reg);
+		inline void reg_add(RegisterType& reg);
+		inline void reg_adc(RegisterType& reg);
+		inline void reg_cmp(RegisterType& reg);
+		inline void reg_or (RegisterType& reg);
+		inline void reg_xor(RegisterType& reg);
+		inline void hl_add(BigRegisterType& big_reg);
+		inline void bit_ch(RegisterType reg, unsigned shift);
+		inline void bit_res(RegisterType& reg, unsigned shift);
+		inline void bit_set(RegisterType& reg, unsigned shift);
+		inline void bit_swap(RegisterType& reg);
+		inline void bit_rrc(RegisterType& reg);
+		inline void bit_rl(RegisterType& reg);
+		inline void bit_rr(RegisterType& reg);
+		inline void bit_sl(RegisterType& reg);
+		inline void bit_sr(RegisterType& reg);
+		inline void bit_srl(RegisterType& reg);
+		inline void rst(RegisterType addr);
+		void handle_interrupts();
+		void execute_interrupt(int bit);
+		void update_timers(int cycles);
+		int get_clk_freq();
+
+	public:
+		CPU(Bus* bus);
+		struct Instruction {
+			std::string name;
+			void(CPU::* op)() = nullptr;
+			int skip = 0;
+		};
+		// TODO: remove instr times, use the ones in gb_addresses instead
+		std::array<Instruction, 0x100> Instructions = { {
+			{ "NOP" , &CPU::NOP }, { "LDBC16" , &CPU::LDBC16 , 2}, { "LDBCA" , &CPU::LDBCA }, { "INCBC" , &CPU::INCBC }, { "INCB" , &CPU::INCB }, { "DECB" , &CPU::DECB }, { "LDB8" , &CPU::LDB8 , 1}, { "RLCA" , &CPU::RLCA }, { "LD16SP" , &CPU::LD16SP }, { "ADDHLBC" , &CPU::ADDHLBC }, { "LDABC" , &CPU::LDABC }, { "DECBC" , &CPU::DECBC }, { "INCC" , &CPU::INCC }, { "DECC" , &CPU::DECC }, { "LDC8" , &CPU::LDC8 , 1}, { "RRCA" , &CPU::RRCA },
+			{ "STOP" , &CPU::STOP }, { "LDDE16" , &CPU::LDDE16 , 2}, { "LDDEA" , &CPU::LDDEA }, { "INCDE" , &CPU::INCDE }, { "INCD" , &CPU::INCD }, { "DECD" , &CPU::DECD }, { "LDD8" , &CPU::LDD8 , 1}, { "RLA" , &CPU::RLA }, { "JR8" , &CPU::JR8 , 1}, { "ADDHLDE" , &CPU::ADDHLDE }, { "LDADE" , &CPU::LDADE }, { "DECDE" , &CPU::DECDE }, { "INCE" , &CPU::INCE }, { "DECE" , &CPU::DECE }, { "LDE8" , &CPU::LDE8 , 1}, { "RRA" , &CPU::RRA },
+			{ "JRNZ8" , &CPU::JRNZ8 , 1}, { "LDHL16" , &CPU::LDHL16 , 2}, { "LDIHLA" , &CPU::LDIHLA }, { "INCHL" , &CPU::INCHL }, { "INCH" , &CPU::INCH }, { "DECH" , &CPU::DECH }, { "LDH8" , &CPU::LDH8 , 1}, { "DAA" , &CPU::DAA }, { "JRZ8" , &CPU::JRZ8 , 1}, { "ADDHLHL" , &CPU::ADDHLHL }, { "LDIAHL" , &CPU::LDIAHL }, { "DECHL" , &CPU::DECHL }, { "INCL" , &CPU::INCL }, { "DECL" , &CPU::DECL }, { "LDL8" , &CPU::LDL8 , 1}, { "CPL" , &CPU::CPL },
+			{ "JRNC8" , &CPU::JRNC8 , 1}, { "LDSP16" , &CPU::LDSP16 , 2}, { "LDDHLA" , &CPU::LDDHLA }, { "INCSP" , &CPU::INCSP }, { "INCHLR" , &CPU::INCHLR }, { "DECHLR" , &CPU::DECHLR }, { "LDHL8" , &CPU::LDHL8 , 1}, { "SCF" , &CPU::SCF }, { "JRC8" , &CPU::JRC8 , 1}, { "ADDHLSP" , &CPU::ADDHLSP }, { "LDDAHL" , &CPU::LDDAHL }, { "DECSP" , &CPU::DECSP }, { "INCA" , &CPU::INCA }, { "DECA" , &CPU::DECA }, { "LDA8" , &CPU::LDA8 , 1}, { "CCF" , &CPU::CCF },
+			{ "LDBB" , &CPU::LDBB }, { "LDBC" , &CPU::LDBC }, { "LDBD" , &CPU::LDBD }, { "LDBE" , &CPU::LDBE }, { "LDBH" , &CPU::LDBH }, { "LDBL" , &CPU::LDBL }, { "LDBHL" , &CPU::LDBHL }, { "LDBA" , &CPU::LDBA }, { "LDCB" , &CPU::LDCB }, { "LDCC" , &CPU::LDCC }, { "LDCD" , &CPU::LDCD }, { "LDCE" , &CPU::LDCE }, { "LDCH" , &CPU::LDCH }, { "LDCL" , &CPU::LDCL }, { "LDCHL" , &CPU::LDCHL }, { "LDCA" , &CPU::LDCA },
+			{ "LDDB" , &CPU::LDDB }, { "LDDC" , &CPU::LDDC }, { "LDDD" , &CPU::LDDD }, { "LDDE" , &CPU::LDDE }, { "LDDH" , &CPU::LDDH }, { "LDDL" , &CPU::LDDL }, { "LDDHL" , &CPU::LDDHL }, { "LDDA" , &CPU::LDDA }, { "LDEB" , &CPU::LDEB }, { "LDEC" , &CPU::LDEC }, { "LDED" , &CPU::LDED }, { "LDEE" , &CPU::LDEE }, { "LDEH" , &CPU::LDEH }, { "LDEL" , &CPU::LDEL }, { "LDEHL" , &CPU::LDEHL }, { "LDEA" , &CPU::LDEA },
+			{ "LDHB" , &CPU::LDHB }, { "LDHC" , &CPU::LDHC }, { "LDHD" , &CPU::LDHD }, { "LDHE" , &CPU::LDHE }, { "LDHH" , &CPU::LDHH }, { "LDHL" , &CPU::LDHL }, { "LDHHL" , &CPU::LDHHL }, { "LDHA" , &CPU::LDHA }, { "LDLB" , &CPU::LDLB }, { "LDLC" , &CPU::LDLC }, { "LDLD" , &CPU::LDLD }, { "LDLE" , &CPU::LDLE }, { "LDLH" , &CPU::LDLH }, { "LDLL" , &CPU::LDLL }, { "LDLHL" , &CPU::LDLHL }, { "LDLA" , &CPU::LDLA },
+			{ "LDHLB" , &CPU::LDHLB }, { "LDHLC" , &CPU::LDHLC }, { "LDHLD" , &CPU::LDHLD }, { "LDHLE" , &CPU::LDHLE }, { "LDHLH" , &CPU::LDHLH }, { "LDHLL" , &CPU::LDHLL }, { "HALT" , &CPU::HALT }, { "LDHLA" , &CPU::LDHLA }, { "LDAB" , &CPU::LDAB }, { "LDAC" , &CPU::LDAC }, { "LDAD" , &CPU::LDAD }, { "LDAE" , &CPU::LDAE }, { "LDAH" , &CPU::LDAH }, { "LDAL" , &CPU::LDAL }, { "LDAHL" , &CPU::LDAHL }, { "LDAA" , &CPU::LDAA },
+			{ "ADDAB" , &CPU::ADDAB }, { "ADDAC" , &CPU::ADDAC }, { "ADDAD" , &CPU::ADDAD }, { "ADDAE" , &CPU::ADDAE }, { "ADDAH" , &CPU::ADDAH }, { "ADDAL" , &CPU::ADDAL }, { "ADDAHL" , &CPU::ADDAHL }, { "ADDAA" , &CPU::ADDAA }, { "ADCAB" , &CPU::ADCAB }, { "ADCAC" , &CPU::ADCAC }, { "ADCAD" , &CPU::ADCAD }, { "ADCAE" , &CPU::ADCAE }, { "ADCAH" , &CPU::ADCAH }, { "ADCAL" , &CPU::ADCAL }, { "ADCAHL" , &CPU::ADCAHL }, { "ADCAA" , &CPU::ADCAA },
+			{ "SUBAB" , &CPU::SUBAB }, { "SUBAC" , &CPU::SUBAC }, { "SUBAD" , &CPU::SUBAD }, { "SUBAE" , &CPU::SUBAE }, { "SUBAH" , &CPU::SUBAH }, { "SUBAL" , &CPU::SUBAL }, { "SUBAHL" , &CPU::SUBAHL }, { "SUBAA" , &CPU::SUBAA }, { "SBCAB" , &CPU::SBCAB }, { "SBCAC" , &CPU::SBCAC }, { "SBCAD" , &CPU::SBCAD }, { "SBCAE" , &CPU::SBCAE }, { "SBCAH" , &CPU::SBCAH }, { "SBCAL" , &CPU::SBCAL }, { "SBCAHL" , &CPU::SBCAHL }, { "SBCAA" , &CPU::SBCAA },
+			{ "ANDB" , &CPU::ANDB }, { "ANDC" , &CPU::ANDC }, { "ANDD" , &CPU::ANDD }, { "ANDE" , &CPU::ANDE }, { "ANDH" , &CPU::ANDH }, { "ANDL" , &CPU::ANDL }, { "ANDHL" , &CPU::ANDHL }, { "ANDA" , &CPU::ANDA }, { "XORB" , &CPU::XORB }, { "XORC" , &CPU::XORC }, { "XORD" , &CPU::XORD }, { "XORE" , &CPU::XORE }, { "XORH" , &CPU::XORH }, { "XORL" , &CPU::XORL }, { "XORHL" , &CPU::XORHL }, { "XORA" , &CPU::XORA },
+			{ "ORB" , &CPU::ORB }, { "ORC" , &CPU::ORC }, { "ORD" , &CPU::ORD }, { "ORE" , &CPU::ORE }, { "ORH" , &CPU::ORH }, { "ORL" , &CPU::ORL }, { "ORHL" , &CPU::ORHL }, { "ORA" , &CPU::ORA }, { "CPAB" , &CPU::CPAB }, { "CPAC" , &CPU::CPAC }, { "CPAD" , &CPU::CPAD }, { "CPAE" , &CPU::CPAE }, { "CPAH" , &CPU::CPAH }, { "CPAL" , &CPU::CPAL }, { "CPAHL" , &CPU::CPAHL }, { "CPAA" , &CPU::CPAA },
+			{ "RETNZ" , &CPU::RETNZ }, { "POPBC" , &CPU::POPBC }, { "JPNZ16" , &CPU::JPNZ16 , 2}, { "JP16" , &CPU::JP16 , 2}, { "CALLNZ16" , &CPU::CALLNZ16 , 2}, { "PUSHBC" , &CPU::PUSHBC }, { "ADDA8" , &CPU::ADDA8 , 1}, { "RST0" , &CPU::RST0 }, { "RETZ" , &CPU::RETZ }, { "RET" , &CPU::RET }, { "JPZ16" , &CPU::JPZ16 , 2}, { "EXT" , &CPU::EXT , 1 }, { "CALLZ16" , &CPU::CALLZ16 , 2}, { "CALL16" , &CPU::CALL16 , 2}, { "ADCA8" , &CPU::ADCA8 , 2}, { "RST8" , &CPU::RST8 },
+			{ "RETNC" , &CPU::RETNC }, { "POPDE" , &CPU::POPDE }, { "JPNC16" , &CPU::JPNC16 , 2}, { "???" , &CPU::XXX }, { "CALLNC16" , &CPU::CALLNC16 , 2}, { "PUSHDE" , &CPU::PUSHDE }, { "SUBA8" , &CPU::SUBA8 , 1}, { "RST10" , &CPU::RST10 }, { "RETC" , &CPU::RETC }, { "RETI" , &CPU::RETI }, { "JPC16" , &CPU::JPC16 , 2}, { "???" , &CPU::XXX }, { "CALLC16" , &CPU::CALLC16 , 2}, { "???" , &CPU::XXX }, { "SBCA8" , &CPU::SBCA8 , 1}, { "RST18" , &CPU::RST18 },
+			{ "LDH8A" , &CPU::LDH8A }, { "POPHL" , &CPU::POPHL }, { "LDHCA" , &CPU::LDHCA }, { "???" , &CPU::XXX }, { "???" , &CPU::XXX }, { "PUSHHL" , &CPU::PUSHHL }, { "AND8" , &CPU::AND8 , 1}, { "RST20" , &CPU::RST20 }, { "ADDSPD" , &CPU::ADDSPD , 1}, { "JPHL" , &CPU::JPHL }, { "LD16A" , &CPU::LD16A }, { "???" , &CPU::XXX }, { "???" , &CPU::XXX }, { "???" , &CPU::XXX }, { "XOR8" , &CPU::XOR8 , 1}, { "RST28" , &CPU::RST28 },
+			{ "LDHA8" , &CPU::LDHA8 , 1}, { "POPAF" , &CPU::POPAF }, { "LDAMC" , &CPU::LDAMC }, { "DI" , &CPU::DI }, { "???" , &CPU::XXX }, { "PUSHAF" , &CPU::PUSHAF }, { "OR8" , &CPU::OR8, 1 }, { "RST30" , &CPU::RST30 }, { "LDHLSPD" , &CPU::LDHLSPD , 1 }, { "LDSPHL", &CPU::LDSPHL }, { "LDA16" , &CPU::LDA16 }, { "EI" , &CPU::EI }, { "???" , &CPU::XXX }, { "???" , &CPU::XXX }, { "CP8" , &CPU::CP8 , 1}, { "RST38" , &CPU::RST38 }
+		} };
+		std::array<Instruction, 0x100> CBInstructions = { {
+			{ "RLCB" , &CPU::RLCB }, { "RLCC" , &CPU::RLCC }, { "RLCD" , &CPU::RLCD }, { "RLCE" , &CPU::RLCE }, { "RLCH" , &CPU::RLCH }, { "RLCL" , &CPU::RLCL }, { "RLCHL" , &CPU::RLCHL }, { "RLCAr" , &CPU::RLCAr },  { "RRCB" , &CPU::RRCB }, { "RRCC" , &CPU::RRCC }, { "RRCD" , &CPU::RRCD }, { "RRCE" , &CPU::RRCE }, { "RRCH" , &CPU::RRCH }, { "RRCL" , &CPU::RRCL }, { "RRCHL" , &CPU::RRCHL }, { "RRCAr" , &CPU::RRCAr },
+			{ "RLB" , &CPU::RLB }, { "RLC" , &CPU::RLC }, { "RLD" , &CPU::RLD }, { "RLE" , &CPU::RLE }, { "RLH" , &CPU::RLH }, { "RLL" , &CPU::RLL }, { "RLHL" , &CPU::RLHL }, { "RLAr" , &CPU::RLAr }, { "RRB" , &CPU::RRB }, { "RRC" , &CPU::RRC },  { "RRD" , &CPU::RRD },  { "RRE" , &CPU::RRE },  { "RRH" , &CPU::RRH },  { "RRL" , &CPU::RRL },  { "RRHL" , &CPU::RRHL },  { "RRAr" , &CPU::RRAr },
+			{ "SLAB" , &CPU::SLAB }, { "SLAC" , &CPU::SLAC }, { "SLAD" , &CPU::SLAD }, { "SLAE" , &CPU::SLAE }, { "SLAH" , &CPU::SLAH }, { "SLAL" , &CPU::SLAL }, { "SLAHL" , &CPU::SLAHL }, { "SLAA" , &CPU::SLAA }, { "SRAB" , &CPU::SRAB }, { "SRAC" , &CPU::SRAC }, { "SRAD" , &CPU::SRAD }, { "SRAE" , &CPU::SRAE }, { "SRAH" , &CPU::SRAH }, { "SRAL" , &CPU::SRAL }, { "SRAHL" , &CPU::SRAHL }, { "SRAA" , &CPU::SRAA },
+			{ "SWAPB" , &CPU::SWAPB }, { "SWAPC" , &CPU::SWAPC }, { "SWAPD" , &CPU::SWAPD }, { "SWAPE" , &CPU::SWAPE }, { "SWAPH" , &CPU::SWAPH }, { "SWAPL" , &CPU::SWAPL }, { "SWAPHL" , &CPU::SWAPHL }, { "SWAPA" , &CPU::SWAPA }, { "SRLB" , &CPU::SRLB }, { "SRLC" , &CPU::SRLC }, { "SRLD" , &CPU::SRLD }, { "SRLE" , &CPU::SRLE }, { "SRLH" , &CPU::SRLH }, { "SRLL" , &CPU::SRLL }, { "SRLHL" , &CPU::SRLHL }, { "SRLA" , &CPU::SRLA },
+			{ "BIT0B" , &CPU::BIT0B }, { "BIT0C" , &CPU::BIT0C }, { "BIT0D" , &CPU::BIT0D }, { "BIT0E" , &CPU::BIT0E }, { "BIT0H" , &CPU::BIT0H }, { "BIT0L" , &CPU::BIT0L }, { "BIT0M" , &CPU::BIT0M }, { "BIT0A" , &CPU::BIT0A }, { "BIT1B" , &CPU::BIT1B }, { "BIT1C" , &CPU::BIT1C }, { "BIT1D" , &CPU::BIT1D }, { "BIT1E" , &CPU::BIT1E }, { "BIT1H" , &CPU::BIT1H }, { "BIT1L" , &CPU::BIT1L }, { "BIT1M" , &CPU::BIT1M }, { "BIT1A" , &CPU::BIT1A },
+			{ "BIT2B" , &CPU::BIT2B }, { "BIT2C" , &CPU::BIT2C }, { "BIT2D" , &CPU::BIT2D }, { "BIT2E" , &CPU::BIT2E }, { "BIT2H" , &CPU::BIT2H }, { "BIT2L" , &CPU::BIT2L }, { "BIT2M" , &CPU::BIT2M }, { "BIT2A" , &CPU::BIT2A }, { "BIT3B" , &CPU::BIT3B }, { "BIT3C" , &CPU::BIT3C }, { "BIT3D" , &CPU::BIT3D }, { "BIT3E" , &CPU::BIT3E }, { "BIT3H" , &CPU::BIT3H }, { "BIT3L" , &CPU::BIT3L }, { "BIT3M" , &CPU::BIT3M }, { "BIT3A" , &CPU::BIT3A },
+			{ "BIT4B" , &CPU::BIT4B }, { "BIT4C" , &CPU::BIT4C }, { "BIT4D" , &CPU::BIT4D }, { "BIT4E" , &CPU::BIT4E }, { "BIT4H" , &CPU::BIT4H }, { "BIT4L" , &CPU::BIT4L }, { "BIT4M" , &CPU::BIT4M }, { "BIT4A" , &CPU::BIT4A }, { "BIT5B" , &CPU::BIT5B }, { "BIT5C" , &CPU::BIT5C }, { "BIT5D" , &CPU::BIT5D }, { "BIT5E" , &CPU::BIT5E }, { "BIT5H" , &CPU::BIT5H }, { "BIT5L" , &CPU::BIT5L }, { "BIT5M" , &CPU::BIT5M }, { "BIT5A" , &CPU::BIT5A },
+			{ "BIT6B" , &CPU::BIT6B }, { "BIT6C" , &CPU::BIT6C }, { "BIT6D" , &CPU::BIT6D }, { "BIT6E" , &CPU::BIT6E }, { "BIT6H" , &CPU::BIT6H }, { "BIT6L" , &CPU::BIT6L }, { "BIT6M" , &CPU::BIT6M }, { "BIT6A" , &CPU::BIT6A }, { "BIT7B" , &CPU::BIT7B }, { "BIT7C" , &CPU::BIT7C }, { "BIT7D" , &CPU::BIT7D }, { "BIT7E" , &CPU::BIT7E }, { "BIT7H" , &CPU::BIT7H }, { "BIT7L" , &CPU::BIT7L }, { "BIT7M" , &CPU::BIT7M }, { "BIT7A" , &CPU::BIT7A },
+			{ "RES0B" , &CPU::RES0B }, { "RES0C" , &CPU::RES0C }, { "RES0D" , &CPU::RES0D }, { "RES0E" , &CPU::RES0E }, { "RES0H" , &CPU::RES0H }, { "RES0L" , &CPU::RES0L }, { "RES0HL" , &CPU::RES0HL }, { "RES0A" , &CPU::RES0A }, { "RES1B" , &CPU::RES1B }, { "RES1C" , &CPU::RES1C }, { "RES1D" , &CPU::RES1D }, { "RES1E" , &CPU::RES1E }, { "RES1H" , &CPU::RES1H }, { "RES1L" , &CPU::RES1L }, { "RES1HL" , &CPU::RES1HL }, { "RES1A" , &CPU::RES1A },
+			{ "RES2B" , &CPU::RES2B }, { "RES2C" , &CPU::RES2C }, { "RES2D" , &CPU::RES2D }, { "RES2E" , &CPU::RES2E }, { "RES2H" , &CPU::RES2H }, { "RES2L" , &CPU::RES2L }, { "RES2HL" , &CPU::RES2HL }, { "RES2A" , &CPU::RES2A }, { "RES3B" , &CPU::RES3B }, { "RES3C" , &CPU::RES3C }, { "RES3D" , &CPU::RES3D }, { "RES3E" , &CPU::RES3E }, { "RES3H" , &CPU::RES3H }, { "RES3L" , &CPU::RES3L }, { "RES3HL" , &CPU::RES3HL }, { "RES3A" , &CPU::RES3A },
+			{ "RES4B" , &CPU::RES4B }, { "RES4C" , &CPU::RES4C }, { "RES4D" , &CPU::RES4D }, { "RES4E" , &CPU::RES4E }, { "RES4H" , &CPU::RES4H }, { "RES4L" , &CPU::RES4L }, { "RES4HL" , &CPU::RES4HL }, { "RES4A" , &CPU::RES4A }, { "RES5B" , &CPU::RES5B }, { "RES5C" , &CPU::RES5C }, { "RES5D" , &CPU::RES5D }, { "RES5E" , &CPU::RES5E }, { "RES5H" , &CPU::RES5H }, { "RES5L" , &CPU::RES5L }, { "RES5HL" , &CPU::RES5HL }, { "RES5A" , &CPU::RES5A },
+			{ "RES6B" , &CPU::RES6B }, { "RES6C" , &CPU::RES6C }, { "RES6D" , &CPU::RES6D }, { "RES6E" , &CPU::RES6E }, { "RES6H" , &CPU::RES6H }, { "RES6L" , &CPU::RES6L }, { "RES6HL" , &CPU::RES6HL }, { "RES6A" , &CPU::RES6A }, { "RES7B" , &CPU::RES7B }, { "RES7C" , &CPU::RES7C }, { "RES7D" , &CPU::RES7D }, { "RES7E" , &CPU::RES7E }, { "RES7H" , &CPU::RES7H }, { "RES7L" , &CPU::RES7L }, { "RES7HL" , &CPU::RES7HL }, { "RES7A" , &CPU::RES7A },
+			{ "SET0B" , &CPU::SET0B }, { "SET0C" , &CPU::SET0C }, { "SET0D" , &CPU::SET0D }, { "SET0E" , &CPU::SET0E }, { "SET0H" , &CPU::SET0H }, { "SET0L" , &CPU::SET0L }, { "SET0HL" , &CPU::SET0HL }, { "SET0A" , &CPU::SET0A }, { "SET1B" , &CPU::SET1B }, { "SET1C" , &CPU::SET1C }, { "SET1D" , &CPU::SET1D }, { "SET1E" , &CPU::SET1E }, { "SET1H" , &CPU::SET1H }, { "SET1L" , &CPU::SET1L }, { "SET1HL" , &CPU::SET1HL }, { "SET1A" , &CPU::SET1A },
+			{ "SET2B" , &CPU::SET2B }, { "SET2C" , &CPU::SET2C }, { "SET2D" , &CPU::SET2D }, { "SET2E" , &CPU::SET2E }, { "SET2H" , &CPU::SET2H }, { "SET2L" , &CPU::SET2L }, { "SET2HL" , &CPU::SET2HL }, { "SET2A" , &CPU::SET2A }, { "SET3B" , &CPU::SET3B }, { "SET3C" , &CPU::SET3C }, { "SET3D" , &CPU::SET3D }, { "SET3E" , &CPU::SET3E }, { "SET3H" , &CPU::SET3H }, { "SET3L" , &CPU::SET3L }, { "SET3HL" , &CPU::SET3HL }, { "SET3A" , &CPU::SET3A },
+			{ "SET4B" , &CPU::SET4B }, { "SET4C" , &CPU::SET4C }, { "SET4D" , &CPU::SET4D }, { "SET4E" , &CPU::SET4E }, { "SET4H" , &CPU::SET4H }, { "SET4L" , &CPU::SET4L }, { "SET4HL" , &CPU::SET4HL }, { "SET4A" , &CPU::SET4A }, { "SET5B" , &CPU::SET5B }, { "SET5C" , &CPU::SET5C }, { "SET5D" , &CPU::SET5D }, { "SET5E" , &CPU::SET5E }, { "SET5H" , &CPU::SET5H }, { "SET5L" , &CPU::SET5L }, { "SET5HL" , &CPU::SET5HL }, { "SET5A" , &CPU::SET5A },
+			{ "SET6B" , &CPU::SET6B }, { "SET6C" , &CPU::SET6C }, { "SET6D" , &CPU::SET6D }, { "SET6E" , &CPU::SET6E }, { "SET6H" , &CPU::SET6H }, { "SET6L" , &CPU::SET6L }, { "SET6HL" , &CPU::SET6HL }, { "SET6A" , &CPU::SET6A }, { "SET7B" , &CPU::SET7B }, { "SET7C" , &CPU::SET7C }, { "SET7D" , &CPU::SET7D }, { "SET7E" , &CPU::SET7E }, { "SET7H" , &CPU::SET7H }, { "SET7L" , &CPU::SET7L }, { "SET7HL" , &CPU::SET7HL }, { "SET7A" , &CPU::SET7A }
+		} };
+
+		// CPU registers
+		RegisterType A, B, C, D, E, H, L, F;
+		BigRegisterType PC, SP;
+
+		// Memory mapped registers, they are a reference to a position in memory
+		RegisterType &IF, &IE, &DIVIDER, &TIMA, &TMA, &TAC, &LY, &JOYP;
+
+		const int ClockSpeed = 4194304;
+		const int MaxCycles = ClockSpeed / 60;
+		int Oscillator = 0;
+		int TimerCounter = ClockSpeed / tac_index_;
+		int TClock = 0;
+		unsigned long TotalClocks = 0;
+		void Reset();
+		int Update();
+	};
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
new file mode 100644
index 0000000000000000000000000000000000000000..968c736abf13b1dcf0e42328cba165621037b701
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -0,0 +1,347 @@
+#pragma once
+#ifndef TKP_GB_DISASSEMBLER_H
+#define TKP_GB_DISASSEMBLER_H
+#include <vector>
+#include <algorithm>
+#include <unordered_map>
+// TODO: task.h is deprecated warning
+#include <execution>
+#include "base_disassembler.h"
+#include "gb_breakpoint.h"
+#include "gameboy.h"
+// TODO: put code in .cpp file
+namespace TKPEmu::Applications {
+    class GameboyDisassembler : public BaseDisassembler {
+    private:
+        using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
+        using Gameboy = TKPEmu::Gameboy::Gameboy;
+        using GBSelectionMap = std::vector<bool>;
+        GameboyBreakpoint debug_rvalues_;
+        GBSelectionMap sel_map_{};
+        Gameboy* emulator_ = nullptr;
+        uint8_t* LY_ = nullptr;
+        bool clear_all_flag = false;
+        int selected_bp = -1;
+    public:
+        GameboyDisassembler(bool* rom_loaded) : BaseDisassembler(rom_loaded) {
+            sel_map_.resize(0x10000);
+        };
+        void Focus(int item) noexcept {
+            ImGuiContext& g = *ImGui::GetCurrentContext();
+            ImGuiWindow* window = g.CurrentWindow;
+            // TODO: find a way to make item_height not hard coded
+            static const int item_height = 17;
+            window->Scroll.y = IM_FLOOR(item_height * item);
+        }
+        void SetEmulator(Emulator* emulator) override {
+            emulator_ = dynamic_cast<Gameboy*>(emulator);
+        }
+        void v_draw() noexcept {
+            bool bp_add_popup = false;
+            int goto_pc = -1;
+            if (ImGui::BeginMenuBar()) {
+                if (ImGui::BeginMenu("Emulation")) {
+                    DrawMenuEmulation(emulator_, rom_loaded_);
+                }
+                if (ImGui::BeginMenu("Navigation")) {
+                    if (ImGui::MenuItem("Step", "F7", false, emulator_->Paused.load())) {
+                        emulator_->Step.store(true);
+                        emulator_->Step.notify_all();
+                    }
+                    if (ImGui::MenuItem("Goto PC")) {
+                        // TODO: if PC not found, go to nearest close to that value
+                        OpenGotoPopup = true;
+                    }
+                    ImGui::EndMenu();
+                }
+                ImGui::EndMenuBar();
+            }
+            if (OpenGotoPopup) {
+                ImGui::OpenPopup("Goto Program Code");
+            }
+            ImVec2 center = ImGui::GetMainViewport()->GetCenter();
+            ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+            if (ImGui::BeginPopupModal("Goto Program Code", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+                ImGui::Text("Program Code (in hex) to go to:");
+                ImGui::Separator();
+                // 4 hexadecimal characters and a null terminator
+                constexpr size_t buf_size = 4 + 1;
+                static char buf[buf_size] = "";
+                bool close = false;
+                if (OpenGotoPopup) {
+                    if (!ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
+                        ImGui::SetKeyboardFocusHere(0);
+                    OpenGotoPopup = false;
+                }
+                if (ImGui::InputText("hexadecimal", buf, buf_size, 
+                        ImGuiInputTextFlags_CharsHexadecimal |
+                        ImGuiInputTextFlags_CharsUppercase |
+                        ImGuiInputTextFlags_EnterReturnsTrue)) {
+                    close = true;
+                }
+                if (ImGui::Button("OK", ImVec2(120, 0))) {
+                    close = true;
+                }
+                if (close) {
+                    // Convert hex to int
+                    unsigned x = 0;
+                    std::stringstream ss;
+                    ss << std::hex << buf;
+                    ss >> x;
+                    goto_pc = x;
+                    ImGui::CloseCurrentPopup();
+                }
+                ImGui::EndPopup();
+            }
+            static ImGuiTableFlags flags = ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV
+                | ImGuiTableFlags_ScrollY | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_BordersInnerV;
+            {
+                ImGui::BeginChild("ChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.6f, ImGui::GetContentRegionAvail().y), true);
+                if (ImGui::BeginTable("cmds", 3, flags)) {
+                    ImGui::TableSetupColumn("PC");
+                    ImGui::TableSetupColumn("Opcode");
+                    ImGui::TableSetupColumn("Description");
+                    ImGui::TableSetupScrollFreeze(0, 1);
+                    ImGui::TableHeadersRow();
+                    if (clear_all_flag) {
+                        clear_all_flag = false;
+                        std::fill(sel_map_.begin(), sel_map_.end(), false);
+                    }
+                    ImGuiListClipper clipper;
+                    clipper.Begin(0x10000);
+                    // TODO: cache disassembly instructions (overhead might not be enough for it to matter however)
+
+                    // Issue #006:
+                    // On first Clipper.Step() displaystart and displayend are 0 and 1 no matter how far down we scrolled
+                    // This means that if we aren't actually at the top, and instruction 0 uses parameters, the top 1/2 instructions will always
+                    // appear as (Parameter). This boolean helps fix this bug on that special edge case.
+                    bool imgui_bug = false;
+                    int skip = 0;
+                    while (clipper.Step()) {
+                        if (imgui_bug) {
+                            if (clipper.DisplayStart != 1) {
+                                // Edge case detected. Set skip to 0 to avoid bug.
+                                imgui_bug = false;
+                                skip = 0;
+                            }
+                        }
+                        for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
+                            bool is_skipped = false;
+                            DisInstr ins = emulator_->GetInstruction(row_n);
+                            if (skip == 0) {
+                                skip += ins.ParamSize;
+                                if (row_n == 0) 
+                                    imgui_bug = true;
+                            } else {
+                                skip--;
+                                is_skipped = true;
+                            }
+                            ImGui::PushID(row_n);
+                            ImGui::TableNextRow();
+                            ImGui::TableSetColumnIndex(0);
+                            if (ImGui::Selectable("$", sel_map_[row_n], ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
+                                if (emulator_->Paused.load()) {
+                                    sel_map_[row_n].flip();
+                                    if (sel_map_[row_n]) {
+                                        GBBPArguments bp_arg;
+                                        bp_arg.PC_using = true;
+                                        bp_arg.PC_value = ins.InstructionProgramCode;
+                                        emulator_->AddBreakpoint(bp_arg);
+                                    }
+                                    else {
+                                        auto it = std::find_if(
+                                            std::execution::par_unseq,
+                                            emulator_->Breakpoints.begin(),
+                                            emulator_->Breakpoints.end(),
+                                            [target = ins.InstructionProgramCode](const GameboyBreakpoint& bp) {
+                                                return bp.BPFromTable && bp.Args.PC_value == target;
+                                            }
+                                        );
+                                        if (it != emulator_->Breakpoints.end())
+                                            emulator_->Breakpoints.erase(it);
+                                    }
+                                }
+                            }
+                            ImGui::SameLine();
+                            ImGui::Text("%04X", ins.InstructionProgramCode);
+                            ImGui::TableSetColumnIndex(1);
+                            ImGui::Text("%02X", ins.Instruction);
+                            switch (ins.ParamSize) {
+                            case 0:
+                                ImGui::SameLine();
+                                ImGui::TextUnformatted("     ");
+                                break;
+                            case 1:
+                                ImGui::SameLine();
+                                ImGui::Text("%02X   ", ins.Params[0]);
+                                break;
+                            case 2:
+                                ImGui::SameLine();
+                                ImGui::Text("%02X,%02X", ins.Params[0], ins.Params[1]);
+                                break;
+                            }
+                            ImGui::TableSetColumnIndex(2);
+                            if (!is_skipped){
+                                ImGui::TextUnformatted(emulator_->GetCPU().Instructions[ins.Instruction].name.c_str());
+                                switch (ins.ParamSize) {
+                                    case 1:
+                                        ImGui::SameLine();
+                                        ImGui::Text("0x%02X", ins.Params[0]);
+                                        break;
+                                    case 2:
+                                        ImGui::SameLine();
+                                        ImGui::Text("0x%02X%02X", ins.Params[1], ins.Params[0]);
+                                        break;
+                                }
+                            } else {
+                                ImGui::SameLine();
+                                ImGui::TextUnformatted("(Parameter)");
+                            }
+                            ImGui::PopID();
+                        }
+                    }
+                    if (auto inst = emulator_->InstructionBreak.load(); inst != -1) {
+                        goto_pc = inst;
+                        emulator_->InstructionBreak.store(-1);
+                    }
+                    if (goto_pc != -1) {
+                        Focus(goto_pc);
+                    }
+                    ImGui::EndTable();
+                }
+                ImGui::EndChild();
+            }
+            ImGui::SameLine();
+            {
+                ImGui::BeginChild("ChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), false);
+                if (ImGui::BeginTable("bps", 1, flags, ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.6f))) {
+                    ImGui::TableSetupColumn("Breakpoints");
+                    ImGui::TableHeadersRow();
+
+                    ImGuiListClipper clipper;
+                    clipper.Begin(emulator_->Breakpoints.size());
+                    while (clipper.Step()) {
+                        for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
+                            auto& bp = emulator_->Breakpoints[row_n];
+                            ImGui::PushID(row_n);
+                            ImGui::TableNextRow();
+                            ImGui::TableSetColumnIndex(0);
+                            bool sel = false;
+                            if (row_n == selected_bp)
+                                sel = true;
+                            if (ImGui::Selectable(bp.GetName().c_str(), sel, ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
+                                if (!sel)
+                                    selected_bp = row_n;
+                                else
+                                    selected_bp = -1;
+                            }
+                            ImGui::PopID();
+                        }
+                    }
+                    ImGui::EndTable();
+                }
+                if (ImGui::Button("Add", ImVec2(ImGui::GetContentRegionAvail().x * (1.0f / 3.0f), ImGui::GetContentRegionAvail().y * 0.15f))) {
+                    bp_add_popup = true;
+                }
+                ImGui::SameLine();
+                bool disable = false;
+                // If a breakpoint isn't selected, disable the "Remove" button
+                if (selected_bp == -1) {
+                    disable = true;
+                    ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+                }
+                if (ImGui::Button("Remove", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.15f))) {
+                    if (emulator_->Breakpoints[selected_bp].BPFromTable) {
+                        // We have to remove the breakpoint selection from the table too
+                        sel_map_[emulator_->Breakpoints[selected_bp].Args.PC_value] = false;
+                    }
+                    emulator_->Breakpoints.erase(emulator_->Breakpoints.begin() + selected_bp);
+                    selected_bp = -1;
+                }
+                if (disable) {
+                    ImGui::PopItemFlag();
+                }
+                ImGui::SameLine();
+                if (ImGui::Button("Clear", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.15f))) {
+                    emulator_->Breakpoints.clear();
+                    clear_all_flag = true;
+                }
+                static bool use_hex = true;
+                auto& t = emulator_->GetCPU();
+                if (use_hex) {
+                    ImGui::Text("AF: 0x%02x%02x", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: 0x%04x", t.PC);
+                    ImGui::Text("BC: 0x%02x%02x", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: 0x%04x", t.SP);
+                    ImGui::Text("DE: 0x%02x%02x", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: 0x%02x", t.IE);
+                    ImGui::Text("HL: 0x%02x%02x", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: 0x%02x", t.IF);
+                }
+                else {
+                    ImGui::Text("AF: %d,%d", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: %d", t.PC);
+                    ImGui::Text("BC: %d,%d", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: %d", t.SP);
+                    ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
+                    ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
+                }
+                ImGui::Checkbox("Hex", &use_hex);
+                ImGui::EndChild();
+                // TODO: add switch from hex to binary on every textbox here
+                if (bp_add_popup) {
+                    ImGui::OpenPopup("Add breakpoint");
+                    bp_add_popup = false;
+                }
+                ImGui::SetNextWindowSize(ImVec2(250, 250));
+                ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+                if (ImGui::BeginPopupModal("Add breakpoint", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+                    ImGui::Text("Configure the breakpoint:");
+                    ImGui::Separator();
+                    static GBBPArguments bp_arg;
+                    {
+                        ImGui::BeginChild("bpChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.9f));
+                        breakpoint_register_checkbox("A:", bp_arg.A_value, bp_arg.A_using);
+                        breakpoint_register_checkbox("B:", bp_arg.B_value, bp_arg.B_using);
+                        breakpoint_register_checkbox("D:", bp_arg.D_value, bp_arg.D_using);
+                        breakpoint_register_checkbox("H:", bp_arg.H_value, bp_arg.H_using);
+                        breakpoint_register_checkbox("PC:", bp_arg.PC_value, bp_arg.PC_using, ImGuiDataType_U16);
+                        breakpoint_register_checkbox("Instr:", bp_arg.Ins_value, bp_arg.Ins_using);
+                        ImGui::EndChild();
+                    }
+                    ImGui::SameLine();
+                    {
+                        ImGui::BeginChild("bpChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.9f));
+                        breakpoint_register_checkbox("F:", bp_arg.F_value, bp_arg.F_using);
+                        breakpoint_register_checkbox("C:", bp_arg.C_value, bp_arg.C_using);
+                        breakpoint_register_checkbox("E:", bp_arg.E_value, bp_arg.E_using);
+                        breakpoint_register_checkbox("L:", bp_arg.L_value, bp_arg.L_using);
+                        breakpoint_register_checkbox("SP:", bp_arg.SP_value, bp_arg.SP_using, ImGuiDataType_U16);
+                        ImGui::EndChild();
+                    }
+                    if (ImGui::Button("Add", ImVec2(120, 0))) {
+                        bool pc_only = emulator_->AddBreakpoint(bp_arg);
+                        if (pc_only) {
+                            sel_map_[bp_arg.PC_value] = true;
+                        }
+                        ImGui::CloseCurrentPopup();
+                    }
+
+                    ImGui::EndPopup();
+                }
+            }
+        }
+    private:
+        template<typename T>
+        void breakpoint_register_checkbox(const char* checkbox_l, T& value, bool& is_used, ImGuiDataType type = ImGuiDataType_U8) {
+            ImGui::Checkbox(checkbox_l, &is_used);
+            if (is_used) {
+                ImGui::SameLine();
+                int w = 20;
+                if (type == ImGuiDataType_U16)
+                    w = 40;
+                ImGui::PushItemWidth(w);
+                char id[6] = "##IDt";
+                id[4] = checkbox_l[0];
+                ImGui::InputScalar(id, type, &value, 0, 0, w == 20 ? "%02X" : "%04X",
+                    ImGuiInputTextFlags_AllowTabInput | ImGuiInputTextFlags_CharsHexadecimal);
+                ImGui::PopItemWidth();
+            }
+        }
+    };
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..4a2db30daca04b5104a8c29fec761a72566f9a62
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -0,0 +1,301 @@
+#include "../include/gb_ppu.h"
+#include <mutex>
+#include "../glad/glad/glad.h"
+
+namespace TKPEmu::Gameboy::Devices {
+	PPU::PPU(Bus* bus, std::mutex* draw_mutex) : bus_(bus), draw_mutex_(draw_mutex), next_stat_mode(bus->NextMode),
+		LCDC(bus->GetReference(0xFF40)),
+		STAT(bus->GetReference(0xFF41)),
+		SCY(bus->GetReference(0xFF42)),
+		SCX(bus->GetReference(0xFF43)),
+		LY(bus->GetReference(0xFF44)),
+		LYC(bus->GetReference(0xFF45)),
+		WY(bus->GetReference(0xFF4A)),
+		WX(bus->GetReference(0xFF4B)),
+		IF(bus->GetReference(0xFF0F))
+	{}
+
+	void PPU::Update(uint8_t tTemp) {
+		IF &= 0b11111110;
+		clock_ += tTemp;
+		if (LCDC & LCDCFlag::LCD_ENABLE) {
+			if (clock_ >= clock_target_) {
+				if (LY == 153) {
+					next_stat_mode = 2;
+					LY = -1;
+					clock_ %= FRAME_CYCLES;
+					clock_target_ = FRAME_CYCLES;
+				}
+				IF |= set_mode(next_stat_mode);
+				
+				if (int mode = get_mode(); mode == 2) {
+					clock_target_ += 80;
+					next_stat_mode = 3;
+					LY += 1;
+					IF |= update_lyc();
+				}
+				else if (mode == 3) {
+					clock_target_ += 170;
+					next_stat_mode = 0;
+				}
+				else if (mode == 0) {
+					clock_target_ += 206;
+					if (LY <= 143) {
+						next_stat_mode = 2;
+						std::lock_guard<std::mutex> lg(*draw_mutex_);
+						draw_scanline();
+					}
+					else {
+						next_stat_mode = 1;
+					}
+				}
+				else if (mode == 1) {
+					clock_target_ += 456;
+					next_stat_mode = 1;
+					if (LY == 144) {
+						IF |= IFInterrupt::VBLANK;
+					}
+					LY += 1;
+					IF |= update_lyc();
+				}
+			}
+		}
+		else {
+			if (clock_ >= FRAME_CYCLES) {
+				clock_ %= FRAME_CYCLES;
+			}
+		}
+	}
+	void PPU::Reset() {
+		LY = 0x90;
+		LCDC = 0b1001'0001;
+		STAT = 0b1000'0000;
+		next_stat_mode = 2;
+		clock_ = 0;
+		clock_target_ = 0;
+	}
+	
+	float* PPU::GetScreenData() {
+		return &screen_color_data_[0];
+	}
+
+	int PPU::set_mode(int mode) {
+		if (get_mode() == mode) {
+			return 0;
+		}
+		STAT &= 0b1111'1100;
+		STAT |= mode;
+		if (mode != 3 && STAT & (1 << (mode + 3))) {
+			return IFInterrupt::LCDSTAT;
+		}
+		return 0;
+	}
+	int PPU::get_mode() {
+		return STAT & STATFlag::MODE;
+	}
+
+	int PPU::update_lyc() {
+		if (LYC == LY) {
+			STAT |= STATFlag::COINCIDENCE;
+			if (STAT & STATFlag::COINC_INTER)
+				return IFInterrupt::LCDSTAT;
+		}
+		else {
+			STAT &= 0b1111'1011;
+		}
+		return 0;
+	}
+
+	void PPU::draw_scanline() {
+		if (LCDC & 0b1) {
+			renderTiles();
+		}
+		if (LCDC & 0b10) {
+			renderSprites();
+		}
+	}
+
+	inline void PPU::renderTiles() {
+		uint16_t tileData = (LCDC & 0b10000) ? 0x8000 : 0x8800;
+
+		uint8_t scrollY = bus_->Read(0xFF42);
+		uint8_t scrollX = bus_->Read(0xFF43);
+		uint8_t windowY = bus_->Read(0xFF4A);
+		uint8_t windowX = bus_->Read(0xFF4B) - 7;
+		bool unsig = true;
+		if (tileData == 0x8800) {
+			unsig = false;
+		}
+		bool windowEnabled = false;
+
+		// is the window enabled?f
+		if (LCDC & 0b100000) {
+			// there is no point in drawing the window if its located under the current scanline
+			if (windowY <= bus_->Read(0xFF44)) {
+				windowEnabled = true;
+			}
+
+		}
+		uint16_t identifierLocation;
+		uint8_t positionY = 0;
+		// if window is enabled we use the window background memory map per Pan doc gb docs
+		if (windowEnabled) {
+			identifierLocation = (LCDC & 0b1000000) ? 0x9C00 : 0x9800;
+			// if the window is enabled we can get the y-position of the place we need to draw via
+			// window y since window y tells us distance from the area of the first place we need to draw
+			positionY = bus_->Read(0xFF44) - windowY;
+		}
+		else {
+			identifierLocation = (LCDC & 0b1000) == 1 ? 0x9C00 : 0x9800;
+			// if windows is not enabled we get the edge y-position of the area we need to draw
+			// by adding current scanline and scroll-y
+			positionY = bus_->Read(0xFF44) + scrollY;
+		}
+
+		uint16_t tileRow = (((uint8_t)(positionY / 8)) * 32);
+
+		// draw pixels horizontally
+		for (int pixel = 0; pixel < 160; pixel++) {
+			uint8_t positionX = pixel + scrollX;
+			if (windowEnabled) {
+				if (pixel >= windowX) {
+					positionX = pixel - windowX;
+				}
+			}
+
+			uint16_t tileCol = (positionX / 8);
+
+			int16_t tileNumber;
+
+			uint16_t tileAddress = identifierLocation + tileRow + tileCol;
+
+			if (unsig) {
+				tileNumber = bus_->Read(tileAddress);
+			}
+			else {
+				tileNumber = static_cast<int8_t>(bus_->Read(tileAddress));
+			}
+
+			uint16_t tileLocation = tileData;
+
+			if (unsig) {
+				tileLocation += tileNumber * 16;
+			}
+			else {
+				tileLocation += (tileNumber + 128) * 16;
+			}
+
+			// which col of tile
+			uint8_t line = (positionY % 8);
+			line *= 2;
+
+			uint8_t data1 = bus_->Read(tileLocation + line);
+			uint8_t data2 = bus_->Read(tileLocation + line + 1);
+
+			int colorBit = positionX % 8;
+			// pixel 0 is bit 7, so on
+			// 0 - 7 is -7, multiplied by -1 is 7 so we can get the 7th bit of the data
+			colorBit -= 7;
+			colorBit *= -1;
+
+			int colorNum = (data2 >> colorBit) & 0x1;
+			colorNum <<= 1;
+			colorNum |= (data1 >> colorBit) & 0x1;
+			int finaly = bus_->Read(0xFF44);
+
+			// safety check to make sure what im about 
+			// to set is int the 160x144 bounds
+			int idx = (pixel * 4) + (finaly * 4 * 160);
+			if (LCDC & 0b01) {
+				screen_color_data_[idx++] = bus_->Palette[bus_->BGPalette[colorNum]][0];
+				screen_color_data_[idx++] = bus_->Palette[bus_->BGPalette[colorNum]][1];
+				screen_color_data_[idx++] = bus_->Palette[bus_->BGPalette[colorNum]][2];
+				screen_color_data_[idx] = 255.0f;
+			}
+		}
+	}
+
+	void PPU::renderSprites() {
+		bool use8x16 = false;
+		if (LCDC & 0b100)
+			use8x16 = true;
+
+		for (int sprite = 0; sprite < 40; sprite++) {
+			uint8_t positionY = bus_->OAM[sprite].y_pos - 16;
+			uint8_t positionX = bus_->OAM[sprite].x_pos - 8;
+			uint8_t tileLoc = bus_->OAM[sprite].tile_index;
+			uint8_t attributes = bus_->OAM[sprite].flags;
+
+			bool yFlip = attributes & 0b1000000;
+			bool xFlip = attributes & 0b100000;
+
+			int scanLine = bus_->Read(0xFF44);
+			int height = 8;
+			if (use8x16) {
+				height = 16;
+			}
+
+			if ((scanLine >= positionY) && (scanLine < (positionY + height))) {
+				int line = scanLine - positionY;
+
+				// if a sprite is flipped we read data from opposite side of table 
+				if (yFlip) {
+					line -= height - 1;
+					line *= -1;
+				}
+
+				line *= 2;
+
+				uint16_t address = (0x8000 + (tileLoc * 16) + line);
+				uint8_t data1 = bus_->Read(address);
+				uint8_t data2 = bus_->Read(address + 1);
+
+
+				for (int tilePixel = 7; tilePixel >= 0; tilePixel--) {
+					int colorbit = tilePixel;
+					if (xFlip) {
+						colorbit -= 7;
+						colorbit *= -1;
+					}
+
+					int colorNum = (data2 >> colorbit) & 0x1;
+					colorNum <<= 1;
+					colorNum |= (data1 >> colorbit) & 0x1;
+
+					bool obp1 = (attributes & 0b10000);
+					uint8_t color = 1;
+					if (obp1) {
+						color = bus_->OBJ1Palette[colorNum];
+					}
+					else {
+						color = bus_->OBJ0Palette[colorNum];
+					}
+
+					if (color == 0) {
+						continue;
+					}
+
+
+					int xPix = 0 - tilePixel;
+					xPix += 7;
+
+					int pixel = positionX + xPix;
+
+
+					if ((scanLine < 0) || (scanLine > 143) || (pixel < 0) || (pixel > 159))
+					{
+						continue;
+					}
+
+					int idx = (pixel * 4) + (scanLine * 4 * 160);
+					if (LCDC & 0b10) {
+						screen_color_data_[idx++] = bus_->Palette[color][0];
+						screen_color_data_[idx++] = bus_->Palette[color][1];
+						screen_color_data_[idx++] = bus_->Palette[color][2];
+						screen_color_data_[idx] = 255;
+					}
+				}
+			}
+		}
+	}
+}
diff --git a/TKPEmu/gb_tkp/gb_ppu.h b/TKPEmu/gb_tkp/gb_ppu.h
new file mode 100644
index 0000000000000000000000000000000000000000..bc494524d03e0e82c0a96a68f9ec33a31409af8d
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_ppu.h
@@ -0,0 +1,42 @@
+#pragma once
+#ifndef TKP_GB_PPU_H
+#define TKP_GB_PPU_H
+#include "gb_bus.h"
+#include "TKPImage.h"
+#include <mutex>
+#include <queue>
+#include <array>
+namespace TKPEmu::Gameboy::Devices {
+	constexpr int FRAME_CYCLES = 70224;
+	class PPU {
+	private:
+		using IFInterrupt = Bus::IFInterrupt;
+		using LCDCFlag = Bus::LCDCFlag;
+		using STATFlag = Bus::STATFlag;
+		using TKPImage = TKPEmu::Tools::TKPImage;
+		using Pixel = TKPEmu::Gameboy::Devices::Bus::Pixel;
+	public:
+		PPU(Bus* bus, std::mutex* draw_mutex);
+		void Update(uint8_t tTemp);
+		void Reset();
+		float* GetScreenData();
+	private:
+		Bus* bus_;
+		std::array<float, 4 * 160 * 144> screen_color_data_{};
+
+		// PPU register pointers
+		uint8_t& LCDC, &STAT, &LYC, &LY, &IF, &SCY, &SCX, &WY, &WX;
+
+		int clock_ = 0;
+		int clock_target_ = 0;
+		uint8_t& next_stat_mode;
+		std::mutex* draw_mutex_ = nullptr;
+		int set_mode(int mode);
+		int get_mode();
+		int update_lyc();
+		void draw_scanline();
+		inline void renderTiles();
+		inline void renderSprites();
+	};
+}
+#endif
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..28f01b7378b5e2dcae7ed7e0ebc84177fe388b16
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -0,0 +1,25 @@
+#include "../include/gb_tracelogger.h"
+#include "../include/gb_addresses.h"
+#include "../lib/imgui.h"
+namespace TKPEmu::Applications {
+	void GameboyTracelogger::v_draw() {
+		ImGui::NewLine();
+		ImGui::TextUnformatted("Memory to log:");
+		ImGui::Separator();
+		for (int i = 0; i < LogTypeSize; i++) {
+			ImGui::Checkbox(LogTypeNames[i].c_str(), &available_types_[i]);
+			if ((i + 1) % 5 != 0) {
+				ImGui::SameLine();
+			}
+		}
+	}
+	void GameboyTracelogger::set_logtypes() {
+		std::unique_ptr<std::vector<LogType>> ptr = std::make_unique<std::vector<LogType>>();
+		for (int i = 0; i < LogTypeSize; i++) {
+			if (available_types_[i]) {
+				ptr->push_back(LogTypeMap[i]);
+			}
+		}
+		(dynamic_cast<Gameboy*>(emulator_))->SetLogTypes(std::move(ptr));
+	}
+}
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.h b/TKPEmu/gb_tkp/gb_tracelogger.h
new file mode 100644
index 0000000000000000000000000000000000000000..bbeb821d82736855d5b9637606574eb2381a9fc4
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_tracelogger.h
@@ -0,0 +1,16 @@
+#pragma once
+#ifndef TKP_GB_TRACELOGGER_H
+#define TKP_GB_TRACELOGGER_H
+#include <array>
+#include "base_tracelogger.h"
+#include "gameboy.h"
+namespace TKPEmu::Applications {
+	using Gameboy = TKPEmu::Gameboy::Gameboy;
+	class GameboyTracelogger : public BaseTracelogger {
+	private:
+		void v_draw() override;
+		void set_logtypes() override;
+		std::array<bool, LogTypeSize> available_types_{};
+	};
+}
+#endif

From 7a2bfe5f5f96927a8cc63e5a20a042efc7b1ec87 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 22 Nov 2021 23:49:20 +0200
Subject: [PATCH] fix to last commit, compiles correctly

---
 TKPEmu/gb_tkp/gameboy.h          | 4 ++--
 TKPEmu/gb_tkp/gb_addresses.h     | 2 +-
 TKPEmu/gb_tkp/gb_bus.cpp         | 4 ++--
 TKPEmu/gb_tkp/gb_cartridge.cpp   | 2 +-
 TKPEmu/gb_tkp/gb_cpu.cpp         | 2 +-
 TKPEmu/gb_tkp/gb_cpu.h           | 2 +-
 TKPEmu/gb_tkp/gb_disassembler.h  | 2 +-
 TKPEmu/gb_tkp/gb_ppu.cpp         | 3 +--
 TKPEmu/gb_tkp/gb_ppu.h           | 3 +--
 TKPEmu/gb_tkp/gb_tracelogger.cpp | 4 ++--
 TKPEmu/gb_tkp/gb_tracelogger.h   | 2 +-
 11 files changed, 14 insertions(+), 16 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 972af16ecfb07ccf9096b8a50bb4e8336b45c26d..890256c8f8e8fda46ffd7d90476cd3e3d6ae92e9 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -2,8 +2,8 @@
 #ifndef TKP_GB_GAMEBOY_H
 #define TKP_GB_GAMEBOY_H
 #include <array>
-#include "emulator.h"
-#include "disassembly_instr.h"
+#include "../include/emulator.h"
+#include "../include/disassembly_instr.h"
 #include "gb_breakpoint.h"
 #include "gb_addresses.h"
 #include "gb_cpu.h"
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index cb4f940ed0b2f27aebc2642981c12e908cc08717..c3cedaf32447b3b908422be2ac32455215c31541 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -1,7 +1,7 @@
 #pragma once
 #ifndef TKP_TOOLS_GBADDR_H
 #define TKP_TOOLS_GBADDR_H
-#include "disassembly_instr.h"
+#include "../include/disassembly_instr.h"
 #include "gb_breakpoint.h"
 #include <cstdint>
 using DisInstr = TKPEmu::Tools::DisInstr;
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 41da174173f8ea02f4fafb3225b17852bf01f08e..82adb9d10cffa89cf7b3ed3511c5701082cda92d 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -2,8 +2,8 @@
 #include <iomanip>
 #include <algorithm>
 #include <bitset>
-#include "../include/gb_bus.h"
-#include "../include/gb_addresses.h"
+#include "gb_bus.h"
+#include "gb_addresses.h"
 namespace TKPEmu::Gameboy::Devices {
 
 	Bus::Bus(std::vector<DisInstr>& instrs) : instructions_(instrs) {}
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 67683ca541c5cd71936e502dd97ddfc4665a04ad..53920f8a2067b63636c8e3882cbac57eb2c28663 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -1,7 +1,7 @@
 #include <fstream>
 #include <iostream>
 #include <cmath>
-#include "../include/gb_cartridge.h"
+#include "gb_cartridge.h"
 namespace TKPEmu::Gameboy::Devices {
 	void Cartridge::Load(const std::string& fileName, std::vector<std::array<uint8_t, 0x4000>>& romBanks, std::vector<std::array<uint8_t, 0x2000>>& ramBanks) {
 		std::ifstream is;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 4c3cfa549decc19747db21f6cee375215e0d5882..b0fbd5d6229b2e33d275a5b24a52243130dd5d1f 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1,4 +1,4 @@
-#include "../include/gb_cpu.h"
+#include "gb_cpu.h"
 #include <stdexcept>
 #include <iostream>
 namespace TKPEmu::Gameboy::Devices {
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index e2bc1b6a9f21ced0f81de4ab90eede47c3dcd5cd..5d4b4e8c8266dbb8f952dc5950a22b23b768e0e1 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -9,7 +9,7 @@
 #include "gb_bus.h"
 #include "gb_ppu.h"
 #include "gb_addresses.h"
-#include "disassembly_instr.h"
+#include "../include/disassembly_instr.h"
 namespace TKPEmu::Gameboy::Devices {
 	class CPU {
 	private:
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index 968c736abf13b1dcf0e42328cba165621037b701..4d7abffcfdf3de2aa2a8e7afd93551d5f4154c51 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -6,7 +6,7 @@
 #include <unordered_map>
 // TODO: task.h is deprecated warning
 #include <execution>
-#include "base_disassembler.h"
+#include "../include/base_disassembler.h"
 #include "gb_breakpoint.h"
 #include "gameboy.h"
 // TODO: put code in .cpp file
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index 4a2db30daca04b5104a8c29fec761a72566f9a62..5b84b56b310b6995fd78f01d66c34a14e06d4830 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -1,5 +1,4 @@
-#include "../include/gb_ppu.h"
-#include <mutex>
+#include "gb_ppu.h"
 #include "../glad/glad/glad.h"
 
 namespace TKPEmu::Gameboy::Devices {
diff --git a/TKPEmu/gb_tkp/gb_ppu.h b/TKPEmu/gb_tkp/gb_ppu.h
index bc494524d03e0e82c0a96a68f9ec33a31409af8d..35a73bf0d8f0cec2304db91ae8000c2c3321bed3 100644
--- a/TKPEmu/gb_tkp/gb_ppu.h
+++ b/TKPEmu/gb_tkp/gb_ppu.h
@@ -2,9 +2,8 @@
 #ifndef TKP_GB_PPU_H
 #define TKP_GB_PPU_H
 #include "gb_bus.h"
-#include "TKPImage.h"
+#include "../include/TKPImage.h"
 #include <mutex>
-#include <queue>
 #include <array>
 namespace TKPEmu::Gameboy::Devices {
 	constexpr int FRAME_CYCLES = 70224;
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index 28f01b7378b5e2dcae7ed7e0ebc84177fe388b16..410416cebd82ffe7e0408173fb2fae746c80f0c7 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -1,5 +1,5 @@
-#include "../include/gb_tracelogger.h"
-#include "../include/gb_addresses.h"
+#include "gb_tracelogger.h"
+#include "gb_addresses.h"
 #include "../lib/imgui.h"
 namespace TKPEmu::Applications {
 	void GameboyTracelogger::v_draw() {
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.h b/TKPEmu/gb_tkp/gb_tracelogger.h
index bbeb821d82736855d5b9637606574eb2381a9fc4..6864ff95dae8b8be501b9902ea50f7da78eccf2a 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.h
+++ b/TKPEmu/gb_tkp/gb_tracelogger.h
@@ -2,7 +2,7 @@
 #ifndef TKP_GB_TRACELOGGER_H
 #define TKP_GB_TRACELOGGER_H
 #include <array>
-#include "base_tracelogger.h"
+#include "../include/base_tracelogger.h"
 #include "gameboy.h"
 namespace TKPEmu::Applications {
 	using Gameboy = TKPEmu::Gameboy::Gameboy;

From ddb1341131af0445874fb80e0cf586e0fb2d9a9a Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 22 Nov 2021 23:57:55 +0200
Subject: [PATCH] moving less changed files to /lib

---
 TKPEmu/gb_tkp/README.md | 56 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..0eef2486138acac9275a2db2150fbb82689338bc
--- /dev/null
+++ b/TKPEmu/gb_tkp/README.md
@@ -0,0 +1,56 @@
+# GameboyTKP
+Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
+## Features
+
+ - Disassembler/Debugger with step/reset/pause functionality
+ - Advanced breakpoints. You can create a breakpoint for a specific instruction with specific register values
+ - Real time register values shown on disassembler
+ - Trace logger (WIP)
+ - Save states (WIP)
+ - Rewind functionality (WIP)
+## Tests
+
+**[Blargg](https://github.com/gblargg)'s tests:**
+| Test | GameboyTKP  |
+|--|--|
+| cpu_instrs |  |
+| instr_timing |  (Issue [#3](https://github.com/OFFTKP/TKPEmu/issues/3))|
+| mem_timing |  |
+| dmg_sound |  |
+| oam_bug |  |
+
+**[Gekkio](https://github.com/Gekkio)'s acceptance tests:**
+
+|Test| GameboyTKP |
+|--|--|
+| bits/mem_oam |  |
+| bits/reg_f |  |
+| bits/unused_hwio_GS |  |
+| instr/daa |  |
+| interrupts/ie_push |  |
+| oam_dma/basic |  |
+| oam_dma/reg_read |  |
+| oam_dma/sources-GS |  (needs MBC5)|
+| ppu/... |  (untested)|
+| serial/... |  (untested)|
+| timer/div_write |  |
+| timer/rapid_toggle |  |
+| timer/tim00 |  |
+| timer/tim00_div_trigger |  |
+| timer/tim01 |  (Issue [#4](https://github.com/OFFTKP/TKPEmu/issues/4))|
+| timer/tim01_div_trigger |  |
+| timer/tim10 |  |
+| timer/tim10_div_trigger |  |
+| timer/tim11 |  |
+| timer/tim11_div_trigger |  |
+| timer/tima_reload |  |
+| timer/tima_write_reloading |  |
+| timer/tma_write_reloading |  |
+
+**[mattcurie](https://github.com/mattcurrie)'s tests:**
+|Test|GameboyTKP  |
+|--|--|
+| dmg-acid2 |  (Milestone [#1](https://github.com/OFFTKP/TKPEmu/milestone/1)) |
+
+## License
+See [TKPEmu](https://github.com/OFFTKP/TKPEmu) license

From 8030d6e26f096ada0e53ac2cba02805e821da674 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 22 Nov 2021 23:59:50 +0200
Subject: [PATCH] Update README.md

---
 TKPEmu/gb_tkp/README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index 0eef2486138acac9275a2db2150fbb82689338bc..9ba915aad56e2b64e724934078f6f356ce535189 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -5,7 +5,7 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
  - Disassembler/Debugger with step/reset/pause functionality
  - Advanced breakpoints. You can create a breakpoint for a specific instruction with specific register values
  - Real time register values shown on disassembler
- - Trace logger (WIP)
+ - Trace logger
  - Save states (WIP)
  - Rewind functionality (WIP)
 ## Tests

From 8c8a6e853c7ac1ecba06257ca07096ca3b2c19c1 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 23 Nov 2021 17:05:14 +0200
Subject: [PATCH] general qol changes

---
 TKPEmu/gb_tkp/gb_disassembler.cpp | 303 ++++++++++++++++++++++++++++++++++++
 TKPEmu/gb_tkp/gb_disassembler.h   | 316 +-------------------------------------
 TKPEmu/gb_tkp/gb_tracelogger.cpp  |   2 +-
 3 files changed, 311 insertions(+), 310 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..9dd6e2e21993943e98d48995a236c03301478e0d
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -0,0 +1,303 @@
+#include "gb_disassembler.h"
+
+namespace TKPEmu::Applications {
+    GameboyDisassembler::GameboyDisassembler(bool* rom_loaded) : BaseDisassembler(rom_loaded) {
+        sel_map_.resize(0x10000);
+    };
+    void GameboyDisassembler::Focus(int item) {
+        ImGuiContext& g = *ImGui::GetCurrentContext();
+        ImGuiWindow* window = g.CurrentWindow;
+        // TODO: find a way to make item_height not hard coded
+        static const int item_height = 17;
+        window->Scroll.y = IM_FLOOR(item_height * item);
+    }
+    void GameboyDisassembler::v_draw() {
+        Gameboy* gameboy = static_cast<Gameboy*>(emulator_);
+        bool bp_add_popup = false;
+        int goto_pc = -1;
+        if (ImGui::BeginMenuBar()) {
+            if (ImGui::BeginMenu("Emulation")) {
+                DrawMenuEmulation(gameboy, rom_loaded_);
+            }
+            if (ImGui::BeginMenu("Navigation")) {
+                if (ImGui::MenuItem("Step", "F7", false, gameboy->Paused.load())) {
+                    gameboy->Step.store(true);
+                    gameboy->Step.notify_all();
+                }
+                if (ImGui::MenuItem("Goto PC")) {
+                    // TODO: if PC not found, go to nearest close to that value
+                    OpenGotoPopup = true;
+                }
+                ImGui::EndMenu();
+            }
+            ImGui::EndMenuBar();
+        }
+        if (OpenGotoPopup) {
+            ImGui::OpenPopup("Goto Program Code");
+        }
+        ImVec2 center = ImGui::GetMainViewport()->GetCenter();
+        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+        if (ImGui::BeginPopupModal("Goto Program Code", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+            ImGui::Text("Program Code (in hex) to go to:");
+            ImGui::Separator();
+            // 4 hexadecimal characters and a null terminator
+            constexpr size_t buf_size = 4 + 1;
+            static char buf[buf_size] = "";
+            bool close = false;
+            if (OpenGotoPopup) {
+                if (!ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
+                    ImGui::SetKeyboardFocusHere(0);
+                OpenGotoPopup = false;
+            }
+            if (ImGui::InputText("hexadecimal", buf, buf_size, 
+                    ImGuiInputTextFlags_CharsHexadecimal |
+                    ImGuiInputTextFlags_CharsUppercase |
+                    ImGuiInputTextFlags_EnterReturnsTrue)) {
+                close = true;
+            }
+            if (ImGui::Button("OK", ImVec2(120, 0))) {
+                close = true;
+            }
+            if (close) {
+                // Convert hex to int
+                unsigned x = 0;
+                std::stringstream ss;
+                ss << std::hex << buf;
+                ss >> x;
+                goto_pc = x;
+                ImGui::CloseCurrentPopup();
+            }
+            ImGui::EndPopup();
+        }
+        static ImGuiTableFlags flags = ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV
+            | ImGuiTableFlags_ScrollY | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_BordersInnerV;
+        {
+            ImGui::BeginChild("ChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.6f, ImGui::GetContentRegionAvail().y), true);
+            if (ImGui::BeginTable("cmds", 3, flags)) {
+                ImGui::TableSetupColumn("PC");
+                ImGui::TableSetupColumn("Opcode");
+                ImGui::TableSetupColumn("Description");
+                ImGui::TableSetupScrollFreeze(0, 1);
+                ImGui::TableHeadersRow();
+                if (clear_all_flag) {
+                    clear_all_flag = false;
+                    std::fill(sel_map_.begin(), sel_map_.end(), false);
+                }
+                ImGuiListClipper clipper;
+                clipper.Begin(0x10000);
+                // TODO: cache disassembly instructions (overhead might not be enough for it to matter however)
+
+                // Issue #006:
+                // On first Clipper.Step() displaystart and displayend are 0 and 1 no matter how far down we scrolled
+                // This means that if we aren't actually at the top, and instruction 0 uses parameters, the top 1/2 instructions will always
+                // appear as (Parameter). This boolean helps fix this bug on that special edge case.
+                bool imgui_bug = false;
+                int skip = 0;
+                while (clipper.Step()) {
+                    if (imgui_bug) {
+                        if (clipper.DisplayStart != 1) {
+                            // Edge case detected. Set skip to 0 to avoid bug.
+                            imgui_bug = false;
+                            skip = 0;
+                        }
+                    }
+                    for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
+                        bool is_skipped = false;
+                        DisInstr ins = gameboy->GetInstruction(row_n);
+                        if (skip == 0) {
+                            skip += ins.ParamSize;
+                            if (row_n == 0) 
+                                imgui_bug = true;
+                        } else {
+                            skip--;
+                            is_skipped = true;
+                        }
+                        ImGui::PushID(row_n);
+                        ImGui::TableNextRow();
+                        ImGui::TableSetColumnIndex(0);
+                        if (ImGui::Selectable("$", sel_map_[row_n], ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
+                            if (gameboy->Paused.load()) {
+                                sel_map_[row_n].flip();
+                                if (sel_map_[row_n]) {
+                                    GBBPArguments bp_arg;
+                                    bp_arg.PC_using = true;
+                                    bp_arg.PC_value = ins.InstructionProgramCode;
+                                    gameboy->AddBreakpoint(bp_arg);
+                                }
+                                else {
+                                    auto it = std::find_if(
+                                        std::execution::par_unseq,
+                                        gameboy->Breakpoints.begin(),
+                                        gameboy->Breakpoints.end(),
+                                        [target = ins.InstructionProgramCode](const GameboyBreakpoint& bp) {
+                                            return bp.BPFromTable && bp.Args.PC_value == target;
+                                        }
+                                    );
+                                    if (it != gameboy->Breakpoints.end())
+                                        gameboy->Breakpoints.erase(it);
+                                }
+                            }
+                        }
+                        ImGui::SameLine();
+                        ImGui::Text("%04X", ins.InstructionProgramCode);
+                        ImGui::TableSetColumnIndex(1);
+                        ImGui::Text("%02X", ins.Instruction);
+                        switch (ins.ParamSize) {
+                        case 0:
+                            ImGui::SameLine();
+                            ImGui::TextUnformatted("     ");
+                            break;
+                        case 1:
+                            ImGui::SameLine();
+                            ImGui::Text("%02X   ", ins.Params[0]);
+                            break;
+                        case 2:
+                            ImGui::SameLine();
+                            ImGui::Text("%02X,%02X", ins.Params[0], ins.Params[1]);
+                            break;
+                        }
+                        ImGui::TableSetColumnIndex(2);
+                        if (!is_skipped){
+                            ImGui::TextUnformatted(gameboy->GetCPU().Instructions[ins.Instruction].name.c_str());
+                            switch (ins.ParamSize) {
+                                case 1:
+                                    ImGui::SameLine();
+                                    ImGui::Text("0x%02X", ins.Params[0]);
+                                    break;
+                                case 2:
+                                    ImGui::SameLine();
+                                    ImGui::Text("0x%02X%02X", ins.Params[1], ins.Params[0]);
+                                    break;
+                            }
+                        } else {
+                            ImGui::SameLine();
+                            ImGui::TextUnformatted("(Parameter)");
+                        }
+                        ImGui::PopID();
+                    }
+                }
+                if (auto inst = gameboy->InstructionBreak.load(); inst != -1) {
+                    goto_pc = inst;
+                    gameboy->InstructionBreak.store(-1);
+                }
+                if (goto_pc != -1) {
+                    Focus(goto_pc);
+                }
+                ImGui::EndTable();
+            }
+            ImGui::EndChild();
+        }
+        ImGui::SameLine();
+        {
+            ImGui::BeginChild("ChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), false);
+            if (ImGui::BeginTable("bps", 1, flags, ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.6f))) {
+                ImGui::TableSetupColumn("Breakpoints");
+                ImGui::TableHeadersRow();
+
+                ImGuiListClipper clipper;
+                clipper.Begin(gameboy->Breakpoints.size());
+                while (clipper.Step()) {
+                    for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
+                        auto& bp = gameboy->Breakpoints[row_n];
+                        ImGui::PushID(row_n);
+                        ImGui::TableNextRow();
+                        ImGui::TableSetColumnIndex(0);
+                        bool sel = false;
+                        if (row_n == selected_bp)
+                            sel = true;
+                        if (ImGui::Selectable(bp.GetName().c_str(), sel, ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
+                            if (!sel)
+                                selected_bp = row_n;
+                            else
+                                selected_bp = -1;
+                        }
+                        ImGui::PopID();
+                    }
+                }
+                ImGui::EndTable();
+            }
+            if (ImGui::Button("Add", ImVec2(ImGui::GetContentRegionAvail().x * (1.0f / 3.0f), ImGui::GetContentRegionAvail().y * 0.15f))) {
+                bp_add_popup = true;
+            }
+            ImGui::SameLine();
+            bool disable = false;
+            // If a breakpoint isn't selected, disable the "Remove" button
+            if (selected_bp == -1) {
+                disable = true;
+                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+            }
+            if (ImGui::Button("Remove", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.15f))) {
+                if (gameboy->Breakpoints[selected_bp].BPFromTable) {
+                    // We have to remove the breakpoint selection from the table too
+                    sel_map_[gameboy->Breakpoints[selected_bp].Args.PC_value] = false;
+                }
+                gameboy->Breakpoints.erase(gameboy->Breakpoints.begin() + selected_bp);
+                selected_bp = -1;
+            }
+            if (disable) {
+                ImGui::PopItemFlag();
+            }
+            ImGui::SameLine();
+            if (ImGui::Button("Clear", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.15f))) {
+                gameboy->Breakpoints.clear();
+                clear_all_flag = true;
+            }
+            static bool use_hex = true;
+            auto& t = gameboy->GetCPU();
+            if (use_hex) {
+                ImGui::Text("AF: 0x%02x%02x", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: 0x%04x", t.PC);
+                ImGui::Text("BC: 0x%02x%02x", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: 0x%04x", t.SP);
+                ImGui::Text("DE: 0x%02x%02x", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: 0x%02x", t.IE);
+                ImGui::Text("HL: 0x%02x%02x", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: 0x%02x", t.IF);
+            }
+            else {
+                ImGui::Text("AF: %d,%d", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: %d", t.PC);
+                ImGui::Text("BC: %d,%d", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: %d", t.SP);
+                ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
+                ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
+            }
+            ImGui::Checkbox("Hex", &use_hex);
+            ImGui::EndChild();
+            // TODO: add switch from hex to binary on every textbox here
+            if (bp_add_popup) {
+                ImGui::OpenPopup("Add breakpoint");
+                bp_add_popup = false;
+            }
+            ImGui::SetNextWindowSize(ImVec2(250, 250));
+            ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+            if (ImGui::BeginPopupModal("Add breakpoint", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+                ImGui::Text("Configure the breakpoint:");
+                ImGui::Separator();
+                static GBBPArguments bp_arg;
+                {
+                    ImGui::BeginChild("bpChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.9f));
+                    breakpoint_register_checkbox("A:", bp_arg.A_value, bp_arg.A_using);
+                    breakpoint_register_checkbox("B:", bp_arg.B_value, bp_arg.B_using);
+                    breakpoint_register_checkbox("D:", bp_arg.D_value, bp_arg.D_using);
+                    breakpoint_register_checkbox("H:", bp_arg.H_value, bp_arg.H_using);
+                    breakpoint_register_checkbox("PC:", bp_arg.PC_value, bp_arg.PC_using, ImGuiDataType_U16);
+                    breakpoint_register_checkbox("Instr:", bp_arg.Ins_value, bp_arg.Ins_using);
+                    ImGui::EndChild();
+                }
+                ImGui::SameLine();
+                {
+                    ImGui::BeginChild("bpChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.9f));
+                    breakpoint_register_checkbox("F:", bp_arg.F_value, bp_arg.F_using);
+                    breakpoint_register_checkbox("C:", bp_arg.C_value, bp_arg.C_using);
+                    breakpoint_register_checkbox("E:", bp_arg.E_value, bp_arg.E_using);
+                    breakpoint_register_checkbox("L:", bp_arg.L_value, bp_arg.L_using);
+                    breakpoint_register_checkbox("SP:", bp_arg.SP_value, bp_arg.SP_using, ImGuiDataType_U16);
+                    ImGui::EndChild();
+                }
+                if (ImGui::Button("Add", ImVec2(120, 0))) {
+                    bool pc_only = gameboy->AddBreakpoint(bp_arg);
+                    if (pc_only) {
+                        sel_map_[bp_arg.PC_value] = true;
+                    }
+                    ImGui::CloseCurrentPopup();
+                }
+                ImGui::EndPopup();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index 4d7abffcfdf3de2aa2a8e7afd93551d5f4154c51..d478cd5cc9675c61d0d9aefed9ca8b7a64e1fd73 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -9,323 +9,21 @@
 #include "../include/base_disassembler.h"
 #include "gb_breakpoint.h"
 #include "gameboy.h"
-// TODO: put code in .cpp file
 namespace TKPEmu::Applications {
+    using Gameboy = TKPEmu::Gameboy::Gameboy;
+    using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
+    using GBSelectionMap = std::vector<bool>;
     class GameboyDisassembler : public BaseDisassembler {
+    public:
+        GameboyDisassembler(bool* rom_loaded);
+        void Focus(int item);
+        void v_draw() override;
     private:
-        using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
-        using Gameboy = TKPEmu::Gameboy::Gameboy;
-        using GBSelectionMap = std::vector<bool>;
         GameboyBreakpoint debug_rvalues_;
         GBSelectionMap sel_map_{};
-        Gameboy* emulator_ = nullptr;
         uint8_t* LY_ = nullptr;
         bool clear_all_flag = false;
         int selected_bp = -1;
-    public:
-        GameboyDisassembler(bool* rom_loaded) : BaseDisassembler(rom_loaded) {
-            sel_map_.resize(0x10000);
-        };
-        void Focus(int item) noexcept {
-            ImGuiContext& g = *ImGui::GetCurrentContext();
-            ImGuiWindow* window = g.CurrentWindow;
-            // TODO: find a way to make item_height not hard coded
-            static const int item_height = 17;
-            window->Scroll.y = IM_FLOOR(item_height * item);
-        }
-        void SetEmulator(Emulator* emulator) override {
-            emulator_ = dynamic_cast<Gameboy*>(emulator);
-        }
-        void v_draw() noexcept {
-            bool bp_add_popup = false;
-            int goto_pc = -1;
-            if (ImGui::BeginMenuBar()) {
-                if (ImGui::BeginMenu("Emulation")) {
-                    DrawMenuEmulation(emulator_, rom_loaded_);
-                }
-                if (ImGui::BeginMenu("Navigation")) {
-                    if (ImGui::MenuItem("Step", "F7", false, emulator_->Paused.load())) {
-                        emulator_->Step.store(true);
-                        emulator_->Step.notify_all();
-                    }
-                    if (ImGui::MenuItem("Goto PC")) {
-                        // TODO: if PC not found, go to nearest close to that value
-                        OpenGotoPopup = true;
-                    }
-                    ImGui::EndMenu();
-                }
-                ImGui::EndMenuBar();
-            }
-            if (OpenGotoPopup) {
-                ImGui::OpenPopup("Goto Program Code");
-            }
-            ImVec2 center = ImGui::GetMainViewport()->GetCenter();
-            ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
-            if (ImGui::BeginPopupModal("Goto Program Code", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
-                ImGui::Text("Program Code (in hex) to go to:");
-                ImGui::Separator();
-                // 4 hexadecimal characters and a null terminator
-                constexpr size_t buf_size = 4 + 1;
-                static char buf[buf_size] = "";
-                bool close = false;
-                if (OpenGotoPopup) {
-                    if (!ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
-                        ImGui::SetKeyboardFocusHere(0);
-                    OpenGotoPopup = false;
-                }
-                if (ImGui::InputText("hexadecimal", buf, buf_size, 
-                        ImGuiInputTextFlags_CharsHexadecimal |
-                        ImGuiInputTextFlags_CharsUppercase |
-                        ImGuiInputTextFlags_EnterReturnsTrue)) {
-                    close = true;
-                }
-                if (ImGui::Button("OK", ImVec2(120, 0))) {
-                    close = true;
-                }
-                if (close) {
-                    // Convert hex to int
-                    unsigned x = 0;
-                    std::stringstream ss;
-                    ss << std::hex << buf;
-                    ss >> x;
-                    goto_pc = x;
-                    ImGui::CloseCurrentPopup();
-                }
-                ImGui::EndPopup();
-            }
-            static ImGuiTableFlags flags = ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV
-                | ImGuiTableFlags_ScrollY | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_BordersInnerV;
-            {
-                ImGui::BeginChild("ChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.6f, ImGui::GetContentRegionAvail().y), true);
-                if (ImGui::BeginTable("cmds", 3, flags)) {
-                    ImGui::TableSetupColumn("PC");
-                    ImGui::TableSetupColumn("Opcode");
-                    ImGui::TableSetupColumn("Description");
-                    ImGui::TableSetupScrollFreeze(0, 1);
-                    ImGui::TableHeadersRow();
-                    if (clear_all_flag) {
-                        clear_all_flag = false;
-                        std::fill(sel_map_.begin(), sel_map_.end(), false);
-                    }
-                    ImGuiListClipper clipper;
-                    clipper.Begin(0x10000);
-                    // TODO: cache disassembly instructions (overhead might not be enough for it to matter however)
-
-                    // Issue #006:
-                    // On first Clipper.Step() displaystart and displayend are 0 and 1 no matter how far down we scrolled
-                    // This means that if we aren't actually at the top, and instruction 0 uses parameters, the top 1/2 instructions will always
-                    // appear as (Parameter). This boolean helps fix this bug on that special edge case.
-                    bool imgui_bug = false;
-                    int skip = 0;
-                    while (clipper.Step()) {
-                        if (imgui_bug) {
-                            if (clipper.DisplayStart != 1) {
-                                // Edge case detected. Set skip to 0 to avoid bug.
-                                imgui_bug = false;
-                                skip = 0;
-                            }
-                        }
-                        for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
-                            bool is_skipped = false;
-                            DisInstr ins = emulator_->GetInstruction(row_n);
-                            if (skip == 0) {
-                                skip += ins.ParamSize;
-                                if (row_n == 0) 
-                                    imgui_bug = true;
-                            } else {
-                                skip--;
-                                is_skipped = true;
-                            }
-                            ImGui::PushID(row_n);
-                            ImGui::TableNextRow();
-                            ImGui::TableSetColumnIndex(0);
-                            if (ImGui::Selectable("$", sel_map_[row_n], ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
-                                if (emulator_->Paused.load()) {
-                                    sel_map_[row_n].flip();
-                                    if (sel_map_[row_n]) {
-                                        GBBPArguments bp_arg;
-                                        bp_arg.PC_using = true;
-                                        bp_arg.PC_value = ins.InstructionProgramCode;
-                                        emulator_->AddBreakpoint(bp_arg);
-                                    }
-                                    else {
-                                        auto it = std::find_if(
-                                            std::execution::par_unseq,
-                                            emulator_->Breakpoints.begin(),
-                                            emulator_->Breakpoints.end(),
-                                            [target = ins.InstructionProgramCode](const GameboyBreakpoint& bp) {
-                                                return bp.BPFromTable && bp.Args.PC_value == target;
-                                            }
-                                        );
-                                        if (it != emulator_->Breakpoints.end())
-                                            emulator_->Breakpoints.erase(it);
-                                    }
-                                }
-                            }
-                            ImGui::SameLine();
-                            ImGui::Text("%04X", ins.InstructionProgramCode);
-                            ImGui::TableSetColumnIndex(1);
-                            ImGui::Text("%02X", ins.Instruction);
-                            switch (ins.ParamSize) {
-                            case 0:
-                                ImGui::SameLine();
-                                ImGui::TextUnformatted("     ");
-                                break;
-                            case 1:
-                                ImGui::SameLine();
-                                ImGui::Text("%02X   ", ins.Params[0]);
-                                break;
-                            case 2:
-                                ImGui::SameLine();
-                                ImGui::Text("%02X,%02X", ins.Params[0], ins.Params[1]);
-                                break;
-                            }
-                            ImGui::TableSetColumnIndex(2);
-                            if (!is_skipped){
-                                ImGui::TextUnformatted(emulator_->GetCPU().Instructions[ins.Instruction].name.c_str());
-                                switch (ins.ParamSize) {
-                                    case 1:
-                                        ImGui::SameLine();
-                                        ImGui::Text("0x%02X", ins.Params[0]);
-                                        break;
-                                    case 2:
-                                        ImGui::SameLine();
-                                        ImGui::Text("0x%02X%02X", ins.Params[1], ins.Params[0]);
-                                        break;
-                                }
-                            } else {
-                                ImGui::SameLine();
-                                ImGui::TextUnformatted("(Parameter)");
-                            }
-                            ImGui::PopID();
-                        }
-                    }
-                    if (auto inst = emulator_->InstructionBreak.load(); inst != -1) {
-                        goto_pc = inst;
-                        emulator_->InstructionBreak.store(-1);
-                    }
-                    if (goto_pc != -1) {
-                        Focus(goto_pc);
-                    }
-                    ImGui::EndTable();
-                }
-                ImGui::EndChild();
-            }
-            ImGui::SameLine();
-            {
-                ImGui::BeginChild("ChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y), false);
-                if (ImGui::BeginTable("bps", 1, flags, ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.6f))) {
-                    ImGui::TableSetupColumn("Breakpoints");
-                    ImGui::TableHeadersRow();
-
-                    ImGuiListClipper clipper;
-                    clipper.Begin(emulator_->Breakpoints.size());
-                    while (clipper.Step()) {
-                        for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
-                            auto& bp = emulator_->Breakpoints[row_n];
-                            ImGui::PushID(row_n);
-                            ImGui::TableNextRow();
-                            ImGui::TableSetColumnIndex(0);
-                            bool sel = false;
-                            if (row_n == selected_bp)
-                                sel = true;
-                            if (ImGui::Selectable(bp.GetName().c_str(), sel, ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowItemOverlap)) {
-                                if (!sel)
-                                    selected_bp = row_n;
-                                else
-                                    selected_bp = -1;
-                            }
-                            ImGui::PopID();
-                        }
-                    }
-                    ImGui::EndTable();
-                }
-                if (ImGui::Button("Add", ImVec2(ImGui::GetContentRegionAvail().x * (1.0f / 3.0f), ImGui::GetContentRegionAvail().y * 0.15f))) {
-                    bp_add_popup = true;
-                }
-                ImGui::SameLine();
-                bool disable = false;
-                // If a breakpoint isn't selected, disable the "Remove" button
-                if (selected_bp == -1) {
-                    disable = true;
-                    ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
-                }
-                if (ImGui::Button("Remove", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.15f))) {
-                    if (emulator_->Breakpoints[selected_bp].BPFromTable) {
-                        // We have to remove the breakpoint selection from the table too
-                        sel_map_[emulator_->Breakpoints[selected_bp].Args.PC_value] = false;
-                    }
-                    emulator_->Breakpoints.erase(emulator_->Breakpoints.begin() + selected_bp);
-                    selected_bp = -1;
-                }
-                if (disable) {
-                    ImGui::PopItemFlag();
-                }
-                ImGui::SameLine();
-                if (ImGui::Button("Clear", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.15f))) {
-                    emulator_->Breakpoints.clear();
-                    clear_all_flag = true;
-                }
-                static bool use_hex = true;
-                auto& t = emulator_->GetCPU();
-                if (use_hex) {
-                    ImGui::Text("AF: 0x%02x%02x", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: 0x%04x", t.PC);
-                    ImGui::Text("BC: 0x%02x%02x", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: 0x%04x", t.SP);
-                    ImGui::Text("DE: 0x%02x%02x", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: 0x%02x", t.IE);
-                    ImGui::Text("HL: 0x%02x%02x", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: 0x%02x", t.IF);
-                }
-                else {
-                    ImGui::Text("AF: %d,%d", t.A, t.F); ImGui::SameLine(); ImGui::Text("PC: %d", t.PC);
-                    ImGui::Text("BC: %d,%d", t.B, t.C); ImGui::SameLine(); ImGui::Text("SP: %d", t.SP);
-                    ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
-                    ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
-                }
-                ImGui::Checkbox("Hex", &use_hex);
-                ImGui::EndChild();
-                // TODO: add switch from hex to binary on every textbox here
-                if (bp_add_popup) {
-                    ImGui::OpenPopup("Add breakpoint");
-                    bp_add_popup = false;
-                }
-                ImGui::SetNextWindowSize(ImVec2(250, 250));
-                ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
-                if (ImGui::BeginPopupModal("Add breakpoint", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
-                    ImGui::Text("Configure the breakpoint:");
-                    ImGui::Separator();
-                    static GBBPArguments bp_arg;
-                    {
-                        ImGui::BeginChild("bpChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.9f));
-                        breakpoint_register_checkbox("A:", bp_arg.A_value, bp_arg.A_using);
-                        breakpoint_register_checkbox("B:", bp_arg.B_value, bp_arg.B_using);
-                        breakpoint_register_checkbox("D:", bp_arg.D_value, bp_arg.D_using);
-                        breakpoint_register_checkbox("H:", bp_arg.H_value, bp_arg.H_using);
-                        breakpoint_register_checkbox("PC:", bp_arg.PC_value, bp_arg.PC_using, ImGuiDataType_U16);
-                        breakpoint_register_checkbox("Instr:", bp_arg.Ins_value, bp_arg.Ins_using);
-                        ImGui::EndChild();
-                    }
-                    ImGui::SameLine();
-                    {
-                        ImGui::BeginChild("bpChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.9f));
-                        breakpoint_register_checkbox("F:", bp_arg.F_value, bp_arg.F_using);
-                        breakpoint_register_checkbox("C:", bp_arg.C_value, bp_arg.C_using);
-                        breakpoint_register_checkbox("E:", bp_arg.E_value, bp_arg.E_using);
-                        breakpoint_register_checkbox("L:", bp_arg.L_value, bp_arg.L_using);
-                        breakpoint_register_checkbox("SP:", bp_arg.SP_value, bp_arg.SP_using, ImGuiDataType_U16);
-                        ImGui::EndChild();
-                    }
-                    if (ImGui::Button("Add", ImVec2(120, 0))) {
-                        bool pc_only = emulator_->AddBreakpoint(bp_arg);
-                        if (pc_only) {
-                            sel_map_[bp_arg.PC_value] = true;
-                        }
-                        ImGui::CloseCurrentPopup();
-                    }
-
-                    ImGui::EndPopup();
-                }
-            }
-        }
-    private:
         template<typename T>
         void breakpoint_register_checkbox(const char* checkbox_l, T& value, bool& is_used, ImGuiDataType type = ImGuiDataType_U8) {
             ImGui::Checkbox(checkbox_l, &is_used);
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index 410416cebd82ffe7e0408173fb2fae746c80f0c7..f86bf36e8b9b3632926c4778a0d9d7f37e7f9641 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -20,6 +20,6 @@ namespace TKPEmu::Applications {
 				ptr->push_back(LogTypeMap[i]);
 			}
 		}
-		(dynamic_cast<Gameboy*>(emulator_))->SetLogTypes(std::move(ptr));
+		static_cast<Gameboy*>(emulator_)->SetLogTypes(std::move(ptr));
 	}
 }

From 3b105679980f32d97f591c882232fd6514c7e383 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 23 Nov 2021 19:56:38 +0200
Subject: [PATCH] new timer class, new settings option to skip boot sequence
 and other minor changes

---
 TKPEmu/gb_tkp/gameboy.cpp         |  22 +++++--
 TKPEmu/gb_tkp/gameboy.h           |   9 ++-
 TKPEmu/gb_tkp/gb_addresses.h      |  29 +++++++++
 TKPEmu/gb_tkp/gb_bus.h            |  34 -----------
 TKPEmu/gb_tkp/gb_cpu.cpp          | 122 ++++++--------------------------------
 TKPEmu/gb_tkp/gb_cpu.h            |   9 +--
 TKPEmu/gb_tkp/gb_disassembler.cpp |   1 -
 TKPEmu/gb_tkp/gb_ppu.cpp          |   4 +-
 TKPEmu/gb_tkp/gb_ppu.h            |   7 +--
 TKPEmu/gb_tkp/gb_timer.cpp        |  38 ++++++++++++
 TKPEmu/gb_tkp/gb_timer.h          |  19 ++++++
 11 files changed, 133 insertions(+), 161 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index e676b06a398e19689b192625eb49b6b3f32fe57a..ba417d66f79d116d07dc3ed9bbdea12f79ec098c 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -19,6 +19,7 @@ namespace TKPEmu::Gameboy {
 		bus_(Instructions),
 		cpu_(&bus_),
 		ppu_(&bus_, &DrawMutex),
+		timer_(&bus_),
 		direction_keys_(direction_keys),
 		action_keys_(action_keys),
 		joypad_(bus_.GetReference(addr_joy)),
@@ -155,9 +156,16 @@ namespace TKPEmu::Gameboy {
 		UpdateThread = std::thread(func);
 		UpdateThread.detach();
 	}
-	void Gameboy::Reset() {
+	void Gameboy::reset_normal() {
 		bus_.SoftReset();
-		cpu_.Reset();
+		cpu_.Reset(false);
+		timer_.Reset();
+		ppu_.Reset();
+	}
+	void Gameboy::reset_skip() {
+		bus_.SoftReset();
+		cpu_.Reset(true);
+		timer_.Reset();
 		ppu_.Reset();
 	}
 	void Gameboy::update() {
@@ -165,17 +173,19 @@ namespace TKPEmu::Gameboy {
 			bus_.BiosEnabled = false;
 		}
 		int clk = cpu_.Update();
+		if (timer_.Update(clk)) {
+			interrupt_flag_ |= IFInterrupt::TIMER;
+		}
 		ppu_.Update(clk);
 		if (cpu_.TClock >= cpu_.MaxCycles) {
 			cpu_.TClock = 0;
-			cpu_.TimerCounter = cpu_.ClockSpeed / 0x400;
 			limit_fps();
 		}
 		log_state();
 	}
 	std::string Gameboy::print() const { 
 		return "GameboyTKP for TKPEmu\n"
-		       "Read more: https://github.com/OFFTKP/TKPEmu/blob/master/gb_README.md";
+		       "Read more: https://github.com/OFFTKP/TKPEmu/tree/master/TKPEmu/gb_tkp";
 	}
 	void Gameboy::HandleKeyDown(SDL_Keycode key) {
 		static const uint8_t joy_direction = 0b1110'1111;
@@ -183,12 +193,12 @@ namespace TKPEmu::Gameboy {
 		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
 			int index = it_dir - direction_keys_.begin();
 			bus_.DirectionKeys = (~(1UL << index)) & joy_direction;
-			interrupt_flag_ = TKPEmu::Gameboy::Devices::Bus::JOYPAD;
+			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
 			int index = it_dir - action_keys_.begin();
 			bus_.ActionKeys = (~(1UL << index)) & joy_action;
-			interrupt_flag_ = TKPEmu::Gameboy::Devices::Bus::JOYPAD;
+			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 	}
 	void Gameboy::HandleKeyUp(SDL_Keycode key) {
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 890256c8f8e8fda46ffd7d90476cd3e3d6ae92e9..8b89f3cc647c2d615cfea049a356bb335f65775e 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -1,12 +1,16 @@
 #pragma once
 #ifndef TKP_GB_GAMEBOY_H
 #define TKP_GB_GAMEBOY_H
+// TODO: twitch plays plugin
 #include <array>
 #include "../include/emulator.h"
 #include "../include/disassembly_instr.h"
 #include "gb_breakpoint.h"
 #include "gb_addresses.h"
 #include "gb_cpu.h"
+#include "gb_ppu.h"
+#include "gb_bus.h"
+#include "gb_timer.h"
 namespace TKPEmu::Gameboy {
 	using GameboyPalettes = std::array<std::array<float, 3>,4>;
 	using GameboyKeys = std::array<SDL_Keycode, 4>;
@@ -15,13 +19,13 @@ namespace TKPEmu::Gameboy {
 		using CPU = TKPEmu::Gameboy::Devices::CPU;
 		using PPU = TKPEmu::Gameboy::Devices::PPU;
 		using Bus = TKPEmu::Gameboy::Devices::Bus;
+		using Timer = TKPEmu::Gameboy::Devices::Timer;
 		using Cartridge = TKPEmu::Gameboy::Devices::Cartridge;
 		using DisInstr = TKPEmu::Tools::DisInstr;
 		using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
 	public:
 		Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys);
 		~Gameboy();
-		void Reset() override;
 		void HandleKeyDown(SDL_Keycode key) override;
 		void HandleKeyUp(SDL_Keycode key) override;
 		void LoadFromFile(std::string&& path) override;
@@ -39,6 +43,7 @@ namespace TKPEmu::Gameboy {
 		Bus bus_;
 		CPU cpu_;
 		PPU ppu_;
+		Timer timer_;
 		Cartridge cartridge_;
 		GameboyKeys& direction_keys_;
 		GameboyKeys& action_keys_;
@@ -50,6 +55,8 @@ namespace TKPEmu::Gameboy {
 		void v_log_state() override;
 		void start_normal() override;
 		void start_debug() override;
+		void reset_normal() override;
+		void reset_skip() override;
 		void update() override;
 		std::string print() const override;
 		void limit_fps();
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index c3cedaf32447b3b908422be2ac32455215c31541..856004005f5f253b9d4a0b4cc35c017a0ea7d675 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -4,6 +4,8 @@
 #include "../include/disassembly_instr.h"
 #include "gb_breakpoint.h"
 #include <cstdint>
+using RegisterType = uint8_t;
+using BigRegisterType = uint16_t;
 using DisInstr = TKPEmu::Tools::DisInstr;
 using GBBPArguments = TKPEmu::Gameboy::Utils::GBBPArguments;
 constexpr size_t LogTypeSize = 10;
@@ -12,6 +14,31 @@ enum class LogType {
     E, F, H, L,
     PC, SP,
 };
+enum LCDCFlag {
+    BG_ENABLE = 1 << 0,
+    OBJ_ENABLE = 1 << 1,
+    OBJ_SIZE = 1 << 2,
+    BG_TILEMAP = 1 << 3,
+    BG_TILES = 1 << 4,
+    WND_ENABLE = 1 << 5,
+    WND_TILEMAP = 1 << 6,
+    LCD_ENABLE = 1 << 7
+};
+enum STATFlag {
+    MODE = 0b11,
+    COINCIDENCE = 1 << 2,
+    MODE0_INTER = 1 << 3,
+    MODE1_INTER = 1 << 4,
+    MODE2_INTER = 1 << 5,
+    COINC_INTER = 1 << 6
+};
+enum IFInterrupt {
+    VBLANK = 1 << 0,
+    LCDSTAT = 1 << 1,
+    TIMER = 1 << 2,
+    SERIAL = 1 << 3,
+    JOYPAD = 1 << 4
+};
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::A, LogType::B, LogType::C, LogType::D,
     LogType::E, LogType::F, LogType::H, LogType::L,
@@ -50,6 +77,8 @@ constexpr auto addr_std = 0xFF01;
 constexpr auto addr_stc = 0xFF02;
 // Timer registers
 constexpr auto addr_div = 0xFF04;
+constexpr auto addr_tim = 0xFF05;
+constexpr auto addr_tma = 0xFF06;
 constexpr auto addr_tac = 0xFF07;
 // Interrupt flag
 constexpr auto addr_ifl = 0xFF0F;
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 5faa5dce142f34ab6e08d56e0bf393fccae2f02b..7b4e53251c201c7afd7799c1a92d7c3ec8fed2cb 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -32,46 +32,12 @@ namespace TKPEmu::Gameboy::Devices {
         std::vector<DisInstr>& instructions_;
         uint8_t& redirect_address(uint16_t address);
     public:
-        enum LCDCFlag {
-            BG_ENABLE = 1 << 0,
-            OBJ_ENABLE = 1 << 1,
-            OBJ_SIZE = 1 << 2,
-            BG_TILEMAP = 1 << 3,
-            BG_TILES = 1 << 4,
-            WND_ENABLE = 1 << 5,
-            WND_TILEMAP = 1 << 6,
-            LCD_ENABLE = 1 << 7
-        };
-        enum STATFlag {
-            MODE = 0b11,
-            COINCIDENCE = 1 << 2,
-            MODE0_INTER = 1 << 3,
-            MODE1_INTER = 1 << 4,
-            MODE2_INTER = 1 << 5,
-            COINC_INTER = 1 << 6
-        };
-        enum IFInterrupt {
-            VBLANK = 1 << 0,
-            LCDSTAT = 1 << 1,
-            TIMER = 1 << 2,
-            SERIAL = 1 << 3,
-            JOYPAD = 1 << 4
-        };
         struct Sprite {
             uint8_t y_pos = 0;
             uint8_t x_pos = 0;
             uint8_t tile_index = 0;
             uint8_t flags = 0;
         };
-        struct Pixel {
-            uint8_t color : 2;
-            uint8_t palette : 2;
-            // TODO: CGB Sprite priority
-            uint8_t bg_prio : 1;
-        };
-        struct Tile {
-            Pixel pixels[64];
-        };
         bool BiosEnabled = true;
         uint8_t logo[0x30] = {
             // Every 2 bytes is an 8x8 tile. If you convert the hex to binary, each bit is a 2x2 pixel
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b0fbd5d6229b2e33d275a5b24a52243130dd5d1f..5cb5f92551cb46fca36c1162c41ea6ec529174ea 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -5,10 +5,6 @@ namespace TKPEmu::Gameboy::Devices {
 	CPU::CPU(Bus* bus) : bus_(bus),
 		IF(bus->GetReference(0xFF0F)),
 		IE(bus->GetReference(0xFFFF)),
-		DIVIDER(bus->GetReference(0xFF04)),
-		TIMA(bus->GetReference(0xFF05)),
-		TMA(bus->GetReference(0xFF06)),
-		TAC(bus->GetReference(0xFF07)),
 		LY(bus->GetReference(0xFF44)),
 		JOYP(bus->GetReference(0xFF00))
 	{
@@ -2804,50 +2800,38 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	#pragma endregion
 
-	void CPU::Reset() {
-		A = 0; F = 0;
-		B = 0; C = 0;
-		D = 0; E = 0;
-		H = 0; L = 0;
-		SP = 0;
-		PC = 0;
+	void CPU::Reset(bool skip) {
+		if (!skip) {
+			A = 0; F = 0;
+			B = 0; C = 0;
+			D = 0; E = 0;
+			H = 0; L = 0;
+			SP = 0;
+			PC = 0;
+		} else {
+			A = 0x01; F = 0xB0;
+			B = 0x00; C = 0x13;
+			D = 0x00; E = 0xD8;
+			H = 0x01; L = 0x4D;
+			SP = 0xFFFE;
+			PC = 0x100;
+			LY = 0x91;
+		}
 		TClock = 0;
 		halt_ = false; stop_ = false;
 		JOYP = 0b1110'1111;
-		Oscillator = 0;
-		DIVIDER = 0;
-		div_reset_index_ = -1;
-		TimerCounter = 0;
-		old_tac_ = 0;
 	}
 
 	int CPU::Update() {
 		if (halt_) {
 			PC--;
 		}
-		auto old_if = IF;
 		(this->*Instructions[bus_->Read(PC++)].op)();
-		// Maybe needed to confirm tTemp == 4 also?
-		if (tima_overflow_) {
-			// TIMA might've changed in this strange cycle (see the comment below)
-			// If it changes in that cycle, it doesn't update to be equal to TMA
-			if (TIMA == 0) {
-				TIMA = TMA;
-				// If this isn't true, IF has changed during this instruction so the new value persists
-				if (IF == old_if) {
-					IF |= 1 << 2;
-					halt_ = false;
-				}
-			}
-			tima_overflow_ = false;
-		}
-		update_timers(tTemp);
 		handle_interrupts();
 		TClock += tTemp;
 		TotalClocks += tTemp;
 		return tTemp;
 	}
-
 	void CPU::handle_interrupts() {
 		if (auto temp = IE & IF; ime_ && IF) {
 			// Starting from the lowest bit (highest priority) and going up,
@@ -2860,7 +2844,6 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 		}
 	}
-
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;
 		IF &= ~(1U << bit);
@@ -2868,75 +2851,4 @@ namespace TKPEmu::Gameboy::Devices {
 		SP -= 2;
 		PC = 0x40 + bit * 0x8;
 	}
-
-	void CPU::update_timers(int cycles) {
-		int freq = get_clk_freq();
-		if (bus_->DIVReset) {
-			bus_->DIVReset = false;
-			if (div_reset_index_ >= freq / 2) {
-				TIMA++;
-			}
-			Oscillator = 0;
-			TimerCounter = 0;
-			div_reset_index_ = 0;
-		}
-		if (bus_->TACChanged) {
-			bus_->TACChanged = false;
-			uint8_t new_tac = TAC;
-			TAC = old_tac_;
-			int old_freq = get_clk_freq();
-			TAC = new_tac;
-			if ((old_tac_ >> 2) & 1) {
-				// If old tac was enabled
-				// TODO: prettify timer after its fully implemented
-				if (!((new_tac >> 2) & 1)) {
-					if ((div_reset_index_ & (old_freq / 2)) != 0) {
-						TIMA++;
-					}
-				}
-				else {
-					if ((div_reset_index_ & (old_freq / 2)) != 0 && ((div_reset_index_ & (freq / 2)) == 0)) {
-						TIMA++;
-					}
-				}
-			}
-			old_tac_ = new_tac;
-		}
-		bool enabled = (TAC >> 2) & 0x1;
-		Oscillator += cycles;
-		// Divider always equals the top 8 bits of the oscillator
-		DIVIDER = Oscillator >> 8;
-		if (div_reset_index_ != -1)
-			div_reset_index_ += cycles;
-		if (div_reset_index_ > freq) {
-			TIMA++;
-			div_reset_index_ = -1;
-		}
-		if (enabled) {
-			TimerCounter += cycles;
-			while (TimerCounter >= freq) {
-				TimerCounter -= freq;
-				//TimerCounter = get_clk_freq();
-				if (TIMA == 0xFF) {
-					/*TIMA = TMA;
-					IF |= 1 << 2;
-					halt_ = false;*/
-					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
-					TIMA = 0;
-					tima_overflow_ = true;
-				}
-				else {
-					TIMA++;
-				}
-			}
-		}
-	}
-	int CPU::get_clk_freq() {
-		switch (TAC & 0b11) {
-			case 0: return 1024;
-			case 1: return 16;
-			case 2: return 64;
-			case 3: return 256;
-		}
-	}
 }
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 5d4b4e8c8266dbb8f952dc5950a22b23b768e0e1..0cef6d3c1db61ae198f3ff3c0c2c2c7aeec17759 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -12,9 +12,6 @@
 #include "../include/disassembly_instr.h"
 namespace TKPEmu::Gameboy::Devices {
 	class CPU {
-	private:
-		using RegisterType = uint8_t;
-		using BigRegisterType = uint16_t;
 	private:
 		Bus* bus_;
 		bool ime_ = false;
@@ -143,15 +140,13 @@ namespace TKPEmu::Gameboy::Devices {
 		BigRegisterType PC, SP;
 
 		// Memory mapped registers, they are a reference to a position in memory
-		RegisterType &IF, &IE, &DIVIDER, &TIMA, &TMA, &TAC, &LY, &JOYP;
+		RegisterType &IF, &IE, &LY, &JOYP;
 
 		const int ClockSpeed = 4194304;
 		const int MaxCycles = ClockSpeed / 60;
-		int Oscillator = 0;
-		int TimerCounter = ClockSpeed / tac_index_;
 		int TClock = 0;
 		unsigned long TotalClocks = 0;
-		void Reset();
+		void Reset(bool skip);
 		int Update();
 	};
 }
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 9dd6e2e21993943e98d48995a236c03301478e0d..9de8b276974e4a4eb356050545383aa7651ba123 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -1,5 +1,4 @@
 #include "gb_disassembler.h"
-
 namespace TKPEmu::Applications {
     GameboyDisassembler::GameboyDisassembler(bool* rom_loaded) : BaseDisassembler(rom_loaded) {
         sel_map_.resize(0x10000);
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index 5b84b56b310b6995fd78f01d66c34a14e06d4830..d533817defb02a338966615aa775e94538624017 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -14,9 +14,9 @@ namespace TKPEmu::Gameboy::Devices {
 		IF(bus->GetReference(0xFF0F))
 	{}
 
-	void PPU::Update(uint8_t tTemp) {
+	void PPU::Update(uint8_t cycles) {
 		IF &= 0b11111110;
-		clock_ += tTemp;
+		clock_ += cycles;
 		if (LCDC & LCDCFlag::LCD_ENABLE) {
 			if (clock_ >= clock_target_) {
 				if (LY == 153) {
diff --git a/TKPEmu/gb_tkp/gb_ppu.h b/TKPEmu/gb_tkp/gb_ppu.h
index 35a73bf0d8f0cec2304db91ae8000c2c3321bed3..e4f415ad664cc5df0cd3022c6679c450982b46d9 100644
--- a/TKPEmu/gb_tkp/gb_ppu.h
+++ b/TKPEmu/gb_tkp/gb_ppu.h
@@ -3,20 +3,17 @@
 #define TKP_GB_PPU_H
 #include "gb_bus.h"
 #include "../include/TKPImage.h"
+#include "gb_addresses.h"
 #include <mutex>
 #include <array>
 namespace TKPEmu::Gameboy::Devices {
 	constexpr int FRAME_CYCLES = 70224;
 	class PPU {
 	private:
-		using IFInterrupt = Bus::IFInterrupt;
-		using LCDCFlag = Bus::LCDCFlag;
-		using STATFlag = Bus::STATFlag;
 		using TKPImage = TKPEmu::Tools::TKPImage;
-		using Pixel = TKPEmu::Gameboy::Devices::Bus::Pixel;
 	public:
 		PPU(Bus* bus, std::mutex* draw_mutex);
-		void Update(uint8_t tTemp);
+		void Update(uint8_t cycles);
 		void Reset();
 		float* GetScreenData();
 	private:
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..42c2780966e1f696d21113749841838ef22d5272
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -0,0 +1,38 @@
+#include "gb_timer.h"
+namespace TKPEmu::Gameboy::Devices {
+    Timer::Timer(Bus* bus) : 
+        bus_(bus), 
+        DIV(bus->GetReference(addr_div)),
+        TIMA(bus_->GetReference(addr_tim)),
+        TMA(bus_->GetReference(addr_tma)),
+        TAC(bus_->GetReference(addr_tac))
+    {}
+    void Timer::Reset() {
+        DIV = 0;
+        TAC = 0;
+        TIMA = 0;
+        TMA = 0;
+        oscillator_ = 0;
+        timer_counter_ = 0;
+    }
+    bool Timer::Update(uint8_t cycles) {
+        oscillator_ += cycles;
+        DIV += oscillator_ >> 8;
+        oscillator_ &= 0xFF;
+        if (TAC & 0b100 == 0) {
+            return false;
+        }
+        timer_counter_ += cycles;
+        auto interr_cycles = interr_times_[TAC & 0b11];
+        if (timer_counter_ >= interr_cycles) {
+            timer_counter_ -= interr_cycles;
+            TIMA += 1;
+            // If TIMA is 0 after incrementing, it means it has overflown
+            if (TIMA == 0) {
+                TIMA = TMA;
+                return true;
+            }
+        }
+        return false;
+	}
+}
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_timer.h b/TKPEmu/gb_tkp/gb_timer.h
new file mode 100644
index 0000000000000000000000000000000000000000..7c31c34197c1fb50b0ba581d4eaf35ad96159414
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_timer.h
@@ -0,0 +1,19 @@
+#pragma once
+#ifndef TKP_GB_TIMER_H
+#define TKP_GB_TIMER_H
+#include "gb_bus.h"
+#include "gb_addresses.h"
+namespace TKPEmu::Gameboy::Devices {
+    class Timer {
+    public:
+        Timer(Bus* bus);
+        void Reset();
+        bool Update(uint8_t cycles);
+    private:
+        Bus* bus_;
+        RegisterType &DIV, &TIMA, &TAC, &TMA;
+        int oscillator_, timer_counter_;
+        const std::array<const unsigned, 4> interr_times_ { 1024, 16, 64, 256 };
+    };
+}
+#endif
\ No newline at end of file

From d4a9757228080b81750b93edfd8081488b7ccb0a Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 23 Nov 2021 20:34:11 +0200
Subject: [PATCH] added todo

---
 TKPEmu/gb_tkp/gb_disassembler.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index d478cd5cc9675c61d0d9aefed9ca8b7a64e1fd73..f1d762dc46149f85f0826ee4a163951850fdadff 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -5,6 +5,7 @@
 #include <algorithm>
 #include <unordered_map>
 // TODO: task.h is deprecated warning
+// TODO: enter press on breakpoint adds breakpoint
 #include <execution>
 #include "../include/base_disassembler.h"
 #include "gb_breakpoint.h"

From bd0fe3b424ca406b54211712265a8c56952a1c79 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 23 Nov 2021 23:03:51 +0200
Subject: [PATCH] timer changes reverted

---
 TKPEmu/gb_tkp/gameboy.cpp  |  5 +--
 TKPEmu/gb_tkp/gb_cpu.h     |  2 +-
 TKPEmu/gb_tkp/gb_ppu.cpp   |  7 ++--
 TKPEmu/gb_tkp/gb_ppu.h     |  1 +
 TKPEmu/gb_tkp/gb_timer.cpp | 95 ++++++++++++++++++++++++++++++++++++----------
 TKPEmu/gb_tkp/gb_timer.h   |  8 ++--
 6 files changed, 87 insertions(+), 31 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index ba417d66f79d116d07dc3ed9bbdea12f79ec098c..62163f8d421ede4092001a1c5ad5248b46f3e3bc 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -172,10 +172,9 @@ namespace TKPEmu::Gameboy {
 		if (cpu_.PC == 0x100) {
 			bus_.BiosEnabled = false;
 		}
+		uint8_t old_if = interrupt_flag_;
 		int clk = cpu_.Update();
-		if (timer_.Update(clk)) {
-			interrupt_flag_ |= IFInterrupt::TIMER;
-		}
+		timer_.Update(clk, old_if);
 		ppu_.Update(clk);
 		if (cpu_.TClock >= cpu_.MaxCycles) {
 			cpu_.TClock = 0;
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 0cef6d3c1db61ae198f3ff3c0c2c2c7aeec17759..b79f6cbc59efd49638b5f864bde8ba377c4b7503 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -20,7 +20,6 @@ namespace TKPEmu::Gameboy::Devices {
 		int old_tac_ = 0;
 		int tac_index_ = 0x1000;
 		int tima_overflow_ = false;
-		bool halt_ = false;
 		bool stop_ = false;
 
 		// Instruction functions
@@ -92,6 +91,7 @@ namespace TKPEmu::Gameboy::Devices {
 
 	public:
 		CPU(Bus* bus);
+		bool halt_ = false;
 		struct Instruction {
 			std::string name;
 			void(CPU::* op)() = nullptr;
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index d533817defb02a338966615aa775e94538624017..ae7dcded6112c99315c1faf305872c355ae319b6 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -13,7 +13,6 @@ namespace TKPEmu::Gameboy::Devices {
 		WX(bus->GetReference(0xFF4B)),
 		IF(bus->GetReference(0xFF0F))
 	{}
-
 	void PPU::Update(uint8_t cycles) {
 		IF &= 0b11111110;
 		clock_ += cycles;
@@ -26,7 +25,6 @@ namespace TKPEmu::Gameboy::Devices {
 					clock_target_ = FRAME_CYCLES;
 				}
 				IF |= set_mode(next_stat_mode);
-				
 				if (int mode = get_mode(); mode == 2) {
 					clock_target_ += 80;
 					next_stat_mode = 3;
@@ -73,11 +71,12 @@ namespace TKPEmu::Gameboy::Devices {
 		clock_ = 0;
 		clock_target_ = 0;
 	}
-	
+    int PPU::CalcCycles() {
+		return clock_target_ - clock_;
+	}
 	float* PPU::GetScreenData() {
 		return &screen_color_data_[0];
 	}
-
 	int PPU::set_mode(int mode) {
 		if (get_mode() == mode) {
 			return 0;
diff --git a/TKPEmu/gb_tkp/gb_ppu.h b/TKPEmu/gb_tkp/gb_ppu.h
index e4f415ad664cc5df0cd3022c6679c450982b46d9..ae6fab20de30a138af0b450e246063e582381cc3 100644
--- a/TKPEmu/gb_tkp/gb_ppu.h
+++ b/TKPEmu/gb_tkp/gb_ppu.h
@@ -15,6 +15,7 @@ namespace TKPEmu::Gameboy::Devices {
 		PPU(Bus* bus, std::mutex* draw_mutex);
 		void Update(uint8_t cycles);
 		void Reset();
+        int CalcCycles();
 		float* GetScreenData();
 	private:
 		Bus* bus_;
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 42c2780966e1f696d21113749841838ef22d5272..dbaf615d952cb118e22070c7aba80edf6e1aa42d 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -5,7 +5,8 @@ namespace TKPEmu::Gameboy::Devices {
         DIV(bus->GetReference(addr_div)),
         TIMA(bus_->GetReference(addr_tim)),
         TMA(bus_->GetReference(addr_tma)),
-        TAC(bus_->GetReference(addr_tac))
+        TAC(bus_->GetReference(addr_tac)),
+        IF(bus_->GetReference(addr_ifl))
     {}
     void Timer::Reset() {
         DIV = 0;
@@ -15,24 +16,78 @@ namespace TKPEmu::Gameboy::Devices {
         oscillator_ = 0;
         timer_counter_ = 0;
     }
-    bool Timer::Update(uint8_t cycles) {
-        oscillator_ += cycles;
-        DIV += oscillator_ >> 8;
-        oscillator_ &= 0xFF;
-        if (TAC & 0b100 == 0) {
-            return false;
-        }
-        timer_counter_ += cycles;
-        auto interr_cycles = interr_times_[TAC & 0b11];
-        if (timer_counter_ >= interr_cycles) {
-            timer_counter_ -= interr_cycles;
-            TIMA += 1;
-            // If TIMA is 0 after incrementing, it means it has overflown
-            if (TIMA == 0) {
-                TIMA = TMA;
-                return true;
-            }
-        }
-        return false;
+    void Timer::Update(uint8_t cycles, uint8_t old_if) {
+        if (tima_overflow_) {
+			// TIMA might've changed in this strange cycle (see the comment below)
+			// If it changes in that cycle, it doesn't update to be equal to TMA
+			if (TIMA == 0) {
+				TIMA = TMA;
+				// If this isn't true, IF has changed during this instruction so the new value persists
+				if (IF == old_if) {
+					IF |= IFInterrupt::TIMER;
+				}
+			}
+			tima_overflow_ = false;
+		}
+        int freq = interr_times_[TAC & 0b11];
+		if (bus_->DIVReset) {
+			bus_->DIVReset = false;
+			if (div_reset_index_ >= freq / 2) {
+				TIMA++;
+			}
+			oscillator_ = 0;
+			timer_counter_ = 0;
+			div_reset_index_ = 0;
+		}
+		if (bus_->TACChanged) {
+			bus_->TACChanged = false;
+			uint8_t new_tac = TAC;
+			TAC = old_tac_;
+			int old_freq = interr_times_[TAC & 0b11];
+			TAC = new_tac;
+			if ((old_tac_ >> 2) & 1) {
+				// If old tac was enabled
+				// TODO: prettify timer after its fully implemented
+				if (!((new_tac >> 2) & 1)) {
+					if ((div_reset_index_ & (old_freq / 2)) != 0) {
+						TIMA++;
+					}
+				}
+				else {
+					if ((div_reset_index_ & (old_freq / 2)) != 0 && ((div_reset_index_ & (freq / 2)) == 0)) {
+						TIMA++;
+					}
+				}
+			}
+			old_tac_ = new_tac;
+		}
+		bool enabled = (TAC >> 2) & 0x1;
+		oscillator_ += cycles;
+		// Divider always equals the top 8 bits of the oscillator
+		DIV = oscillator_ >> 8;
+		if (div_reset_index_ != -1)
+			div_reset_index_ += cycles;
+		if (div_reset_index_ > freq) {
+			TIMA++;
+			div_reset_index_ = -1;
+		}
+		if (enabled) {
+			timer_counter_ += cycles;
+			while (timer_counter_ >= freq) {
+				timer_counter_ -= freq;
+				//timer_counter_ = get_clk_freq();
+				if (TIMA == 0xFF) {
+					/*TIMA = TMA;
+					IF |= 1 << 2;
+					halt_ = false;*/
+					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
+					TIMA = 0;
+					tima_overflow_ = true;
+				}
+				else {
+					TIMA++;
+				}
+			}
+		}
 	}
 }
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_timer.h b/TKPEmu/gb_tkp/gb_timer.h
index 7c31c34197c1fb50b0ba581d4eaf35ad96159414..0894e675efcff38c3fa2898d5c9a070932ec806b 100644
--- a/TKPEmu/gb_tkp/gb_timer.h
+++ b/TKPEmu/gb_tkp/gb_timer.h
@@ -8,11 +8,13 @@ namespace TKPEmu::Gameboy::Devices {
     public:
         Timer(Bus* bus);
         void Reset();
-        bool Update(uint8_t cycles);
+        void Update(uint8_t cycles, uint8_t old_if);
     private:
         Bus* bus_;
-        RegisterType &DIV, &TIMA, &TAC, &TMA;
-        int oscillator_, timer_counter_;
+        RegisterType &DIV, &TIMA, &TAC, &TMA, &IF;
+        // TODO: Reduce these temporaries to oscillator_ and timer_counter_ only
+        int oscillator_, timer_counter_, div_reset_index_, old_tac_;
+        bool tima_overflow_;
         const std::array<const unsigned, 4> interr_times_ { 1024, 16, 64, 256 };
     };
 }

From 94fc5734fca3477d6f76adb92bba118e492c73f5 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 25 Nov 2021 00:45:11 +0200
Subject: [PATCH] md5 impl added, cpu_instr fixed again

---
 TKPEmu/gb_tkp/gameboy.cpp  | 6 ++++--
 TKPEmu/gb_tkp/gameboy.h    | 2 +-
 TKPEmu/gb_tkp/gb_timer.cpp | 4 +++-
 TKPEmu/gb_tkp/gb_timer.h   | 2 +-
 4 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 62163f8d421ede4092001a1c5ad5248b46f3e3bc..329102afbb77c68081b00a5d460b36a16d48aa1a 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -174,7 +174,9 @@ namespace TKPEmu::Gameboy {
 		}
 		uint8_t old_if = interrupt_flag_;
 		int clk = cpu_.Update();
-		timer_.Update(clk, old_if);
+		if (timer_.Update(clk, old_if)) {
+			cpu_.halt_ = false;
+		}
 		ppu_.Update(clk);
 		if (cpu_.TClock >= cpu_.MaxCycles) {
 			cpu_.TClock = 0;
@@ -212,7 +214,7 @@ namespace TKPEmu::Gameboy {
 			bus_.ActionKeys = (1UL << index) | joy_action;
 		}
 	}
-	void Gameboy::LoadFromFile(std::string&& path) {
+	void Gameboy::load_file(std::string path) {
 		bus_.LoadCartridge(std::forward<std::string>(path));
 	}
 	DisInstr Gameboy::GetInstruction(uint16_t address) {
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 8b89f3cc647c2d615cfea049a356bb335f65775e..0535bdb7b8aa472b95f412e98a2f10d77b7e88cb 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -28,7 +28,6 @@ namespace TKPEmu::Gameboy {
 		~Gameboy();
 		void HandleKeyDown(SDL_Keycode key) override;
 		void HandleKeyUp(SDL_Keycode key) override;
-		void LoadFromFile(std::string&& path) override;
 		float* GetScreenData() override;
 		void SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr);
         DisInstr GetInstruction(uint16_t address);
@@ -57,6 +56,7 @@ namespace TKPEmu::Gameboy {
 		void start_debug() override;
 		void reset_normal() override;
 		void reset_skip() override;
+		void load_file(std::string path) override;
 		void update() override;
 		std::string print() const override;
 		void limit_fps();
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index dbaf615d952cb118e22070c7aba80edf6e1aa42d..5f0ce857f862e901ebf9f2a3df91fb519b227fa0 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -16,7 +16,7 @@ namespace TKPEmu::Gameboy::Devices {
         oscillator_ = 0;
         timer_counter_ = 0;
     }
-    void Timer::Update(uint8_t cycles, uint8_t old_if) {
+    bool Timer::Update(uint8_t cycles, uint8_t old_if) {
         if (tima_overflow_) {
 			// TIMA might've changed in this strange cycle (see the comment below)
 			// If it changes in that cycle, it doesn't update to be equal to TMA
@@ -83,11 +83,13 @@ namespace TKPEmu::Gameboy::Devices {
 					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
 					TIMA = 0;
 					tima_overflow_ = true;
+					return true;
 				}
 				else {
 					TIMA++;
 				}
 			}
 		}
+		return false;
 	}
 }
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_timer.h b/TKPEmu/gb_tkp/gb_timer.h
index 0894e675efcff38c3fa2898d5c9a070932ec806b..00818f4ddc129b1bd15cb0aa04fc4831415ac5cb 100644
--- a/TKPEmu/gb_tkp/gb_timer.h
+++ b/TKPEmu/gb_tkp/gb_timer.h
@@ -8,7 +8,7 @@ namespace TKPEmu::Gameboy::Devices {
     public:
         Timer(Bus* bus);
         void Reset();
-        void Update(uint8_t cycles, uint8_t old_if);
+        bool Update(uint8_t cycles, uint8_t old_if);
     private:
         Bus* bus_;
         RegisterType &DIV, &TIMA, &TAC, &TMA, &IF;

From baad5bd65e1d411c781d70a2ae5eaf6b6e68eca4 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 25 Nov 2021 00:57:44 +0200
Subject: [PATCH] added PassedTestMap to gb_addresses.h (hash map)

---
 TKPEmu/gb_tkp/gameboy.cpp    |  2 +-
 TKPEmu/gb_tkp/gameboy.h      |  4 ++--
 TKPEmu/gb_tkp/gb_addresses.h | 14 ++++++++++++++
 3 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 329102afbb77c68081b00a5d460b36a16d48aa1a..e729504a376281d8113a26eba9bf9a0fb1fb20cc 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -288,7 +288,7 @@ namespace TKPEmu::Gameboy {
 		return cpu_.Instructions[opc].name;
 	}
 
-	GameboyPalettes& Gameboy::GetPalette() {
+	Gameboy::GameboyPalettes& Gameboy::GetPalette() {
 		return bus_.Palette;
 	}
 }
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 0535bdb7b8aa472b95f412e98a2f10d77b7e88cb..e4cdf8f2e2f0620a116ac572f294d5128e324137 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -12,10 +12,10 @@
 #include "gb_bus.h"
 #include "gb_timer.h"
 namespace TKPEmu::Gameboy {
-	using GameboyPalettes = std::array<std::array<float, 3>,4>;
-	using GameboyKeys = std::array<SDL_Keycode, 4>;
 	class Gameboy : public Emulator {
 	private:
+		using GameboyPalettes = std::array<std::array<float, 3>,4>;
+		using GameboyKeys = std::array<SDL_Keycode, 4>;
 		using CPU = TKPEmu::Gameboy::Devices::CPU;
 		using PPU = TKPEmu::Gameboy::Devices::PPU;
 		using Bus = TKPEmu::Gameboy::Devices::Bus;
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 856004005f5f253b9d4a0b4cc35c017a0ea7d675..14d44e0caa4cc7f10e2b903b90d35cdce27460ad 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -39,6 +39,20 @@ enum IFInterrupt {
     SERIAL = 1 << 3,
     JOYPAD = 1 << 4
 };
+// Used in the map below, to compare rom hashes with expected results after
+// a hardcoded number of clocks
+using Hash = std::string;
+struct ExpectedResult {
+    unsigned long long Clocks;
+    // Represents the hash of the screenshot taken after Clocks
+    Hash ExpectedHash;
+};
+// This map helps with quality assurance, we can check multiple test roms
+// at once and compare their finished hashes with these known good results
+std::unordered_map<Hash, ExpectedResult> PassedTestMap {
+    // cpu_instrs.gb by blargg
+    { "662f04537286d13ee55a6df9de4dce24", { 0, "error-hash" } },
+};
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::A, LogType::B, LogType::C, LogType::D,
     LogType::E, LogType::F, LogType::H, LogType::L,

From c89a9c3fcc06a539adc3ea32a1ebb7b8ab4b0a54 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 25 Nov 2021 22:02:21 +0200
Subject: [PATCH] added fast mode

---
 TKPEmu/gb_tkp/gameboy.cpp    | 12 ------------
 TKPEmu/gb_tkp/gameboy.h      |  4 ----
 TKPEmu/gb_tkp/gb_addresses.h |  2 +-
 3 files changed, 1 insertion(+), 17 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index e729504a376281d8113a26eba9bf9a0fb1fb20cc..1892cb9070cc476d6e1fb1185792ddbf3dcb8e42 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -3,18 +3,6 @@
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
 namespace TKPEmu::Gameboy {
-	void Gameboy::limit_fps() {
-		// TODO: speedhack that sleeps for less time
-		a = std::chrono::system_clock::now();
-		std::chrono::duration<double, std::milli> work_time = a - b;
-		if (work_time.count() < sleep_time_) {
-			std::chrono::duration<double, std::milli> delta_ms(sleep_time_ - work_time.count());
-			auto delta_ms_duration = std::chrono::duration_cast<std::chrono::milliseconds>(delta_ms);
-			std::this_thread::sleep_for(std::chrono::milliseconds(delta_ms_duration.count()));
-		}
-		b = std::chrono::system_clock::now();
-		std::chrono::duration<double, std::milli> sleep_time = b - a;
-	}
 	Gameboy::Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys) :
 		bus_(Instructions),
 		cpu_(&bus_),
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index e4cdf8f2e2f0620a116ac572f294d5128e324137..64938ad813f00bc0e00b8c701a4a21ce26d7744c 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -47,10 +47,7 @@ namespace TKPEmu::Gameboy {
 		GameboyKeys& direction_keys_;
 		GameboyKeys& action_keys_;
 		uint8_t& joypad_, &interrupt_flag_;
-		std::chrono::system_clock::time_point a = std::chrono::system_clock::now();
-		std::chrono::system_clock::time_point b = std::chrono::system_clock::now();
 		std::unique_ptr<std::vector<LogType>> log_types_ptr_;
-		float sleep_time_ = 16.75f;
 		void v_log_state() override;
 		void start_normal() override;
 		void start_debug() override;
@@ -59,7 +56,6 @@ namespace TKPEmu::Gameboy {
 		void load_file(std::string path) override;
 		void update() override;
 		std::string print() const override;
-		void limit_fps();
 	};
 }
 #endif
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 14d44e0caa4cc7f10e2b903b90d35cdce27460ad..a42c0485f264fbe853354d588055e18e15c54c46 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -49,7 +49,7 @@ struct ExpectedResult {
 };
 // This map helps with quality assurance, we can check multiple test roms
 // at once and compare their finished hashes with these known good results
-std::unordered_map<Hash, ExpectedResult> PassedTestMap {
+const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
     // cpu_instrs.gb by blargg
     { "662f04537286d13ee55a6df9de4dce24", { 0, "error-hash" } },
 };

From c886022285f8c6af336be291313d0bed814f59c0 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 27 Nov 2021 01:00:39 +0200
Subject: [PATCH] generalization changes 1

---
 TKPEmu/gb_tkp/gb_tracelogger.cpp | 79 ++++++++++++++++++++++++++++++++++++++++
 TKPEmu/gb_tkp/gb_tracelogger.h   | 13 +++++--
 2 files changed, 88 insertions(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index f86bf36e8b9b3632926c4778a0d9d7f37e7f9641..9c769ae0814e017ea6376eebc2a0a2d50c143b93 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -1,8 +1,71 @@
+#include <filesystem>
+#include <iostream>
 #include "gb_tracelogger.h"
 #include "gb_addresses.h"
 #include "../lib/imgui.h"
+#include "../lib/imgui_stdlib.h"
 namespace TKPEmu::Applications {
+	void GameboyTracelogger::GameboyTracelogger(std::string menu_title, std::string window_title)
+		: IMApplication(menu_title, window_title)
+	{}
 	void GameboyTracelogger::v_draw() {
+        static std::string path_buf = std::filesystem::current_path();
+        static bool path_changed = false;
+        static bool file_exists = false;
+        static bool overwrite = false;
+        if (ImGui::InputText("##path", &path_buf, ImGuiInputTextFlags_EnterReturnsTrue)) {
+            ready_to_log_ = false;
+            path_changed = true;
+            overwrite = false;
+        }
+        ImGui::SameLine();
+        if (ImGui::Button("Set", ImVec2(ImGui::GetContentRegionAvail().x * 0.35f, 0.0f))) {
+            ready_to_log_ = false;
+            path_changed = true;
+            overwrite = false;
+        }
+        if (path_changed) {
+            path_changed = false;
+            if (std::filesystem::is_directory(path_buf)) {
+                std::cout << "Error: Path is directory" << std::endl;
+            } else if (!overwrite && std::filesystem::exists(path_buf)) {
+                file_exists = true;
+                ImGui::OpenPopup("Overwrite?");
+            } else {
+                ready_to_log_ = true;
+                log_path_ = path_buf;
+            }
+        }
+        if (!ready_to_log_) {
+            // This push makes the button seem disabled
+            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.6f);
+            ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+        }
+        if (!is_logging_) {
+            if (ImGui::Button("Start logging")) {
+                if (emulator_ != nullptr) {
+                    set_logtypes();
+                    emulator_->StartLogging(log_path_);
+                    is_logging_ = true;
+                } else {
+                    std::cerr << "Error: Emulator is nullptr" << std::endl;
+                }
+            }
+        } else {
+            if (ImGui::Button("Stop logging")) {
+                if (emulator_ != nullptr) {
+                    emulator_->StopLogging();
+                    is_logging_ = false;
+                } else {
+                    std::cerr << "Error: Emulator is nullptr" << std::endl;
+                }
+            }
+        }
+        if (!ready_to_log_) {
+            // Pop disabled
+            ImGui::PopItemFlag();
+            ImGui::PopStyleVar();
+        }
 		ImGui::NewLine();
 		ImGui::TextUnformatted("Memory to log:");
 		ImGui::Separator();
@@ -12,6 +75,22 @@ namespace TKPEmu::Applications {
 				ImGui::SameLine();
 			}
 		}
+        ImVec2 center = ImGui::GetMainViewport()->GetCenter();
+        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+        ImGui::SetNextWindowSize(ImVec2(350, 75));
+        if (ImGui::BeginPopupModal("Overwrite?", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+            ImGui::TextUnformatted("This file already exists. Overwrite?");
+            if (ImGui::Button("Yes")) {
+                overwrite = true;
+                path_changed = true;
+                ImGui::CloseCurrentPopup();
+            }
+            ImGui::SameLine();
+            if (ImGui::Button("No")) {
+                ImGui::CloseCurrentPopup();
+            }
+            ImGui::EndPopup();
+        }
 	}
 	void GameboyTracelogger::set_logtypes() {
 		std::unique_ptr<std::vector<LogType>> ptr = std::make_unique<std::vector<LogType>>();
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.h b/TKPEmu/gb_tkp/gb_tracelogger.h
index 6864ff95dae8b8be501b9902ea50f7da78eccf2a..2157506f7bdd59137e2581cedde735c168b411d7 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.h
+++ b/TKPEmu/gb_tkp/gb_tracelogger.h
@@ -2,15 +2,20 @@
 #ifndef TKP_GB_TRACELOGGER_H
 #define TKP_GB_TRACELOGGER_H
 #include <array>
-#include "../include/base_tracelogger.h"
+#include "../include/base_application.h"
 #include "gameboy.h"
 namespace TKPEmu::Applications {
 	using Gameboy = TKPEmu::Gameboy::Gameboy;
-	class GameboyTracelogger : public BaseTracelogger {
+	class GameboyTracelogger : public IMApplication {
+	public:
+		GameboyTracelogger(std::string menu_title, std::string window_title);
 	private:
-		void v_draw() override;
-		void set_logtypes() override;
 		std::array<bool, LogTypeSize> available_types_{};
+		std::string log_path_;
+        bool ready_to_log_ = false;
+        bool is_logging_ = false;
+		void v_draw() override;
+		void set_logtypes();
 	};
 }
 #endif

From e7ea38b160bd10f0b0a8dc5a7f720dd2c253bb0a Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 27 Nov 2021 02:35:44 +0200
Subject: [PATCH] applications fully generalized

---
 TKPEmu/gb_tkp/gb_cartridge.cpp    |  1 +
 TKPEmu/gb_tkp/gb_disassembler.cpp | 31 +++++++++++++++++++++++--------
 TKPEmu/gb_tkp/gb_disassembler.h   | 20 ++++++++++++--------
 TKPEmu/gb_tkp/gb_tracelogger.cpp  | 22 ++++++++++++++--------
 TKPEmu/gb_tkp/gb_tracelogger.h    |  2 ++
 5 files changed, 52 insertions(+), 24 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 53920f8a2067b63636c8e3882cbac57eb2c28663..3ea653c870cbd84f80baa70deea700551eac382e 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -43,6 +43,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 
 	// Returns the number of 8KB RAM banks
+	// TODO: constexpr, return from constexpr array
 	int Cartridge::GetRamSize() {
 		switch (header_.ramSize) {
 			case 0: return 0;
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 9de8b276974e4a4eb356050545383aa7651ba123..1d4a3759eda6f893108d30c09276148b57b00c61 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -1,22 +1,37 @@
 #include "gb_disassembler.h"
 namespace TKPEmu::Applications {
-    GameboyDisassembler::GameboyDisassembler(bool* rom_loaded) : BaseDisassembler(rom_loaded) {
+    GameboyDisassembler::GameboyDisassembler(std::string menu_title, std::string window_title) : IMApplication(menu_title, window_title) {
         sel_map_.resize(0x10000);
     };
-    void GameboyDisassembler::Focus(int item) {
+    void GameboyDisassembler::focus(int item) {
         ImGuiContext& g = *ImGui::GetCurrentContext();
         ImGuiWindow* window = g.CurrentWindow;
         // TODO: find a way to make item_height not hard coded
         static const int item_height = 17;
         window->Scroll.y = IM_FLOOR(item_height * item);
     }
+    void GameboyDisassembler::HandleShortcut(const TKPShortcut& shortcut) {
+        switch(shortcut) {
+            case TKPShortcut::F7: {
+                if (emulator_->Paused) {
+                    emulator_->Step = true;
+                    emulator_->Step.notify_all();
+                }
+                break;
+            }
+            case TKPShortcut::CTRL_F: {
+                popup_goto = true;
+                break;
+            }
+        }
+    }
     void GameboyDisassembler::v_draw() {
         Gameboy* gameboy = static_cast<Gameboy*>(emulator_);
         bool bp_add_popup = false;
         int goto_pc = -1;
         if (ImGui::BeginMenuBar()) {
             if (ImGui::BeginMenu("Emulation")) {
-                DrawMenuEmulation(gameboy, rom_loaded_);
+                DrawMenuEmulation(gameboy);
             }
             if (ImGui::BeginMenu("Navigation")) {
                 if (ImGui::MenuItem("Step", "F7", false, gameboy->Paused.load())) {
@@ -25,13 +40,13 @@ namespace TKPEmu::Applications {
                 }
                 if (ImGui::MenuItem("Goto PC")) {
                     // TODO: if PC not found, go to nearest close to that value
-                    OpenGotoPopup = true;
+                    popup_goto = true;
                 }
                 ImGui::EndMenu();
             }
             ImGui::EndMenuBar();
         }
-        if (OpenGotoPopup) {
+        if (popup_goto) {
             ImGui::OpenPopup("Goto Program Code");
         }
         ImVec2 center = ImGui::GetMainViewport()->GetCenter();
@@ -43,10 +58,10 @@ namespace TKPEmu::Applications {
             constexpr size_t buf_size = 4 + 1;
             static char buf[buf_size] = "";
             bool close = false;
-            if (OpenGotoPopup) {
+            if (popup_goto) {
                 if (!ImGui::IsAnyItemActive() && !ImGui::IsMouseClicked(0))
                     ImGui::SetKeyboardFocusHere(0);
-                OpenGotoPopup = false;
+                popup_goto = false;
             }
             if (ImGui::InputText("hexadecimal", buf, buf_size, 
                     ImGuiInputTextFlags_CharsHexadecimal |
@@ -180,7 +195,7 @@ namespace TKPEmu::Applications {
                     gameboy->InstructionBreak.store(-1);
                 }
                 if (goto_pc != -1) {
-                    Focus(goto_pc);
+                    focus(goto_pc);
                 }
                 ImGui::EndTable();
             }
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index f1d762dc46149f85f0826ee4a163951850fdadff..f419678f0fd45a7d74cba46f2a597ffd7a5b7f68 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -7,24 +7,28 @@
 // TODO: task.h is deprecated warning
 // TODO: enter press on breakpoint adds breakpoint
 #include <execution>
-#include "../include/base_disassembler.h"
+#include "../include/base_application.h"
 #include "gb_breakpoint.h"
 #include "gameboy.h"
 namespace TKPEmu::Applications {
-    using Gameboy = TKPEmu::Gameboy::Gameboy;
-    using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
-    using GBSelectionMap = std::vector<bool>;
-    class GameboyDisassembler : public BaseDisassembler {
+    class GameboyDisassembler : public IMApplication {
+    private:
+        using Gameboy = TKPEmu::Gameboy::Gameboy;
+        using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
+        using GBSelectionMap = std::vector<bool>;
     public:
-        GameboyDisassembler(bool* rom_loaded);
-        void Focus(int item);
-        void v_draw() override;
+        GameboyDisassembler(std::string menu_title, std::string window_title);
+        void HandleShortcut(const TKPShortcut& shortcut) override;
     private:
         GameboyBreakpoint debug_rvalues_;
         GBSelectionMap sel_map_{};
         uint8_t* LY_ = nullptr;
         bool clear_all_flag = false;
+        bool popup_goto = false;
         int selected_bp = -1;
+        void v_draw() override;
+        void focus(int item);
+
         template<typename T>
         void breakpoint_register_checkbox(const char* checkbox_l, T& value, bool& is_used, ImGuiDataType type = ImGuiDataType_U8) {
             ImGui::Checkbox(checkbox_l, &is_used);
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index 9c769ae0814e017ea6376eebc2a0a2d50c143b93..388ba0e0e8d94ef1703f5636573c7ecf326c0f3e 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -3,17 +3,23 @@
 #include "gb_tracelogger.h"
 #include "gb_addresses.h"
 #include "../lib/imgui.h"
-#include "../lib/imgui_stdlib.h"
+
 namespace TKPEmu::Applications {
-	void GameboyTracelogger::GameboyTracelogger(std::string menu_title, std::string window_title)
+	GameboyTracelogger::GameboyTracelogger(std::string menu_title, std::string window_title)
 		: IMApplication(menu_title, window_title)
-	{}
+	{
+        std::string path = std::filesystem::current_path();
+        if (path.length() < PATH_MAX) {
+            strncpy(path_buf_, path.data(), PATH_MAX);
+        } else {
+            std::cerr << "Error: Executable path too long" << std::endl;
+        }
+    }
 	void GameboyTracelogger::v_draw() {
-        static std::string path_buf = std::filesystem::current_path();
         static bool path_changed = false;
         static bool file_exists = false;
         static bool overwrite = false;
-        if (ImGui::InputText("##path", &path_buf, ImGuiInputTextFlags_EnterReturnsTrue)) {
+        if (ImGui::InputText("##path", &(path_buf_[0]), PATH_MAX, ImGuiInputTextFlags_EnterReturnsTrue)) {
             ready_to_log_ = false;
             path_changed = true;
             overwrite = false;
@@ -26,14 +32,14 @@ namespace TKPEmu::Applications {
         }
         if (path_changed) {
             path_changed = false;
-            if (std::filesystem::is_directory(path_buf)) {
+            if (std::filesystem::is_directory(path_buf_)) {
                 std::cout << "Error: Path is directory" << std::endl;
-            } else if (!overwrite && std::filesystem::exists(path_buf)) {
+            } else if (!overwrite && std::filesystem::exists(path_buf_)) {
                 file_exists = true;
                 ImGui::OpenPopup("Overwrite?");
             } else {
                 ready_to_log_ = true;
-                log_path_ = path_buf;
+                log_path_ = path_buf_;
             }
         }
         if (!ready_to_log_) {
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.h b/TKPEmu/gb_tkp/gb_tracelogger.h
index 2157506f7bdd59137e2581cedde735c168b411d7..c507ce909bf5c4091daca855408798ad78013b1c 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.h
+++ b/TKPEmu/gb_tkp/gb_tracelogger.h
@@ -4,6 +4,7 @@
 #include <array>
 #include "../include/base_application.h"
 #include "gameboy.h"
+#define PATH_MAX 4096
 namespace TKPEmu::Applications {
 	using Gameboy = TKPEmu::Gameboy::Gameboy;
 	class GameboyTracelogger : public IMApplication {
@@ -12,6 +13,7 @@ namespace TKPEmu::Applications {
 	private:
 		std::array<bool, LogTypeSize> available_types_{};
 		std::string log_path_;
+		char path_buf_[PATH_MAX];
         bool ready_to_log_ = false;
         bool is_logging_ = false;
 		void v_draw() override;

From 2ca503e789b02ce1e34bdf869998f6d5b59871da Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 29 Nov 2021 19:49:11 +0200
Subject: [PATCH] path to console 1

---
 TKPEmu/gb_tkp/gameboy.cpp | 63 +++++++++++++++++++++++++----------------------
 TKPEmu/gb_tkp/gameboy.h   |  9 ++++---
 2 files changed, 40 insertions(+), 32 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 1892cb9070cc476d6e1fb1185792ddbf3dcb8e42..5e95a01fb6550918d01a328d60efca4a58e8d92f 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -3,39 +3,21 @@
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
 namespace TKPEmu::Gameboy {
-	Gameboy::Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys) :
+	Gameboy::Gameboy() : 
 		bus_(Instructions),
 		cpu_(&bus_),
 		ppu_(&bus_, &DrawMutex),
 		timer_(&bus_),
-		direction_keys_(direction_keys),
-		action_keys_(action_keys),
 		joypad_(bus_.GetReference(addr_joy)),
 		interrupt_flag_(bus_.GetReference(addr_if))
 	{
-		GLuint image_texture;
-		glGenTextures(1, &image_texture);
-		glBindTexture(GL_TEXTURE_2D, image_texture);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		glBindTexture(GL_TEXTURE_2D, image_texture);
-		glTexImage2D(
-			GL_TEXTURE_2D,
-			0,
-			GL_RGBA,
-			160,
-			144,
-			0,
-			GL_RGBA,
-			GL_FLOAT,
-			NULL
-		);
-		glBindTexture(GL_TEXTURE_2D, 0);
-		EmulatorImage.texture = image_texture;
-		EmulatorImage.width = 160;
-		EmulatorImage.height = 144;
+		init_image();
+	}
+	Gameboy::Gameboy(GameboyKeys dirkeys, GameboyKeys actionkeys) :
+		Gameboy()
+	{
+		direction_keys_ = std::move(dirkeys);
+		action_keys_ = std::move(actionkeys);
 	}
 	Gameboy::~Gameboy() {
 		Stopped.store(true);
@@ -268,14 +250,37 @@ namespace TKPEmu::Gameboy {
 	void Gameboy::RemoveBreakpoint(int index) {
 		Breakpoints.erase(Breakpoints.begin() + index);
 	}
-	float* Gameboy::GetScreenData()
-	{
+	float* Gameboy::GetScreenData() {
 		return ppu_.GetScreenData();
 	}
 	const auto& Gameboy::GetOpcodeDescription(uint8_t opc) {
 		return cpu_.Instructions[opc].name;
 	}
-
+	void Gameboy::init_image() {
+		GLuint image_texture;
+		glGenTextures(1, &image_texture);
+		glBindTexture(GL_TEXTURE_2D, image_texture);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glBindTexture(GL_TEXTURE_2D, image_texture);
+		glTexImage2D(
+			GL_TEXTURE_2D,
+			0,
+			GL_RGBA,
+			160,
+			144,
+			0,
+			GL_RGBA,
+			GL_FLOAT,
+			NULL
+		);
+		glBindTexture(GL_TEXTURE_2D, 0);
+		EmulatorImage.texture = image_texture;
+		EmulatorImage.width = 160;
+		EmulatorImage.height = 144;
+	}
 	Gameboy::GameboyPalettes& Gameboy::GetPalette() {
 		return bus_.Palette;
 	}
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 64938ad813f00bc0e00b8c701a4a21ce26d7744c..d4443b8f7c771d825577063b599eae32b84a5b6b 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -24,7 +24,9 @@ namespace TKPEmu::Gameboy {
 		using DisInstr = TKPEmu::Tools::DisInstr;
 		using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
 	public:
-		Gameboy(GameboyKeys& direction_keys, GameboyKeys& action_keys);
+		// TODO: use unordered_map or map (key = sdl_key value = 1<<i <SDL_Keycode, int>)
+		Gameboy();
+		Gameboy(GameboyKeys dirkeys, GameboyKeys actionkeys);
 		~Gameboy();
 		void HandleKeyDown(SDL_Keycode key) override;
 		void HandleKeyUp(SDL_Keycode key) override;
@@ -44,8 +46,8 @@ namespace TKPEmu::Gameboy {
 		PPU ppu_;
 		Timer timer_;
 		Cartridge cartridge_;
-		GameboyKeys& direction_keys_;
-		GameboyKeys& action_keys_;
+		GameboyKeys direction_keys_;
+		GameboyKeys action_keys_;
 		uint8_t& joypad_, &interrupt_flag_;
 		std::unique_ptr<std::vector<LogType>> log_types_ptr_;
 		void v_log_state() override;
@@ -55,6 +57,7 @@ namespace TKPEmu::Gameboy {
 		void reset_skip() override;
 		void load_file(std::string path) override;
 		void update() override;
+		void init_image();
 		std::string print() const override;
 	};
 }

From b23c74cc5f6c7e2bc01dd24d4f33d4a790c3fbf5 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Wed, 1 Dec 2021 19:50:31 +0200
Subject: [PATCH] printing hash after every screenshot implemented

---
 TKPEmu/gb_tkp/gameboy.cpp |  4 ++++
 TKPEmu/gb_tkp/gameboy.h   |  1 +
 TKPEmu/gb_tkp/gb_bus.cpp  | 19 +++++++++++++++----
 TKPEmu/gb_tkp/gb_bus.h    |  3 ++-
 4 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 5e95a01fb6550918d01a328d60efca4a58e8d92f..0998ffcb6eadfcf0ae5b4215ca6f20152716ab57 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -2,6 +2,7 @@
 #include <atomic>
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
+#include "../lib/md5.h"
 namespace TKPEmu::Gameboy {
 	Gameboy::Gameboy() : 
 		bus_(Instructions),
@@ -26,6 +27,9 @@ namespace TKPEmu::Gameboy {
 	void Gameboy::SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr) {
 		log_types_ptr_ = std::move(types_ptr);
 	}
+	std::string Gameboy::GetScreenshotHash() {
+		return md5(bus_.GetVramDump());
+	}
 	void Gameboy::v_log_state() {
 		*ofstream_ptr_ << std::setfill('0');
 		bool first_type = true;
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index d4443b8f7c771d825577063b599eae32b84a5b6b..258d51b3743be3d4b4170adb39b24b44d2da008b 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -31,6 +31,7 @@ namespace TKPEmu::Gameboy {
 		void HandleKeyDown(SDL_Keycode key) override;
 		void HandleKeyUp(SDL_Keycode key) override;
 		float* GetScreenData() override;
+		std::string GetScreenshotHash() override;
 		void SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr);
         DisInstr GetInstruction(uint16_t address);
 		bool AddBreakpoint(GBBPArguments bp);
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 82adb9d10cffa89cf7b3ed3511c5701082cda92d..2fb03f87eccd42984bf462fceae3b76746e25a0d 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -1,4 +1,5 @@
 #include <iostream>
+#include <sstream>
 #include <iomanip>
 #include <algorithm>
 #include <bitset>
@@ -119,15 +120,25 @@ namespace TKPEmu::Gameboy::Devices {
 		uint8_t read = redirect_address(address);
 		return read;
 	}
-
 	uint16_t Bus::ReadL(uint16_t address) {
 		return Read(address) + (Read(address + 1) << 8);
 	}
-
 	uint8_t& Bus::GetReference(uint16_t address) {
 		return redirect_address(address);
 	}
-
+	std::string Bus::GetVramDump() {
+		std::stringstream s;
+		for (const auto& m : vram_) {
+			s << std::hex << std::setfill('0') << std::setw(2) << m;
+		}
+		for (const auto& m : OAM) {
+			s << std::hex << std::setfill('0') << std::setw(2) << m.flags;
+			s << std::hex << std::setfill('0') << std::setw(2) << m.tile_index;
+			s << std::hex << std::setfill('0') << std::setw(2) << m.x_pos;
+			s << std::hex << std::setfill('0') << std::setw(2) << m.y_pos;
+		}
+		return std::move(s.str());
+	}
 	void Bus::Write(uint16_t address, uint8_t data) {	
 		if (address <= 0x7FFF) {
 			if (address <= 0x1FFF) {
@@ -309,7 +320,7 @@ namespace TKPEmu::Gameboy::Devices {
 		BiosEnabled = true;
 	}
 
-	void Bus::LoadCartridge(std::string&& fileName) {
+	void Bus::LoadCartridge(std::string fileName) {
 		Reset();
 		cartridge_ = std::unique_ptr<Cartridge>(new Cartridge());
 		cartridge_->Load(fileName, rom_banks_, ram_banks_);
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 7b4e53251c201c7afd7799c1a92d7c3ec8fed2cb..abb85c97c7696f29e4cadcf98e4cf265efaa9523 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -77,7 +77,8 @@ namespace TKPEmu::Gameboy::Devices {
         void WriteL(uint16_t address, uint16_t data);
         void Reset();
         void SoftReset();
-        void LoadCartridge(std::string&& fileName);
+        void LoadCartridge(std::string fileName);
+        std::string GetVramDump();
         std::array<std::array<float, 3>, 4> Palette;
         std::array<uint8_t, 4> BGPalette{};
         std::array<uint8_t, 4> OBJ0Palette{};

From 3ad2819ad178e58fe506f2cb06885b237f93632e Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 4 Dec 2021 02:03:00 +0200
Subject: [PATCH] passing bank1, bank2, mode tests, not ramg test

---
 TKPEmu/gb_tkp/gb_addresses.h      |  7 ++++++-
 TKPEmu/gb_tkp/gb_bus.cpp          | 36 ++++++++++++++++++++++--------------
 TKPEmu/gb_tkp/gb_bus.h            |  1 +
 TKPEmu/gb_tkp/gb_disassembler.cpp |  2 +-
 4 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index a42c0485f264fbe853354d588055e18e15c54c46..84f96cf2c468a5fd49d6e39df278d4d239d63b57 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -50,8 +50,13 @@ struct ExpectedResult {
 // This map helps with quality assurance, we can check multiple test roms
 // at once and compare their finished hashes with these known good results
 const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
-    // cpu_instrs.gb by blargg
+    // cpu_instrs.gb
     { "662f04537286d13ee55a6df9de4dce24", { 0, "error-hash" } },
+
+    // /mbc1/bits_bank1.gb
+    { "31d2ad77d05566b1dcb92d7ff7232767", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    { "d7c8eb26b8c276f0d13e2a272a17c308", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    { "d807288f6cfe34225989dd0d9293043e", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::A, LogType::B, LogType::C, LogType::D,
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 2fb03f87eccd42984bf462fceae3b76746e25a0d..7e499147585983950b81bc29ce2f7fded8371242 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -10,6 +10,7 @@ namespace TKPEmu::Gameboy::Devices {
 	Bus::Bus(std::vector<DisInstr>& instrs) : instructions_(instrs) {}
 
 	uint8_t& Bus::redirect_address(uint16_t address) {
+		unused_mem_area_ = 1;
 		using CT = Cartridge::CartridgeType;
 		// Return address from ROM banks
 		// TODO: create better exceptions
@@ -54,10 +55,12 @@ namespace TKPEmu::Gameboy::Devices {
 					case CT::MBC1_RAM:
 					case CT::MBC1_RAM_BATTERY: {
 						if (address <= 0x3FFF) {
-							return (rom_banks_[0])[address % 0x4000];
+							auto sel = (banking_mode_ ? selected_rom_bank_ & 0b1100000 : 0) % cartridge_->GetRomSize();
+							return (rom_banks_[sel])[address % 0x4000];
 						}
 						else {
-							return (rom_banks_[selected_rom_bank_])[address % 0x4000];
+							auto sel = (banking_mode_ ? selected_rom_bank_ : selected_rom_bank_ & 0b11111) % cartridge_->GetRomSize();
+							return (rom_banks_[sel])[address % 0x4000];
 						}
 						break;
 					}
@@ -71,10 +74,15 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 			case 0xA000:
 			case 0xB000: {
-				if (cartridge_->GetRamSize() == 0)
-					return eram_default_[address % 0x2000];
-
-				return (ram_banks_[selected_ram_bank_])[address % 0x2000];
+				if (ram_enabled_) {
+					if (cartridge_->GetRamSize() == 0)
+						return eram_default_[address % 0x2000];
+					auto sel = (banking_mode_ ? selected_ram_bank_ : 0) % cartridge_->GetRamSize();
+					return (ram_banks_[sel])[address % 0x2000];
+				} else {
+					unused_mem_area_ = 1;
+					return unused_mem_area_;
+				}
 			}
 			case 0xC000:
 			case 0xD000: {
@@ -93,7 +101,6 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				else if (address <= 0xFEFF) {
 					// TODO: check if this is actually unused area
-					unused_mem_area_ = 1;
 					return unused_mem_area_;
 				}
 				else if (address <= 0xFFFF) {
@@ -144,7 +151,7 @@ namespace TKPEmu::Gameboy::Devices {
 			if (address <= 0x1FFF) {
 				// Any value "written" here with lower 4 bits == 0xA enables eram,
 				// other values disable eram
-				if ((data & 0xF) == 0xA) {
+				if (data == 0xA) {
 					ram_enabled_ = true;
 				}
 				else {
@@ -152,8 +159,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 			else if (address <= 0x3FFF) {
-				// Keep 3 highest bits
-				// TODO: this only happens on mbc1
+				// BANK register 1 (TODO: this doesnt happen on mbc0?)
 				selected_rom_bank_ &= 0b11100000;
 				selected_rom_bank_ |= data & 0b11111;
 				selected_rom_bank_ %= rom_banks_size_;
@@ -161,13 +167,15 @@ namespace TKPEmu::Gameboy::Devices {
 					selected_rom_bank_ = 1;
 			}
 			else if (address <= 0x5FFF) {
+				// BANK register 2
 				selected_rom_bank_ &= 0b11111;
-				selected_rom_bank_ |= (data << 5);
+				selected_rom_bank_ |= ((data & 0b11) << 5);
 				selected_rom_bank_ %= rom_banks_size_;
+				selected_ram_bank_ = data & 0b11;
 			}
-			else if (address <= 0x7FFF) {
-				// TODO: MBC1 1MB multi-carts might have different behavior, investigate
-				// This enables mbc1 1mb mode?
+			else {
+				// MODE register
+				banking_mode_ = data & 0b1;
 			}
 		}
 		else {
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index abb85c97c7696f29e4cadcf98e4cf265efaa9523..1d414964deb67759ea860a8bfe603de5b32d3179 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -19,6 +19,7 @@ namespace TKPEmu::Gameboy::Devices {
         uint8_t selected_ram_bank_ = 0;
         uint8_t selected_rom_bank_ = 1;
         uint8_t rom_banks_size_ = 2;
+        bool banking_mode_ = false;
         bool action_key_mode_ = false;
         uint8_t unused_mem_area_ = 0;
         std::vector<RamBank> ram_banks_;
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 1d4a3759eda6f893108d30c09276148b57b00c61..53f5448d1ffcd43ceef36b40dc1d45fc266ac1a2 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -26,7 +26,7 @@ namespace TKPEmu::Applications {
         }
     }
     void GameboyDisassembler::v_draw() {
-        Gameboy* gameboy = static_cast<Gameboy*>(emulator_);
+        static Gameboy* gameboy = static_cast<Gameboy*>(emulator_);
         bool bp_add_popup = false;
         int goto_pc = -1;
         if (ImGui::BeginMenuBar()) {

From 383009c1e8f66da9ed954637598934d237b9e2dc Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 5 Dec 2021 03:27:53 +0200
Subject: [PATCH] 4/8/16 passed, fail 1mb (multicart) and 2mb (???)

---
 TKPEmu/gb_tkp/gb_bus.cpp          | 13 +++++++------
 TKPEmu/gb_tkp/gb_disassembler.cpp |  5 ++++-
 TKPEmu/gb_tkp/gb_disassembler.h   |  2 +-
 3 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 7e499147585983950b81bc29ce2f7fded8371242..580892e1c05a55972171784a62dc0dcc107c6f24 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -10,7 +10,7 @@ namespace TKPEmu::Gameboy::Devices {
 	Bus::Bus(std::vector<DisInstr>& instrs) : instructions_(instrs) {}
 
 	uint8_t& Bus::redirect_address(uint16_t address) {
-		unused_mem_area_ = 1;
+		unused_mem_area_ = 0;
 		using CT = Cartridge::CartridgeType;
 		// Return address from ROM banks
 		// TODO: create better exceptions
@@ -59,7 +59,11 @@ namespace TKPEmu::Gameboy::Devices {
 							return (rom_banks_[sel])[address % 0x4000];
 						}
 						else {
-							auto sel = (banking_mode_ ? selected_rom_bank_ : selected_rom_bank_ & 0b11111) % cartridge_->GetRomSize();
+							auto sel = selected_rom_bank_ % cartridge_->GetRomSize();
+							if ((sel & 0b11111) == 0) {
+								// In 4000-7FFF, automatically maps to next addr if addr chosen is 00/20/40/60
+								sel += 1;
+							}
 							return (rom_banks_[sel])[address % 0x4000];
 						}
 						break;
@@ -80,7 +84,6 @@ namespace TKPEmu::Gameboy::Devices {
 					auto sel = (banking_mode_ ? selected_ram_bank_ : 0) % cartridge_->GetRamSize();
 					return (ram_banks_[sel])[address % 0x2000];
 				} else {
-					unused_mem_area_ = 1;
 					return unused_mem_area_;
 				}
 			}
@@ -160,11 +163,9 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 			else if (address <= 0x3FFF) {
 				// BANK register 1 (TODO: this doesnt happen on mbc0?)
-				selected_rom_bank_ &= 0b11100000;
+				selected_rom_bank_ &= 0b1100000;
 				selected_rom_bank_ |= data & 0b11111;
 				selected_rom_bank_ %= rom_banks_size_;
-				if (selected_rom_bank_ == 0)
-					selected_rom_bank_ = 1;
 			}
 			else if (address <= 0x5FFF) {
 				// BANK register 2
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 53f5448d1ffcd43ceef36b40dc1d45fc266ac1a2..8b9289796e0cc7a303e2dc1888781a6ab5a7f20b 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -2,6 +2,7 @@
 namespace TKPEmu::Applications {
     GameboyDisassembler::GameboyDisassembler(std::string menu_title, std::string window_title) : IMApplication(menu_title, window_title) {
         sel_map_.resize(0x10000);
+        window_flags_ = ImGuiWindowFlags_MenuBar;
     };
     void GameboyDisassembler::focus(int item) {
         ImGuiContext& g = *ImGui::GetCurrentContext();
@@ -10,17 +11,19 @@ namespace TKPEmu::Applications {
         static const int item_height = 17;
         window->Scroll.y = IM_FLOOR(item_height * item);
     }
-    void GameboyDisassembler::HandleShortcut(const TKPShortcut& shortcut) {
+    void GameboyDisassembler::HandleShortcut(TKPShortcut& shortcut) {
         switch(shortcut) {
             case TKPShortcut::F7: {
                 if (emulator_->Paused) {
                     emulator_->Step = true;
                     emulator_->Step.notify_all();
                 }
+                shortcut = TKPShortcut::NONE;
                 break;
             }
             case TKPShortcut::CTRL_F: {
                 popup_goto = true;
+                shortcut = TKPShortcut::NONE;
                 break;
             }
         }
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index f419678f0fd45a7d74cba46f2a597ffd7a5b7f68..808d3ce6bceac9b033e95d0774bfa1e9b91aa315 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -18,7 +18,7 @@ namespace TKPEmu::Applications {
         using GBSelectionMap = std::vector<bool>;
     public:
         GameboyDisassembler(std::string menu_title, std::string window_title);
-        void HandleShortcut(const TKPShortcut& shortcut) override;
+        void HandleShortcut(TKPShortcut& shortcut) override;
     private:
         GameboyBreakpoint debug_rvalues_;
         GBSelectionMap sel_map_{};

From ea369ac12119df4f258616df9618b83f4af8b23d Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 5 Dec 2021 20:03:04 +0200
Subject: [PATCH] mbc1 qol changes

---
 TKPEmu/gb_tkp/gb_bus.cpp       | 89 +++++++++++++++++++++++-------------------
 TKPEmu/gb_tkp/gb_bus.h         | 37 ++++++++++--------
 TKPEmu/gb_tkp/gb_cartridge.cpp |  5 ++-
 TKPEmu/gb_tkp/gb_cartridge.h   | 64 +++++++++++++++---------------
 4 files changed, 103 insertions(+), 92 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 580892e1c05a55972171784a62dc0dcc107c6f24..a4289afebc722f25a70ec54abdd5eee79ecd2c64 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -6,12 +6,49 @@
 #include "gb_bus.h"
 #include "gb_addresses.h"
 namespace TKPEmu::Gameboy::Devices {
-
 	Bus::Bus(std::vector<DisInstr>& instrs) : instructions_(instrs) {}
-
+	void Bus::handle_mbc(uint16_t address, uint8_t data) {
+		auto type = cartridge_->GetCartridgeType();
+		switch (type) {
+			case CartridgeType::MBC1:
+			case CartridgeType::MBC1_RAM:
+			case CartridgeType::MBC1_RAM_BATTERY: {
+				if (address <= 0x1FFF) {
+					// Any value "written" here with lower 4 bits == 0xA enables eram,
+					// other values disable eram
+					if (data == 0xA) {
+						ram_enabled_ = true;
+					}
+					else {
+						ram_enabled_ = false;
+					}
+				}
+				else if (address <= 0x3FFF) {
+					// BANK register 1 (TODO: this doesnt happen on mbc0?)
+					selected_rom_bank_ &= 0b1100000;
+					selected_rom_bank_ |= data & 0b11111;
+					selected_rom_bank_ %= rom_banks_size_;
+				}
+				else if (address <= 0x5FFF) {
+					// BANK register 2
+					selected_rom_bank_ &= 0b11111;
+					selected_rom_bank_ |= ((data & 0b11) << 5);
+					selected_rom_bank_ %= rom_banks_size_;
+					selected_ram_bank_ = data & 0b11;
+				}
+				else {
+					// MODE register
+					banking_mode_ = data & 0b1;
+				}
+				break;
+			}
+			default: {
+				return;
+			}
+		}
+	}
 	uint8_t& Bus::redirect_address(uint16_t address) {
 		unused_mem_area_ = 0;
-		using CT = Cartridge::CartridgeType;
 		// Return address from ROM banks
 		// TODO: create better exceptions
 		// TODO: make bios optional, can be disabled in settings
@@ -47,13 +84,13 @@ namespace TKPEmu::Gameboy::Devices {
 			case 0x7000: {
 				auto ct = cartridge_->GetCartridgeType();
 				switch (ct) {
-					case CT::ROM_ONLY: {
+					case CartridgeType::ROM_ONLY: {
 						int index = address / 0x4000;
 						return (rom_banks_[index])[address % 0x4000];
 					}
-					case CT::MBC1:
-					case CT::MBC1_RAM:
-					case CT::MBC1_RAM_BATTERY: {
+					case CartridgeType::MBC1:
+					case CartridgeType::MBC1_RAM:
+					case CartridgeType::MBC1_RAM_BATTERY: {
 						if (address <= 0x3FFF) {
 							auto sel = (banking_mode_ ? selected_rom_bank_ & 0b1100000 : 0) % cartridge_->GetRomSize();
 							return (rom_banks_[sel])[address % 0x4000];
@@ -62,6 +99,7 @@ namespace TKPEmu::Gameboy::Devices {
 							auto sel = selected_rom_bank_ % cartridge_->GetRomSize();
 							if ((sel & 0b11111) == 0) {
 								// In 4000-7FFF, automatically maps to next addr if addr chosen is 00/20/40/60
+								// TODO: fix multicart roms
 								sel += 1;
 							}
 							return (rom_banks_[sel])[address % 0x4000];
@@ -69,7 +107,8 @@ namespace TKPEmu::Gameboy::Devices {
 						break;
 					}
 				}
-				throw("Bad cartridge type");
+				std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
+				exit(1);
 				break;
 			}
 			case 0x8000:
@@ -110,7 +149,7 @@ namespace TKPEmu::Gameboy::Devices {
 					return hram_[address % 0xFF00];
 				}
 				else {
-					throw("Bad memory address");
+					std::cerr << "Error: Tried to access address " << address << std::endl;
 				}
 			}
 		}
@@ -151,33 +190,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void Bus::Write(uint16_t address, uint8_t data) {	
 		if (address <= 0x7FFF) {
-			if (address <= 0x1FFF) {
-				// Any value "written" here with lower 4 bits == 0xA enables eram,
-				// other values disable eram
-				if (data == 0xA) {
-					ram_enabled_ = true;
-				}
-				else {
-					ram_enabled_ = false;
-				}
-			}
-			else if (address <= 0x3FFF) {
-				// BANK register 1 (TODO: this doesnt happen on mbc0?)
-				selected_rom_bank_ &= 0b1100000;
-				selected_rom_bank_ |= data & 0b11111;
-				selected_rom_bank_ %= rom_banks_size_;
-			}
-			else if (address <= 0x5FFF) {
-				// BANK register 2
-				selected_rom_bank_ &= 0b11111;
-				selected_rom_bank_ |= ((data & 0b11) << 5);
-				selected_rom_bank_ %= rom_banks_size_;
-				selected_ram_bank_ = data & 0b11;
-			}
-			else {
-				// MODE register
-				banking_mode_ = data & 0b1;
-			}
+			handle_mbc(address, data);
 		}
 		else {
 			switch (address) {
@@ -305,19 +318,16 @@ namespace TKPEmu::Gameboy::Devices {
 			redirect_address(address) = data;
 		}
 	}
-
 	void Bus::WriteL(uint16_t address, uint16_t data) {
 		Write(address, data & 0xFF);
 		Write(address + 1, data >> 8);
 	}
-
 	void Bus::Reset() {
 		SoftReset();
 		for (auto& rom : rom_banks_) {
 			rom.fill(0);
 		}	
 	}
-
 	void Bus::SoftReset() {
 		for (auto& ram : ram_banks_) {
 			ram.fill(0);
@@ -328,7 +338,6 @@ namespace TKPEmu::Gameboy::Devices {
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;
 	}
-
 	void Bus::LoadCartridge(std::string fileName) {
 		Reset();
 		cartridge_ = std::unique_ptr<Cartridge>(new Cartridge());
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 1d414964deb67759ea860a8bfe603de5b32d3179..25d661f2b81df7b6788378a83cf0f8aef1f50a0a 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -15,23 +15,7 @@ namespace TKPEmu::Gameboy::Devices {
     private:
         using RamBank = std::array<uint8_t, 0x2000>;
         using RomBank = std::array<uint8_t, 0x4000>;
-        bool ram_enabled_ = false;
-        uint8_t selected_ram_bank_ = 0;
-        uint8_t selected_rom_bank_ = 1;
-        uint8_t rom_banks_size_ = 2;
-        bool banking_mode_ = false;
-        bool action_key_mode_ = false;
-        uint8_t unused_mem_area_ = 0;
-        std::vector<RamBank> ram_banks_;
-        std::vector<RomBank> rom_banks_;
-        std::unique_ptr<Cartridge> cartridge_ = NULL;
-        std::array<uint8_t, 0xA0> oam_{};
-        std::array<uint8_t, 0x100> hram_{};
-        std::array<uint8_t, 0x2000> eram_default_{};
-        std::array<uint8_t, 0x2000> wram_{}; // TODO: cgb uses larger wram, maybe change, maybe inherit
-        std::array<uint8_t, 0x2000> vram_{};
-        std::vector<DisInstr>& instructions_;
-        uint8_t& redirect_address(uint16_t address);
+        using CartridgeType = TKPEmu::Gameboy::Devices::CartridgeType;
     public:
         struct Sprite {
             uint8_t y_pos = 0;
@@ -90,6 +74,25 @@ namespace TKPEmu::Gameboy::Devices {
         uint8_t NextMode = 0;
         uint8_t DirectionKeys = 0b1110'1111;
         uint8_t ActionKeys = 0b1101'1111;
+    private:
+        bool ram_enabled_ = false;
+        uint8_t selected_ram_bank_ = 0;
+        uint8_t selected_rom_bank_ = 1;
+        uint8_t rom_banks_size_ = 2;
+        bool banking_mode_ = false;
+        bool action_key_mode_ = false;
+        uint8_t unused_mem_area_ = 0;
+        std::vector<RamBank> ram_banks_;
+        std::vector<RomBank> rom_banks_;
+        std::unique_ptr<Cartridge> cartridge_;
+        std::array<uint8_t, 0xA0> oam_{};
+        std::array<uint8_t, 0x100> hram_{};
+        std::array<uint8_t, 0x2000> eram_default_{};
+        std::array<uint8_t, 0x2000> wram_{};
+        std::array<uint8_t, 0x2000> vram_{};
+        std::vector<DisInstr>& instructions_;
+        uint8_t& redirect_address(uint16_t address);
+        void handle_mbc(uint16_t address, uint8_t data);
     };
 }
 #endif
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 3ea653c870cbd84f80baa70deea700551eac382e..098a691eefca82871eeee990d176dad4f4a45b14 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -26,7 +26,8 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				default: {
 					// TODO: better error or implement all cartridge types
-					throw("error rom not implemented");
+					std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
+					exit(1);
 				}
 			}
 			is.close();
@@ -36,7 +37,7 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 	}
 
-	Cartridge::CartridgeType Cartridge::GetCartridgeType() {
+	CartridgeType Cartridge::GetCartridgeType() {
 		if (loaded) {
 			return (CartridgeType)header_.cartridgeType;
 		}
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
index 0c89a80d975659257bafae27862f7dce3c38979e..7c0cb2b0e81290a6023d28ff7cf9f63d2ff60851 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.h
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -6,39 +6,37 @@
 #include <array>
 #define ENTRY_POINT 0x100
 namespace TKPEmu::Gameboy::Devices {
-	class Cartridge
-	{
-	public:
-		enum class CartridgeType {
-			ROM_ONLY = 0x0,
-			MBC1 = 0x1,
-			MBC1_RAM = 0x2,
-			MBC1_RAM_BATTERY = 0x3,
-			MBC2 = 0x5,
-			MBC2_BATTERY = 0x6,
-			ROM_RAM = 0x8,
-			ROM_RAM_BATTERY = 0x9,
-			MMM01 = 0xB,
-			MMM01_RAM = 0xC,
-			MMM01_RAM_BATTERY = 0xD,
-			MBC3_TIMER_RAM_BATTERY = 0x10,
-			MBC3 = 0x11,
-			MBC3_RAM = 0x12,
-			MBC3_RAM_BATTERY = 0x13,
-			MBC4 = 0x15,
-			MBC4_RAM = 0x16,
-			MBC4_RAM_BATTERY = 0x17,
-			MBC5 = 0x19,
-			MBC5_RAM = 0x1A,
-			MBC5_RAM_BATTERY = 0x1B,
-			MBC5_RUMBLE = 0x1C,
-			MBC5_RUMBLE_RAM = 0x1D,
-			MBC5_RUMBLE_RAM_BATTERY = 0x1E,
-			POCKET_CAMERA = 0xFC,
-			BANDAITAMA5 = 0xFD,
-			HuC3 = 0xFE,
-			HuC1_RAM_BATTERY = 0xFF
-		};
+	enum class CartridgeType {
+		ROM_ONLY = 0x0,
+		MBC1 = 0x1,
+		MBC1_RAM = 0x2,
+		MBC1_RAM_BATTERY = 0x3,
+		MBC2 = 0x5,
+		MBC2_BATTERY = 0x6,
+		ROM_RAM = 0x8,
+		ROM_RAM_BATTERY = 0x9,
+		MMM01 = 0xB,
+		MMM01_RAM = 0xC,
+		MMM01_RAM_BATTERY = 0xD,
+		MBC3_TIMER_RAM_BATTERY = 0x10,
+		MBC3 = 0x11,
+		MBC3_RAM = 0x12,
+		MBC3_RAM_BATTERY = 0x13,
+		MBC4 = 0x15,
+		MBC4_RAM = 0x16,
+		MBC4_RAM_BATTERY = 0x17,
+		MBC5 = 0x19,
+		MBC5_RAM = 0x1A,
+		MBC5_RAM_BATTERY = 0x1B,
+		MBC5_RUMBLE = 0x1C,
+		MBC5_RUMBLE_RAM = 0x1D,
+		MBC5_RUMBLE_RAM_BATTERY = 0x1E,
+		POCKET_CAMERA = 0xFC,
+		BANDAITAMA5 = 0xFD,
+		HuC3 = 0xFE,
+		HuC1_RAM_BATTERY = 0xFF
+	};
+	class Cartridge {
 	private:
 		struct Header {
 			char unusedData1[0x34];

From 195c5ed7b3f65994e8bf3a1ffc522c968cc0762c Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 5 Dec 2021 20:31:17 +0200
Subject: [PATCH] tim01 pass (fixes #4) tima_reload pass, div_write pass, all
 div_trigger fail though

---
 TKPEmu/gb_tkp/gb_cpu.cpp   | 505 ---------------------------------------------
 TKPEmu/gb_tkp/gb_timer.cpp |  26 +--
 2 files changed, 3 insertions(+), 528 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 5cb5f92551cb46fca36c1162c41ea6ec529174ea..882cc7a638872f975903405521b62a0a1913d257 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -232,68 +232,52 @@ namespace TKPEmu::Gameboy::Devices {
 		reg |= 1 << shift;
 		tTemp = 8;
 	}
-
-	#pragma region Instructions
-
 	void CPU::ADDAA() {
 		reg_add(A);
 	}
-
 	void CPU::ADDAB() {
 		reg_add(B);
 	}
-
 	void CPU::ADDAC() {
 		reg_add(C);
 	}
-
 	void CPU::ADDAD() {
 		reg_add(D);
 	}
-
 	void CPU::ADDAE() {
 		reg_add(E);
 	}
-
 	void CPU::ADDAH() {
 		reg_add(H);
 	}
-
 	void CPU::ADDAL() {
 		reg_add(L);
 	}
-
 	void CPU::ADDAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_add(t);
 		tTemp = 8;
 	}
-
 	void CPU::ADDA8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_add(t);
 		tTemp = 8;
 	}
-
 	void CPU::ADDHLBC() {
 		uint16_t t = (B << 8) | C;
 		hl_add(t);
 	}
-
 	void CPU::ADDHLDE() {
 		uint16_t t = (D << 8) | E;
 		hl_add(t);
 	}
-
 	void CPU::ADDHLHL() {
 		uint16_t t = (H << 8) | L;
 		hl_add(t);
 	}
-
 	void CPU::ADDHLSP() {
 		hl_add(SP);
 	}
-
 	void CPU::ADDSPD() {
 		int val = bus_->Read(PC);
 		auto temp = SP + ((val ^ 0x80) - 0x80);
@@ -306,151 +290,117 @@ namespace TKPEmu::Gameboy::Devices {
 		PC++;
 		tTemp = 16;
 	}
-
 	void CPU::ADCAA() {
 		reg_adc(A);
 	}
-
 	void CPU::ADCAB() {
 		reg_adc(B);
 	}
-
 	void CPU::ADCAC() {
 		reg_adc(C);
 	}
-
 	void CPU::ADCAD() {
 		reg_adc(D);
 	}
-
 	void CPU::ADCAE() {
 		reg_adc(E);
 	}
-
 	void CPU::ADCAH() {
 		reg_adc(H);
 	}
-
 	void CPU::ADCAL() {
 		reg_adc(L);
 	}
-
 	void CPU::ADCAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_adc(t);
 		tTemp = 8;
 	}
-
 	void CPU::ADCA8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_adc(t);
 		tTemp = 8;
 	}
-
 	void CPU::SUBAA() {
 		reg_sub(A);
 	}
-
 	void CPU::SUBAB() {
 		reg_sub(B);
 	}
-
 	void CPU::SUBAC() {
 		reg_sub(C);
 	}
-
 	void CPU::SUBAD() {
 		reg_sub(D);
 	}
-
 	void CPU::SUBAE() {
 		reg_sub(E);
 	}
-
 	void CPU::SUBAH() {
 		reg_sub(H);
 	}
-
 	void CPU::SUBAL() {
 		reg_sub(L);
 	}
-
 	void CPU::SUBAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_sub(t);
 		tTemp = 8;
 	}
-
 	void CPU::SUBA8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_sub(t);
 		tTemp = 8;
 	}
-
 	void CPU::SBCAA() {
 		reg_sbc(A);
 	}
-
 	void CPU::SBCAB() {
 		reg_sbc(B);
 	}
-
 	void CPU::SBCAC() {
 		reg_sbc(C);
 	}
-
 	void CPU::SBCAD() {
 		reg_sbc(D);
 	}
-
 	void CPU::SBCAE() {
 		reg_sbc(E);
 	}
-
 	void CPU::SBCAH() {
 		reg_sbc(H);
 	}
-
 	void CPU::SBCAL() {
 		reg_sbc(L);
 	}
-
 	void CPU::SBCAHL() {
 		uint8_t t = bus_->Read(H << 8 | L);
 		reg_sbc(t);
 		tTemp = 8;
 	}
-
 	void CPU::SBCA8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_sbc(t);
 		tTemp = 8;
 	}
-
 	void CPU::CPAA() {
 		reg_cmp(A);
 	}
-
 	void CPU::CPAB() {
 		reg_cmp(B);
 	}
-
 	void CPU::CPAC() {
 		reg_cmp(C);
 	}
-
 	void CPU::CPAD() {
 		reg_cmp(D);
 	}
-
 	void CPU::CPAE() {
 		reg_cmp(E);
 	}
-
 	void CPU::CPAH() {
 		reg_cmp(H);
 	}
-
 	void CPU::CPAL() {
 		reg_cmp(L);
 	}
@@ -461,32 +411,27 @@ namespace TKPEmu::Gameboy::Devices {
 		bus_->WriteL(SP, (B << 8) | C);
 		tTemp = 16;
 	}
-
 	void CPU::PUSHAF() {
 		SP -= 2;
 		bus_->WriteL(SP, (A << 8) | F);
 		tTemp = 16;
 	}
-
 	void CPU::PUSHDE() {
 		SP -= 2;
 		bus_->WriteL(SP, (D << 8) | E);
 		tTemp = 16;
 	}
-
 	void CPU::PUSHHL() {
 		SP -= 2;
 		bus_->WriteL(SP, (H << 8) | L);
 		tTemp = 16;
 	}
-
 	void CPU::POPBC() {
 		B = bus_->Read(SP + 1);
 		C = bus_->Read(SP);
 		SP += 2;
 		tTemp = 12;
 	}
-
 	void CPU::POPAF() {
 		auto temp = bus_->ReadL(SP);
 		A = (temp >> 8) & 0xFF;
@@ -494,14 +439,12 @@ namespace TKPEmu::Gameboy::Devices {
 		SP += 2;
 		tTemp = 12;
 	}
-
 	void CPU::POPDE() {
 		E = bus_->Read(SP);
 		D = bus_->Read(SP + 1);
 		SP += 2;
 		tTemp = 12;
 	}
-
 	void CPU::POPHL() {
 		L = bus_->Read(SP);
 		H = bus_->Read(SP + 1);
@@ -515,496 +458,399 @@ namespace TKPEmu::Gameboy::Devices {
 		A = bus_->Read(addr);
 		tTemp = 8;
 	}
-
 	void CPU::LDADE() {
 		int addr = E | (D << 8);
 		A = bus_->Read(addr);
 		tTemp = 8;
 	}
-
 	void CPU::LDAA() {
 		A = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDAB() {
 		A = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDAC() {
 		A = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDAD() {
 		A = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDAE() {
 		A = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDAH() {
 		A = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDAL() {
 		A = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDBA() {
 		B = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDBB() {
 		B = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDBC() {
 		B = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDBD() {
 		B = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDBE() {
 		B = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDBH() {
 		B = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDBL() {
 		B = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDCA() {
 		C = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDCB() {
 		C = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDCC() {
 		C = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDCD() {
 		C = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDCE() {
 		C = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDCH() {
 		C = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDCL() {
 		C = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDDA() {
 		D = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDDB() {
 		D = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDDC() {
 		D = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDDD() {
 		D = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDDE() {
 		D = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDDH() {
 		D = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDDL() {
 		D = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDEA() {
 		E = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDEB() {
 		E = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDEC() {
 		E = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDED() {
 		E = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDEE() {
 		E = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDEH() {
 		E = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDEL() {
 		E = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDHA() {
 		H = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDHB() {
 		H = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDHC() {
 		H = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDHD() {
 		H = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDHE() {
 		H = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDHH() {
 		H = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDHL() {
 		H = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDLA() {
 		L = A;
 		tTemp = 4;
 	}
-
 	void CPU::LDLB() {
 		L = B;
 		tTemp = 4;
 	}
-
 	void CPU::LDLC() {
 		L = C;
 		tTemp = 4;
 	}
-
 	void CPU::LDLD() {
 		L = D;
 		tTemp = 4;
 	}
-
 	void CPU::LDLE() {
 		L = E;
 		tTemp = 4;
 	}
-
 	void CPU::LDLH() {
 		L = H;
 		tTemp = 4;
 	}
-
 	void CPU::LDLL() {
 		L = L;
 		tTemp = 4;
 	}
-
 	void CPU::LDAHL() {
 		A = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDBHL() {
 		B = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDCHL() {
 		C = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDDHL() {
 		D = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDEHL() {
 		E = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDHHL() {
 		H = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDLHL() {
 		L = bus_->Read((H << 8) | L);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLA() {
 		bus_->Write((H << 8) | L, A);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLB() {
 		bus_->Write((H << 8) | L, B);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLC() {
 		bus_->Write((H << 8) | L, C);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLD() {
 		bus_->Write((H << 8) | L, D);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLE() {
 		bus_->Write((H << 8) | L, E);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLH() {
 		bus_->Write((H << 8) | L, H);
 		tTemp = 8;
 	}
-
 	void CPU::LDHLL() {
 		bus_->Write((H << 8) | L, L);
 		tTemp = 8;
 	}
-
 	void CPU::LDA8() {
 		A = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDB8() {
 		B = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDC8() {
 		C = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDD8() {
 		D = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDE8() {
 		E = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDH8() {
 		H = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDL8() {
 		L = bus_->Read(PC);
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::LDHL8() {
 		bus_->Write((H << 8) | L, bus_->Read(PC));
 		PC++;
 		tTemp = 12;
 	}
-
 	void CPU::LDBCA() {
 		bus_->Write((B << 8) | C, A);
 		tTemp = 8;
 	}
-
 	void CPU::LDDEA() {
 		bus_->Write((D << 8) | E, A);
 		tTemp = 8;
 	}
-
 	void CPU::LD16A() {
 		bus_->Write(bus_->ReadL(PC), A);
 		PC += 2;
 		tTemp = 16;
 	}
-
 	void CPU::LDA16() {
 		A = bus_->Read(bus_->ReadL(PC));
 		PC += 2;
 		tTemp = 16;
 	}
-
 	void CPU::LDBC16() {
 		C = bus_->Read(PC);
 		B = bus_->Read(PC + 1);
 		PC += 2;
 		tTemp = 12;
 	}
-
 	void CPU::LDDE16() {
 		E = bus_->Read(PC);
 		D = bus_->Read(PC + 1);
 		PC += 2;
 		tTemp = 12;
 	}
-
 	void CPU::LDHL16() {
 		L = bus_->Read(PC);
 		H = bus_->Read(PC + 1);
 		PC += 2;
 		tTemp = 12;
 	}
-
 	void CPU::LD16SP() {
 		bus_->Write(bus_->ReadL(PC), SP & 0xFF);
 		bus_->Write(bus_->ReadL(PC) + 1, (SP >> 8) & 0xFF);
 		PC += 2;
 		tTemp = 20;
 	}
-
 	void CPU::INCA() {
 		reg_inc(A);
 	}
-
 	void CPU::INCB() {
 		reg_inc(B);
 	}
-
 	void CPU::INCC() {
 		reg_inc(C);
 	}
-
 	void CPU::INCD() {
 		reg_inc(D);
 	}
-
 	void CPU::INCE() {
 		reg_inc(E);
 	}
-
 	void CPU::INCH() {
 		reg_inc(H);
 	}
-
 	void CPU::INCL() {
 		reg_inc(L);
 	}
-
 	void CPU::INCHLR() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_inc(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 12;
 	}
-
 	void CPU::DECA() {
 		reg_dec(A);
 	}
-
 	void CPU::DECB() {
 		reg_dec(B);
 	}
-
 	void CPU::DECC() {
 		reg_dec(C);
 	}
-
 	void CPU::DECD() {
 		reg_dec(D);
 	}
-
 	void CPU::DECE() {
 		reg_dec(E);
 	}
-
 	void CPU::DECH() {
 		reg_dec(H);
 	}
-
 	void CPU::DECL() {
 		reg_dec(L);
 	}
-
 	void CPU::DECHLR() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_dec(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 12;
 	}
-
 	void CPU::INCBC() {
 		// TODO: big reg inc
 		C = (C + 1) & 0xFF;
@@ -1013,7 +859,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::INCDE() {
 		E = (E + 1) & 0xFF;
 		if (!E) {
@@ -1021,7 +866,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::INCHL() {
 		L = (L + 1) & 0xFF;
 		if (!L) {
@@ -1029,12 +873,10 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::INCSP() {
 		SP++;
 		tTemp = 8;
 	}
-
 	void CPU::DECBC() {
 		C = (C - 1) & 0xFF;
 		if (C == 0xFF) {
@@ -1042,7 +884,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::DECDE() {
 		E = (E - 1) & 0xFF;
 		if (E == 0xFF) {
@@ -1050,7 +891,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::DECHL() {
 		L = (L - 1) & 0xFF;
 		if (L == 0xFF) {
@@ -1058,22 +898,18 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::DECSP() {
 		SP = (SP - 1) & 0xFFFF;
 		tTemp = 8;
 	}
-
 	void CPU::JP16() {
 		PC = bus_->ReadL(PC);
 		tTemp = 16;
 	}
-
 	void CPU::JPHL() {
 		PC = (H << 8) | L;
 		tTemp = 4;
 	}
-
 	void CPU::JPNZ16() {
 		tTemp = 12;
 		if ((F & 0x80) == 0x00) {
@@ -1083,7 +919,6 @@ namespace TKPEmu::Gameboy::Devices {
 		else
 			PC += 2;
 	}
-
 	void CPU::JPZ16() {
 		tTemp = 12;
 		if ((F & 0x80) == 0x80) {
@@ -1093,7 +928,6 @@ namespace TKPEmu::Gameboy::Devices {
 		else
 			PC += 2;
 	}
-
 	void CPU::JPNC16() {
 		tTemp = 12;
 		if ((F & 0x10) == 0x00) {
@@ -1103,7 +937,6 @@ namespace TKPEmu::Gameboy::Devices {
 		else
 			PC += 2;
 	}
-
 	void CPU::JPC16() {
 		tTemp = 12;
 		if ((F & 0x10) == 0x10) {
@@ -1113,7 +946,6 @@ namespace TKPEmu::Gameboy::Devices {
 		else
 			PC += 2;
 	}
-
 	void CPU::JR8() {
 		int i = bus_->Read(PC);
 		if (i >= 0x80)
@@ -1123,7 +955,6 @@ namespace TKPEmu::Gameboy::Devices {
 		PC += i;
 		tTemp += 4;
 	}
-
 	void CPU::JRNZ8() {
 		int i = bus_->Read(PC);
 		PC++;
@@ -1135,7 +966,6 @@ namespace TKPEmu::Gameboy::Devices {
 			tTemp = 8;
 		}
 	}
-
 	void CPU::JRZ8() {
 		int i = bus_->Read(PC);
 		if (i >= 0x80)
@@ -1147,7 +977,6 @@ namespace TKPEmu::Gameboy::Devices {
 			; tTemp += 4;
 		}
 	}
-
 	void CPU::JRNC8() {
 		int i = bus_->Read(PC);
 		if (i >= 0x80)
@@ -1159,7 +988,6 @@ namespace TKPEmu::Gameboy::Devices {
 			tTemp += 4;
 		}
 	}
-
 	void CPU::JRC8() {
 		int i = bus_->Read(PC);
 		if (i >= 0x80)
@@ -1171,148 +999,116 @@ namespace TKPEmu::Gameboy::Devices {
 			tTemp += 4;
 		}
 	}
-
 	void CPU::ANDA() {
 		reg_and(A);
 	}
-
 	void CPU::ANDB() {
 		reg_and(B);
 	}
-
 	void CPU::ANDC() {
 		reg_and(C);
 	}
-
 	void CPU::ANDD() {
 		reg_and(D);
 	}
-
 	void CPU::ANDE() {
 		reg_and(E);
 	}
-
 	void CPU::ANDH() {
 		reg_and(H);
 	}
-
 	void CPU::ANDL() {
 		reg_and(L);
 	}
-
 	void CPU::ANDHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_and(t);
 		tTemp = 8;
 	}
-
 	void CPU::AND8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_and(t);
 		tTemp = 8;
 	}
-
 	void CPU::ORA() {
 		reg_or(A);
 	}
-
 	void CPU::ORB() {
 		reg_or(B);
 	}
-
 	void CPU::ORC() {
 		reg_or(C);
 	}
-
 	void CPU::ORD() {
 		reg_or(D);
 	}
-
 	void CPU::ORE() {
 		reg_or(E);
 	}
-
 	void CPU::ORH() {
 		reg_or(H);
 	}
-
 	void CPU::ORL() {
 		reg_or(L);
 	}
-
 	void CPU::ORHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_or(t);
 		tTemp = 8;
 	}
-
 	void CPU::OR8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_or(t);
 		tTemp = 8;
 	}
-
 	void CPU::XORA() {
 		reg_xor(A);
 	}
-
 	void CPU::XORB() {
 		reg_xor(B);
 	}
-
 	void CPU::XORC() {
 		reg_xor(C);
 	}
-
 	void CPU::XORD() {
 		reg_xor(D);
 	}
-
 	void CPU::XORE() {
 		reg_xor(E);
 	}
-
 	void CPU::XORH() {
 		reg_xor(H);
 	}
-
 	void CPU::XORL() {
 		reg_xor(L);
 	}
-
 	void CPU::XORHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_xor(t);
 		tTemp = 8;
 	}
-
 	void CPU::XOR8() {
 		uint8_t t = bus_->Read(PC++);
 		reg_xor(t);
 		tTemp = 8;
 	}
-
 	void CPU::NOP() {
 		tTemp = 4;
 	}
-
 	void CPU::STOP() {
 		PC++;
 	}
-
 	void CPU::RET() {
 		PC = bus_->ReadL(SP);
 		SP += 2;
 		tTemp = 12;
 	}
-
 	void CPU::RETI() {
 		ime_ = true;
 		PC = bus_->ReadL(SP);
 		SP += 2;
 		tTemp = 16;
 	}
-
 	void CPU::RETNZ() {
 		tTemp = 8;
 		if ((F & 0x80) == 0x00) {
@@ -1321,7 +1117,6 @@ namespace TKPEmu::Gameboy::Devices {
 			; tTemp += 12;
 		}
 	}
-
 	void CPU::RETZ() {
 		tTemp = 8;
 		if ((F & 0x80) == 0x80) {
@@ -1330,7 +1125,6 @@ namespace TKPEmu::Gameboy::Devices {
 			; tTemp += 12;
 		}
 	}
-
 	void CPU::RETNC() {
 		tTemp = 8;
 		if ((F & 0x10) == 0x00) {
@@ -1339,7 +1133,6 @@ namespace TKPEmu::Gameboy::Devices {
 			; tTemp += 12;
 		}
 	}
-
 	void CPU::RETC() {
 		tTemp = 8;
 		if ((F & 0x10) == 0x10) {
@@ -1348,57 +1141,44 @@ namespace TKPEmu::Gameboy::Devices {
 			; tTemp += 12;
 		}
 	}
-
 	void CPU::RST0() {
 		rst(0x00);
 	}
-
 	void CPU::RST8() {
 		rst(0x08);
 	}
-
 	void CPU::RST10() {
 		rst(0x10);
 	}
-
 	void CPU::RST18() {
 		rst(0x18);
 	}
-
 	void CPU::RST20() {
 		rst(0x20);
 	}
-
 	void CPU::RST28() {
 		rst(0x28);
 	}
-
 	void CPU::RST30() {
 		rst(0x30);
 	}
-
 	void CPU::RST38() {
 		rst(0x38);
 	}
-
 	void CPU::LDSPHL() {
 		SP = (H << 8) | L;
 		tTemp = 8;
 	}
-
 	void CPU::LDAMC() {
 		A = bus_->Read(0xFF00 + C);
 		tTemp = 8;
 	}
-
 	void CPU::DI() {
 		ime_ = false; tTemp = 4;
 	}
-
 	void CPU::EI() {
 		ime_ = true; tTemp = 4;
 	}
-
 	void CPU::RLA() {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = (A << 1) + carry;
@@ -1408,7 +1188,6 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
 	void CPU::RLCA() {
 		auto temp = (A << 1) + (A >> 7);
 		auto flag = FLAG_EMPTY_MASK;
@@ -1417,7 +1196,6 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
 	void CPU::RRA() {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = (A >> 1) + ((carry) << 7) + ((A & 1) << 8);
@@ -1428,7 +1206,6 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp;
 		tTemp = 4;
 	}
-
 	void CPU::RRCA() {
 		auto temp = (A >> 1) + ((A & 1) << 7) + ((A & 1) << 8);
 		auto flag = FLAG_EMPTY_MASK;
@@ -1438,14 +1215,12 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp;
 		tTemp = 4;
 	}
-
 	void CPU::CALL16() {
 		SP -= 2;
 		bus_->WriteL(SP, PC + 2);
 		PC = bus_->ReadL(PC);
 		tTemp = 24;
 	}
-
 	void CPU::CALLNZ16() {
 		if (!(F & FLAG_ZERO_MASK)) {
 			SP -= 2;
@@ -1458,7 +1233,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		; tTemp += 12;
 	}
-
 	void CPU::CALLZ16() {
 		if ((F & 0x80) == 0x80) {
 			SP -= 2;
@@ -1471,7 +1245,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 12;
 	}
-
 	void CPU::CALLNC16() {
 		if ((F & 0x10) == 0x00) {
 			SP -= 2;
@@ -1484,7 +1257,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 12;
 	}
-
 	void CPU::CALLC16() {
 		if ((F & 0x10) == 0x10) {
 			SP -= 2;
@@ -1497,13 +1269,11 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 12;
 	}
-
 	void CPU::LDSP16() {
 		SP = bus_->ReadL(PC);
 		PC += 2;
 		tTemp = 12;
 	}
-
 	void CPU::LDDHLA() {
 		bus_->Write((H << 8) | L, A);
 		L = (L - 1) & 0xFF;
@@ -1512,7 +1282,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::LDDAHL() {
 		A = bus_->Read((H << 8) | L);
 		L = (L - 1) & 0xFF;
@@ -1521,7 +1290,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::LDIHLA() {
 		bus_->Write((H << 8) | L, A);
 		L = (L + 1) & 0xFF;
@@ -1530,7 +1298,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::LDIAHL() {
 		A = bus_->Read((H << 8) | L);
 		L = (L + 1) & 0xFF;
@@ -1539,7 +1306,6 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		tTemp = 8;
 	}
-
 	void CPU::DAA() {
 		int temp = A;
 		uint16_t corr = 0;
@@ -1562,27 +1328,23 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp;
 		tTemp = 4;
 	}
-
 	void CPU::CPL() {
 		A = (~A) & 0xFF;
 		F &= 0b1001'0000;
 		F |= 0b0110'0000;
 		tTemp = 4;
 	}
-
 	void CPU::SCF() {
 		F &= 0b1000'0000;
 		F |= 0b0001'0000;
 		tTemp = 4;
 	}
-
 	void CPU::CCF() {
 		auto flag = (F & 0b0001'0000) ^ 0b0001'0000;
 		F &= 0b1000'0000;
 		F |= flag;
 		tTemp = 4;
 	}
-
 	void CPU::LDHLSPD() {
 		auto val = bus_->Read(PC);
 		auto HL = SP + ((val ^ 0x80) - 0x80);
@@ -1595,24 +1357,20 @@ namespace TKPEmu::Gameboy::Devices {
 		PC++;
 		tTemp = 12;
 	}
-
 	void CPU::LDHA8() {
 		A = bus_->Read(0xFF00 + bus_->Read(PC));
 		PC++;
 		tTemp = 12;
 	}
-
 	void CPU::LDH8A() {
 		bus_->Write(0xFF00 + bus_->Read(PC), A);
 		PC++;
 		tTemp = 12;
 	}
-
 	void CPU::LDHCA() {
 		bus_->Write(0xFF00 + C, A);
 		tTemp = 8;
 	}
-
 	void CPU::EXT() {
 		int i = bus_->Read(PC);
 		PC++;
@@ -1621,13 +1379,11 @@ namespace TKPEmu::Gameboy::Devices {
 			(this->*CBInstructions[i].op)();
 		}
 	}
-
 	void CPU::CPAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_cmp(t);
 		tTemp = 8;
 	}
-
 	void CPU::CP8() {
 		uint16_t m = bus_->Read(PC);
 		int temp = A - m;
@@ -1639,15 +1395,12 @@ namespace TKPEmu::Gameboy::Devices {
 		PC++;
 		tTemp = 8;
 	}
-
 	void CPU::HALT() {
 		halt_ = true;
 	}
-
 	void CPU::XXX() {
 		stop_ = true;
 	}
-
 	void CPU::RLCB() {
 		int i = B & 0x80 ? 1 : 0;
 		int o = B & 0x80 ? 0x10 : 0;
@@ -1657,7 +1410,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCC() {
 		int i = C & 0x80 ? 1 : 0;
 		int o = C & 0x80 ? 0x10 : 0;
@@ -1667,7 +1419,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCD() {
 		int i = D & 0x80 ? 1 : 0;
 		int o = D & 0x80 ? 0x10 : 0;
@@ -1677,7 +1428,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCE() {
 		int i = E & 0x80 ? 1 : 0;
 		int o = E & 0x80 ? 0x10 : 0;
@@ -1687,7 +1437,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCH() {
 		int i = H & 0x80 ? 1 : 0;
 		int o = H & 0x80 ? 0x10 : 0;
@@ -1697,7 +1446,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCL() {
 		int i = L & 0x80 ? 1 : 0;
 		int o = L & 0x80 ? 0x10 : 0;
@@ -1707,7 +1455,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCAr() {
 		int i = A & 0x80 ? 1 : 0;
 		int o = A & 0x80 ? 0x10 : 0;
@@ -1717,7 +1464,6 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + o;
 		tTemp = 8;
 	}
-
 	void CPU::RLCHL() {
 		int i = bus_->Read((H << 8) | L);
 		int ci = (i & 0x80) ? 1 : 0;
@@ -1729,1077 +1475,827 @@ namespace TKPEmu::Gameboy::Devices {
 		F = (F & 0xEF) + co;
 		tTemp = 16;
 	}
-
 	void CPU::RRCB() {
 		bit_rrc(B);
 	}
-
 	void CPU::RRCC() {
 		bit_rrc(C);
 	}
-
 	void CPU::RRCD() {
 		bit_rrc(D);
 	}
-
 	void CPU::RRCE() {
 		bit_rrc(E);
 	}
-
 	void CPU::RRCH() {
 		bit_rrc(H);
 	}
-
 	void CPU::RRCL() {
 		bit_rrc(L);
 	}
-
 	void CPU::RRCAr() {
 		bit_rrc(A);
 	}
-
 	void CPU::RRCHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_rrc(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::RLB() {
 		bit_rl(B);
 	}
-
 	void CPU::RLC() {
 		bit_rl(C);
 	}
-
 	void CPU::RLD() {
 		bit_rl(D);
 	}
-
 	void CPU::RLE() {
 		bit_rl(E);
 	}
-
 	void CPU::RLH() {
 		bit_rl(H);
 	}
-
 	void CPU::RLL() {
 		bit_rl(L);
 	}
-
 	void CPU::RLAr() {
 		bit_rl(A);
 	}
-
 	void CPU::RLHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_rl(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::RRB() {
 		bit_rr(B);
 	}
-
 	void CPU::RRC() {
 		bit_rr(C);
 	}
-
 	void CPU::RRD() {
 		bit_rr(D);
 	}
-
 	void CPU::RRE() {
 		bit_rr(E);
 	}
-
 	void CPU::RRH() {
 		bit_rr(H);
 	}
-
 	void CPU::RRL() {
 		bit_rr(L);
 	}
-
 	void CPU::RRAr() {
 		bit_rr(A);
 	}
-
 	void CPU::RRHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_rr(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::SLAB() {
 		bit_sl(B);
 	}
-
 	void CPU::SLAC() {
 		bit_sl(C);
 	}
-
 	void CPU::SLAD() {
 		bit_sl(D);
 	}
-
 	void CPU::SLAE() {
 		bit_sl(E);
 	}
-
 	void CPU::SLAH() {
 		bit_sl(H);
 	}
-
 	void CPU::SLAL() {
 		bit_sl(L);
 	}
-
 	void CPU::SLAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_sl(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::SLAA() {
 		bit_sl(A);
 	}
-
 	void CPU::SRAB() {
 		bit_sr(B);
 	}
-
 	void CPU::SRAC() {
 		bit_sr(C);
 	}
-
 	void CPU::SRAD() {
 		bit_sr(D);
 	}
-
 	void CPU::SRAE() {
 		bit_sr(E);
 	}
-
 	void CPU::SRAH() {
 		bit_sr(H);
 	}
-
 	void CPU::SRAL() {
 		bit_sr(L);
 	}
-
 	void CPU::SRAHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_sr(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::SRAA() {
 		bit_sr(A);
 	}
-
 	void CPU::SWAPB() {
 		bit_swap(B);
 	}
-
 	void CPU::SWAPC() {
 		bit_swap(C);
 	}
-
 	void CPU::SWAPD() {
 		bit_swap(D);
 	}
-
 	void CPU::SWAPE() {
 		bit_swap(E);
 	}
-
 	void CPU::SWAPH() {
 		bit_swap(H);
 	}
-
 	void CPU::SWAPL() {
 		bit_swap(L);
 	}
-
 	void CPU::SWAPHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_swap(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::SWAPA() {
 		bit_swap(A);
 	}
-
 	void CPU::SRLB() {
 		bit_srl(B);
 	}
-
 	void CPU::SRLC() {
 		bit_srl(C);
 	}
-
 	void CPU::SRLD() {
 		bit_srl(D);
 	}
-
 	void CPU::SRLE() {
 		bit_srl(E);
 	}
-
 	void CPU::SRLH() {
 		bit_srl(H);
 	}
-
 	void CPU::SRLL() {
 		bit_srl(L);
 	}
-
 	void CPU::SRLHL() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		bit_srl(t);
 		bus_->Write((H << 8) | L, t);
 		tTemp = 16;
 	}
-
 	void CPU::SRLA() {
 		bit_srl(A);
 	}
-
 	void CPU::BIT0B() {
 		bit_ch(B, 0);
 	}
-
 	void CPU::BIT0C() {
 		bit_ch(C, 0);
 	}
-
 	void CPU::BIT0D() {
 		bit_ch(D, 0);
 	}
-
 	void CPU::BIT0E() {
 		bit_ch(E, 0);
 	}
-
 	void CPU::BIT0H() {
 		bit_ch(H, 0);
 	}
-
 	void CPU::BIT0L() {
 		bit_ch(L, 0);
 	}
-
 	void CPU::BIT0A() {
 		bit_ch(A, 0);
 	}
-
 	void CPU::BIT0M() {
 		bit_ch(bus_->Read((H << 8) | L), 0);
 		tTemp = 12;
 	}
-
 	void CPU::BIT1B() {
 		bit_ch(B, 1);
 	}
-
 	void CPU::BIT1C() {
 		bit_ch(C, 1);
 	}
-
 	void CPU::BIT1D() {
 		bit_ch(D, 1);
 	}
-
 	void CPU::BIT1E() {
 		bit_ch(E, 1);
 	}
-
 	void CPU::BIT1H() {
 		bit_ch(H, 1);
 	}
-
 	void CPU::BIT1L() {
 		bit_ch(L, 1);
 	}
-
 	void CPU::BIT1A() {
 		bit_ch(A, 1);
 	}
-
 	void CPU::BIT1M() {
 		bit_ch(bus_->Read((H << 8) | L), 1);
 		tTemp = 12;
 	}
-
 	void CPU::BIT2B() {
 		bit_ch(B, 2);
 	}
-
 	void CPU::BIT2C() {
 		bit_ch(C, 2);
 	}
-
 	void CPU::BIT2D() {
 		bit_ch(D, 2);
 	}
-
 	void CPU::BIT2E() {
 		bit_ch(E, 2);
 	}
-
 	void CPU::BIT2H() {
 		bit_ch(H, 2);
 	}
-
 	void CPU::BIT2L() {
 		bit_ch(L, 2);
 	}
-
 	void CPU::BIT2A() {
 		bit_ch(A, 2);
 	}
-
 	void CPU::BIT2M() {
 		bit_ch(bus_->Read((H << 8) | L), 2);
 		tTemp = 12;
 	}
-
 	void CPU::BIT3B() {
 		bit_ch(B, 3);
 	}
-
 	void CPU::BIT3C() {
 		bit_ch(C, 3);
 	}
-
 	void CPU::BIT3D() {
 		bit_ch(D, 3);
 	}
-
 	void CPU::BIT3E() {
 		bit_ch(E, 3);
 	}
-
 	void CPU::BIT3H() {
 		bit_ch(H, 3);
 	}
-
 	void CPU::BIT3L() {
 		bit_ch(L, 3);
 	}
-
 	void CPU::BIT3A() {
 		bit_ch(A, 3);
 	}
-
 	void CPU::BIT3M() {
 		bit_ch(bus_->Read((H << 8) | L), 3);
 		tTemp = 12;
 	}
-
 	void CPU::BIT4B() {
 		bit_ch(B, 4);
 	}
-
 	void CPU::BIT4C() {
 		bit_ch(C, 4);
 	}
-
 	void CPU::BIT4D() {
 		bit_ch(D, 4);
 	}
-
 	void CPU::BIT4E() {
 		bit_ch(E, 4);
 	}
-
 	void CPU::BIT4H() {
 		bit_ch(H, 4);
 	}
-
 	void CPU::BIT4L() {
 		bit_ch(L, 4);
 	}
-
 	void CPU::BIT4A() {
 		bit_ch(A, 4);
 	}
-
 	void CPU::BIT4M() {
 		bit_ch(bus_->Read((H << 8) | L), 4);
 		tTemp = 12;
 	}
-
 	void CPU::BIT5B() {
 		bit_ch(B, 5);
 	}
-
 	void CPU::BIT5C() {
 		bit_ch(C, 5);
 	}
-
 	void CPU::BIT5D() {
 		bit_ch(D, 5);
 	}
-
 	void CPU::BIT5E() {
 		bit_ch(E, 5);
 	}
-
 	void CPU::BIT5H() {
 		bit_ch(H, 5);
 	}
-
 	void CPU::BIT5L() {
 		bit_ch(L, 5);
 	}
-
 	void CPU::BIT5A() {
 		bit_ch(A, 5);
 	}
-
 	void CPU::BIT5M() {
 		bit_ch(bus_->Read((H << 8) | L), 5);
 		tTemp = 12;
 	}
-
 	void CPU::BIT6B() {
 		bit_ch(B, 6);
 	}
-
 	void CPU::BIT6C() {
 		bit_ch(C, 6);
 	}
-
 	void CPU::BIT6D() {
 		bit_ch(D, 6);
 	}
-
 	void CPU::BIT6E() {
 		bit_ch(E, 6);
 	}
-
 	void CPU::BIT6H() {
 		bit_ch(H, 6);
 	}
-
 	void CPU::BIT6L() {
 		bit_ch(L, 6);
 	}
-
 	void CPU::BIT6A() {
 		bit_ch(A, 6);
 	}
-
 	void CPU::BIT6M() {
 		bit_ch(bus_->Read((H << 8) | L), 6);
 		tTemp = 12;
 	}
-
 	void CPU::BIT7B() {
 		bit_ch(B, 7);
 	}
-
 	void CPU::BIT7C() {
 		bit_ch(C, 7);
 	}
-
 	void CPU::BIT7D() {
 		bit_ch(D, 7);
 	}
-
 	void CPU::BIT7E() {
 		bit_ch(E, 7);
 	}
-
 	void CPU::BIT7H() {
 		bit_ch(H, 7);
 	}
-
 	void CPU::BIT7L() {
 		bit_ch(L, 7);
 	}
-
 	void CPU::BIT7A() {
 		bit_ch(A, 7);
 	}
-
 	void CPU::BIT7M() {
 		bit_ch(bus_->Read((H << 8) | L), 7);
 		tTemp = 12;
 	}
-
 	void CPU::RES0B(){
 		bit_res(B, 0);
 	}
-
 	void CPU::RES0C() {
 		bit_res(C, 0);
 	}
-
 	void CPU::RES0D() {
 		bit_res(D, 0);
 	}
-
 	void CPU::RES0E() {
 		bit_res(E, 0);
 	}
-
 	void CPU::RES0H() {
 		bit_res(H, 0);
 	}
-
 	void CPU::RES0L() {
 		bit_res(L, 0);
 	}
-
 	void CPU::RES0HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 0);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES0A() {
 		bit_res(A, 0);
 	}
-
 	void CPU::RES1B() {
 		bit_res(B, 1);
 	}
-
 	void CPU::RES1C() {
 		bit_res(C, 1);
 	}
-
 	void CPU::RES1D() {
 		bit_res(D, 1);
 	}
-
 	void CPU::RES1E() {
 		bit_res(E, 1);
 	}
-
 	void CPU::RES1H() {
 		bit_res(H, 1);
 	}
-
 	void CPU::RES1L() {
 		bit_res(L, 1);
 	}
-
 	void CPU::RES1HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 1);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES1A() {
 		bit_res(A, 1);
 	}
-
 	void CPU::RES2B() {
 		bit_res(B, 2);
 	}
-
 	void CPU::RES2C() {
 		bit_res(C, 2);
 	}
-
 	void CPU::RES2D() {
 		bit_res(D, 2);
 	}
-
 	void CPU::RES2E() {
 		bit_res(E, 2);
 	}
-
 	void CPU::RES2H() {
 		bit_res(H, 2);
 	}
-
 	void CPU::RES2L() {
 		bit_res(L, 2);
 	}
-
 	void CPU::RES2HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 2);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES2A() {
 		bit_res(A, 2);
 	}
-
 	void CPU::RES3B() {
 		bit_res(B, 3);
 	}
-
 	void CPU::RES3C() {
 		bit_res(C, 3);
 	}
-
 	void CPU::RES3D() {
 		bit_res(D, 3);
 	}
-
 	void CPU::RES3E() {
 		bit_res(E, 3);
 	}
-
 	void CPU::RES3H() {
 		bit_res(H, 3);
 	}
-
 	void CPU::RES3L() {
 		bit_res(L, 3);
 	}
-
 	void CPU::RES3HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 3);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES3A() {
 		bit_res(A, 3);
 	}
-
 	void CPU::RES4B() {
 		bit_res(B, 4);
 	}
-
 	void CPU::RES4C() {
 		bit_res(C, 4);
 	}
-
 	void CPU::RES4D() {
 		bit_res(D, 4);
 	}
-
 	void CPU::RES4E() {
 		bit_res(E, 4);
 	}
-
 	void CPU::RES4H() {
 		bit_res(H, 4);
 	}
-
 	void CPU::RES4L() {
 		bit_res(L, 4);
 	}
-
 	void CPU::RES4HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 4);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES4A() {
 		bit_res(A, 4);
 	}
-
 	void CPU::RES5B() {
 		bit_res(B, 5);
 	}
-
 	void CPU::RES5C() {
 		bit_res(C, 5);
 	}
-
 	void CPU::RES5D() {
 		bit_res(D, 5);
 	}
-
 	void CPU::RES5E() {
 		bit_res(E, 5);
 	}
-
 	void CPU::RES5H() {
 		bit_res(H, 5);
 	}
-
 	void CPU::RES5L() {
 		bit_res(L, 5);
 	}
-
 	void CPU::RES5HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 5);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES5A() {
 		bit_res(A, 5);
 	}
-
 	void CPU::RES6B() {
 		bit_res(B, 6);
 	}
-
 	void CPU::RES6C() {
 		bit_res(C, 6);
 	}
-
 	void CPU::RES6D() {
 		bit_res(D, 6);
 	}
-
 	void CPU::RES6E() {
 		bit_res(E, 6);
 	}
-
 	void CPU::RES6H() {
 		bit_res(H, 6);
 	}
-
 	void CPU::RES6L() {
 		bit_res(L, 6);
 	}
-
 	void CPU::RES6HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 6);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES6A() {
 		bit_res(A, 6);
 	}
-
 	void CPU::RES7B() {
 		bit_res(B, 7);
 	}
-
 	void CPU::RES7C() {
 		bit_res(C, 7);
 	}
-
 	void CPU::RES7D() {
 		bit_res(D, 7);
 	}
-
 	void CPU::RES7E() {
 		bit_res(E, 7);
 	}
-
 	void CPU::RES7H() {
 		bit_res(H, 7);
 	}
-
 	void CPU::RES7L() {
 		bit_res(L, 7);
 	}
-
 	void CPU::RES7HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 7);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::RES7A() {
 		bit_res(A, 7);
 	}
-
 	void CPU::SET0B() {
 		bit_set(B, 0);
 	}
-
 	void CPU::SET0C() {
 		bit_set(C, 0);
 	}
-
 	void CPU::SET0D() {
 		bit_set(D, 0);
 	}
-
 	void CPU::SET0E() {
 		bit_set(E, 0);
 	}
-
 	void CPU::SET0H() {
 		bit_set(H, 0);
 	}
-
 	void CPU::SET0L() {
 		bit_set(L, 0);
 	}
-
 	void CPU::SET0HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 0);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET0A() {
 		bit_set(A, 0);
 	}
-
 	void CPU::SET1B() {
 		bit_set(B, 1);
 	}
-
 	void CPU::SET1C() {
 		bit_set(C, 1);
 	}
-
 	void CPU::SET1D() {
 		bit_set(D, 1);
 	}
-
 	void CPU::SET1E() {
 		bit_set(E, 1);
 	}
-
 	void CPU::SET1H() {
 		bit_set(H, 1);
 	}
-
 	void CPU::SET1L() {
 		bit_set(L, 1);
 	}
-
 	void CPU::SET1HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 1);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET1A() {
 		bit_set(A, 1);
 	}
-
 	void CPU::SET2B() {
 		bit_set(B, 2);
 	}
-
 	void CPU::SET2C() {
 		bit_set(C, 2);
 	}
-
 	void CPU::SET2D() {
 		bit_set(D, 2);
 	}
-
 	void CPU::SET2E() {
 		bit_set(E, 2);
 	}
-
 	void CPU::SET2H() {
 		bit_set(H, 2);
 	}
-
 	void CPU::SET2L() {
 		bit_set(L, 2);
 	}
-
 	void CPU::SET2HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 2);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET2A() {
 		bit_set(A, 2);
 	}
-
 	void CPU::SET3B() {
 		bit_set(B, 3);
 	}
-
 	void CPU::SET3C() {
 		bit_set(C, 3);
 	}
-
 	void CPU::SET3D() {
 		bit_set(D, 3);
 	}
-
 	void CPU::SET3E() {
 		bit_set(E, 3);
 	}
-
 	void CPU::SET3H() {
 		bit_set(H, 3);
 	}
-
 	void CPU::SET3L() {
 		bit_set(L, 3);
 	}
-
 	void CPU::SET3HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 3);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET3A() {
 		bit_set(A, 3);
 	}
-
 	void CPU::SET4B() {
 		bit_set(B, 4);
 	}
-
 	void CPU::SET4C() {
 		bit_set(C, 4);
 	}
-
 	void CPU::SET4D() {
 		bit_set(D, 4);
 	}
-
 	void CPU::SET4E() {
 		bit_set(E, 4);
 	}
-
 	void CPU::SET4H() {
 		bit_set(H, 4);
 	}
-
 	void CPU::SET4L() {
 		bit_set(L, 4);
 	}
-
 	void CPU::SET4HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 4);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET4A() {
 		bit_set(A, 4);
 	}
-
 	void CPU::SET5B() {
 		bit_set(B, 5);
 	}
-
 	void CPU::SET5C() {
 		bit_set(C, 5);
 	}
-
 	void CPU::SET5D() {
 		bit_set(D, 5);
 	}
-
 	void CPU::SET5E() {
 		bit_set(E, 5);
 	}
-
 	void CPU::SET5H() {
 		bit_set(H, 5);
 	}
-
 	void CPU::SET5L() {
 		bit_set(L, 5);
 	}
-
 	void CPU::SET5HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 5);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET5A() {
 		bit_set(A, 5);
 	}
-
 	void CPU::SET6B() {
 		bit_set(B, 6);
 	}
-
 	void CPU::SET6C() {
 		bit_set(C, 6);
 	}
-
 	void CPU::SET6D() {
 		bit_set(D, 6);
 	}
-
 	void CPU::SET6E() {
 		bit_set(E, 6);
 	}
-
 	void CPU::SET6H() {
 		bit_set(H, 6);
 	}
-
 	void CPU::SET6L() {
 		bit_set(L, 6);
 	}
-
 	void CPU::SET6HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 6);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET6A() {
 		bit_set(A, 6);
 	}
-
 	void CPU::SET7B() {
 		bit_set(B, 7);
 	}
-
 	void CPU::SET7C() {
 		bit_set(C, 7);
 	}
-
 	void CPU::SET7D() {
 		bit_set(D, 7);
 	}
-
 	void CPU::SET7E() {
 		bit_set(E, 7);
 	}
-
 	void CPU::SET7H() {
 		bit_set(H, 7);
 	}
-
 	void CPU::SET7L() {
 		bit_set(L, 7);
 	}
-
 	void CPU::SET7HL() {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 7);
 		bus_->Write((H << 8) | L, t);
 		; tTemp += 8;
 	}
-
 	void CPU::SET7A() {
 		bit_set(A, 7);
 	}
-	#pragma endregion
-
 	void CPU::Reset(bool skip) {
 		if (!skip) {
 			A = 0; F = 0;
@@ -2821,7 +2317,6 @@ namespace TKPEmu::Gameboy::Devices {
 		halt_ = false; stop_ = false;
 		JOYP = 0b1110'1111;
 	}
-
 	int CPU::Update() {
 		if (halt_) {
 			PC--;
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 5f0ce857f862e901ebf9f2a3df91fb519b227fa0..81bb742657f603826b7bd13c247c50afa56802c9 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -15,6 +15,8 @@ namespace TKPEmu::Gameboy::Devices {
         TMA = 0;
         oscillator_ = 0;
         timer_counter_ = 0;
+		div_reset_index_ = 0;
+		tima_overflow_ = false;
     }
     bool Timer::Update(uint8_t cycles, uint8_t old_if) {
         if (tima_overflow_) {
@@ -37,29 +39,7 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 			oscillator_ = 0;
 			timer_counter_ = 0;
-			div_reset_index_ = 0;
-		}
-		if (bus_->TACChanged) {
-			bus_->TACChanged = false;
-			uint8_t new_tac = TAC;
-			TAC = old_tac_;
-			int old_freq = interr_times_[TAC & 0b11];
-			TAC = new_tac;
-			if ((old_tac_ >> 2) & 1) {
-				// If old tac was enabled
-				// TODO: prettify timer after its fully implemented
-				if (!((new_tac >> 2) & 1)) {
-					if ((div_reset_index_ & (old_freq / 2)) != 0) {
-						TIMA++;
-					}
-				}
-				else {
-					if ((div_reset_index_ & (old_freq / 2)) != 0 && ((div_reset_index_ & (freq / 2)) == 0)) {
-						TIMA++;
-					}
-				}
-			}
-			old_tac_ = new_tac;
+			div_reset_index_ = -1;
 		}
 		bool enabled = (TAC >> 2) & 0x1;
 		oscillator_ += cycles;

From 76a158045e199998fbb6eec54d5574b91eed37cd Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 5 Dec 2021 21:10:34 +0200
Subject: [PATCH] cpu changes

---
 TKPEmu/gb_tkp/gameboy.cpp | 1 +
 TKPEmu/gb_tkp/gb_cpu.cpp  | 3 ++-
 TKPEmu/gb_tkp/gb_cpu.h    | 2 +-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 0998ffcb6eadfcf0ae5b4215ca6f20152716ab57..0ad5d448e9c8294363b1a36bcfa868533030ab72 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -108,6 +108,7 @@ namespace TKPEmu::Gameboy {
 						for (const auto& bp : Breakpoints) {
 							bool brk = bp.Check();
 							if (brk) {
+								std::cout << "Breakpoint hit - Last PC: " << std::hex << cpu_.LastPC << std::endl;
 								InstructionBreak.store(cpu_.PC);
 								Paused.store(true);
 								broken = true;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 882cc7a638872f975903405521b62a0a1913d257..97a8f70c30cccc905c040f3bb5321225f79ba7a1 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -9,7 +9,7 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP(bus->GetReference(0xFF00))
 	{
 		A = 0; B = 0; C = 0; D = 0; E = 0; H = 0; L = 0;
-		F = 0; SP = 0; PC = 0x0; ime_ = true;
+		F = 0; SP = 0; PC = 0; ime_ = true;
 		TClock = 0;
 		halt_ = false; stop_ = false;
 		bus_->Write(0xFF00, 0b11011111);
@@ -2318,6 +2318,7 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
+		LastPC = PC;
 		if (halt_) {
 			PC--;
 		}
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index b79f6cbc59efd49638b5f864bde8ba377c4b7503..d19690bb48f9d75d0be1809d06b6df15dfc06329 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -138,7 +138,7 @@ namespace TKPEmu::Gameboy::Devices {
 		// CPU registers
 		RegisterType A, B, C, D, E, H, L, F;
 		BigRegisterType PC, SP;
-
+		BigRegisterType LastPC;
 		// Memory mapped registers, they are a reference to a position in memory
 		RegisterType &IF, &IE, &LY, &JOYP;
 

From d86bf30cc6ccae84b53c9f53cad3afedf58203eb Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 6 Dec 2021 02:30:36 +0200
Subject: [PATCH] fix crash when opening different roms

---
 TKPEmu/gb_tkp/gameboy.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 0ad5d448e9c8294363b1a36bcfa868533030ab72..52b45e2c5e1c6a9c9e11f19aaed2b478e9497fee 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -103,6 +103,7 @@ namespace TKPEmu::Gameboy {
 			bool first_instr = true;
 			while (!Stopped.load()) {
 				if (!Paused.load()) {
+					std::lock_guard<std::mutex> lg(DebugUpdateMutex);
 					bool broken = false;
 					if (!first_instr) {
 						for (const auto& bp : Breakpoints) {

From 521f3b6faa36a69c3e4f62e5f11826b03f3b0e1d Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 6 Dec 2021 02:32:04 +0200
Subject: [PATCH] fix segmentation fault

---
 TKPEmu/gb_tkp/gb_bus.cpp          | 5 ++---
 TKPEmu/gb_tkp/gb_disassembler.cpp | 4 ++++
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index a4289afebc722f25a70ec54abdd5eee79ecd2c64..af7f85f7408a30dc85bc5b8cf03300a3f1f7c0d7 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -14,12 +14,12 @@ namespace TKPEmu::Gameboy::Devices {
 			case CartridgeType::MBC1_RAM:
 			case CartridgeType::MBC1_RAM_BATTERY: {
 				if (address <= 0x1FFF) {
-					// Any value "written" here with lower 4 bits == 0xA enables eram,
-					// other values disable eram
 					if (data == 0xA) {
+						std::cout << "RAM enabled (before:" << (int)ram_enabled_ <<  ")" << std::endl;
 						ram_enabled_ = true;
 					}
 					else {
+						std::cout << "RAM disabled (before:" << (int)ram_enabled_ <<  ")" << std::endl;
 						ram_enabled_ = false;
 					}
 				}
@@ -51,7 +51,6 @@ namespace TKPEmu::Gameboy::Devices {
 		unused_mem_area_ = 0;
 		// Return address from ROM banks
 		// TODO: create better exceptions
-		// TODO: make bios optional, can be disabled in settings
 		switch (address & 0xF000) {
 			case 0x0000: {
 				if (BiosEnabled) {
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 8b9289796e0cc7a303e2dc1888781a6ab5a7f20b..3b7e956d9c7f5bfc6299e0cfff00c8950a980573 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -136,12 +136,14 @@ namespace TKPEmu::Applications {
                             if (gameboy->Paused.load()) {
                                 sel_map_[row_n].flip();
                                 if (sel_map_[row_n]) {
+					                std::lock_guard<std::mutex> lg(emulator_->DebugUpdateMutex);
                                     GBBPArguments bp_arg;
                                     bp_arg.PC_using = true;
                                     bp_arg.PC_value = ins.InstructionProgramCode;
                                     gameboy->AddBreakpoint(bp_arg);
                                 }
                                 else {
+					                std::lock_guard<std::mutex> lg(emulator_->DebugUpdateMutex);
                                     auto it = std::find_if(
                                         std::execution::par_unseq,
                                         gameboy->Breakpoints.begin(),
@@ -244,6 +246,7 @@ namespace TKPEmu::Applications {
                 ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
             }
             if (ImGui::Button("Remove", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.15f))) {
+				std::lock_guard<std::mutex> lg(emulator_->DebugUpdateMutex);
                 if (gameboy->Breakpoints[selected_bp].BPFromTable) {
                     // We have to remove the breakpoint selection from the table too
                     sel_map_[gameboy->Breakpoints[selected_bp].Args.PC_value] = false;
@@ -256,6 +259,7 @@ namespace TKPEmu::Applications {
             }
             ImGui::SameLine();
             if (ImGui::Button("Clear", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.15f))) {
+				std::lock_guard<std::mutex> lg(emulator_->DebugUpdateMutex);
                 gameboy->Breakpoints.clear();
                 clear_all_flag = true;
             }

From 8a73fab2dae074ddbbd10777b709c29b1304be1f Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 6 Dec 2021 19:40:54 +0200
Subject: [PATCH] fix execute_interrupt (Fixes #15)

---
 TKPEmu/gb_tkp/gb_bus.cpp   |  3 +++
 TKPEmu/gb_tkp/gb_cpu.cpp   |  2 +-
 TKPEmu/gb_tkp/gb_timer.cpp | 37 +++++++++++++++++++------------------
 3 files changed, 23 insertions(+), 19 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index af7f85f7408a30dc85bc5b8cf03300a3f1f7c0d7..7ccf7b8c17202430be1943b8dc318169ea01aa7d 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -314,6 +314,9 @@ namespace TKPEmu::Gameboy::Devices {
 					case 3: OAM[(address & 0xFF) / 4].flags      = data; break;
 				}
 			}
+			if (address == 0xFFFF) {
+				std::cout << "writing " << std::hex << (int)data << std::endl;
+			}
 			redirect_address(address) = data;
 		}
 	}
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 97a8f70c30cccc905c040f3bb5321225f79ba7a1..fc675b4f94b8a5b053e0cb7605e1ec4ee74be052 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2343,8 +2343,8 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;
 		IF &= ~(1U << bit);
-		bus_->WriteL(SP, PC);
 		SP -= 2;
+		bus_->WriteL(SP, PC);
 		PC = 0x40 + bit * 0x8;
 	}
 }
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 81bb742657f603826b7bd13c247c50afa56802c9..32ef80415b54656baf32e951979bd84431a20947 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -19,6 +19,10 @@ namespace TKPEmu::Gameboy::Devices {
 		tima_overflow_ = false;
     }
     bool Timer::Update(uint8_t cycles, uint8_t old_if) {
+		bool enabled = TAC & 0b100;
+		if (!enabled) {
+			return false;
+		}
         if (tima_overflow_) {
 			// TIMA might've changed in this strange cycle (see the comment below)
 			// If it changes in that cycle, it doesn't update to be equal to TMA
@@ -41,7 +45,6 @@ namespace TKPEmu::Gameboy::Devices {
 			timer_counter_ = 0;
 			div_reset_index_ = -1;
 		}
-		bool enabled = (TAC >> 2) & 0x1;
 		oscillator_ += cycles;
 		// Divider always equals the top 8 bits of the oscillator
 		DIV = oscillator_ >> 8;
@@ -51,23 +54,21 @@ namespace TKPEmu::Gameboy::Devices {
 			TIMA++;
 			div_reset_index_ = -1;
 		}
-		if (enabled) {
-			timer_counter_ += cycles;
-			while (timer_counter_ >= freq) {
-				timer_counter_ -= freq;
-				//timer_counter_ = get_clk_freq();
-				if (TIMA == 0xFF) {
-					/*TIMA = TMA;
-					IF |= 1 << 2;
-					halt_ = false;*/
-					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
-					TIMA = 0;
-					tima_overflow_ = true;
-					return true;
-				}
-				else {
-					TIMA++;
-				}
+		timer_counter_ += cycles;
+		while (timer_counter_ >= freq) {
+			timer_counter_ -= freq;
+			//timer_counter_ = get_clk_freq();
+			if (TIMA == 0xFF) {
+				/*TIMA = TMA;
+				IF |= 1 << 2;
+				halt_ = false;*/
+				// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
+				TIMA = 0;
+				tima_overflow_ = true;
+				return true;
+			}
+			else {
+				TIMA++;
 			}
 		}
 		return false;

From 19b8a106e61a194ef9d800e227f6213f6ebc64a8 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 6 Dec 2021 19:41:48 +0200
Subject: [PATCH] remove test std::couts

---
 TKPEmu/gb_tkp/gb_bus.cpp | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 7ccf7b8c17202430be1943b8dc318169ea01aa7d..1cc31f1ba02436239668f7b21a986aa0feaa8e7c 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -15,11 +15,9 @@ namespace TKPEmu::Gameboy::Devices {
 			case CartridgeType::MBC1_RAM_BATTERY: {
 				if (address <= 0x1FFF) {
 					if (data == 0xA) {
-						std::cout << "RAM enabled (before:" << (int)ram_enabled_ <<  ")" << std::endl;
 						ram_enabled_ = true;
 					}
 					else {
-						std::cout << "RAM disabled (before:" << (int)ram_enabled_ <<  ")" << std::endl;
 						ram_enabled_ = false;
 					}
 				}
@@ -315,7 +313,6 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 			if (address == 0xFFFF) {
-				std::cout << "writing " << std::hex << (int)data << std::endl;
 			}
 			redirect_address(address) = data;
 		}

From 358397af5429bb8dd9fd340671a0b225c06d8c7e Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 7 Dec 2021 02:29:37 +0200
Subject: [PATCH] fixing not cleaning up old threads properly

---
 TKPEmu/gb_tkp/gb_addresses.h   | 11 ++++++++---
 TKPEmu/gb_tkp/gb_cartridge.cpp | 14 ++------------
 TKPEmu/gb_tkp/gb_cartridge.h   |  2 --
 3 files changed, 10 insertions(+), 17 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 84f96cf2c468a5fd49d6e39df278d4d239d63b57..f8184ef5adcf6bbbf5aa79b0e038137b16e010bc 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -50,13 +50,18 @@ struct ExpectedResult {
 // This map helps with quality assurance, we can check multiple test roms
 // at once and compare their finished hashes with these known good results
 const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
-    // cpu_instrs.gb
+    // cpu_instrs
     { "662f04537286d13ee55a6df9de4dce24", { 0, "error-hash" } },
-
-    // /mbc1/bits_bank1.gb
+    // bits_bank1
     { "31d2ad77d05566b1dcb92d7ff7232767", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    // bits_bank2
     { "d7c8eb26b8c276f0d13e2a272a17c308", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    // bits_mode
     { "d807288f6cfe34225989dd0d9293043e", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    // if_ie_registers
+    { "cd20692d8453b777bb2918bef8431117", { 0, "f2ead6ee6dc0a2f45504a43ad6536ba6" } },
+    // div_write
+    { "c57eada752f746347951f79c828391b9", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::A, LogType::B, LogType::C, LogType::D,
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 098a691eefca82871eeee990d176dad4f4a45b14..81de81ba6189adf366c8733c2cd361f21cf8e00c 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -33,16 +33,15 @@ namespace TKPEmu::Gameboy::Devices {
 			is.close();
 			// Empty init the rambanks
 			ramBanks.resize(GetRamSize());
-			PrintHeader();
+		} else {
+			std::cerr << "Error: Could not open file" << std::endl;
 		}
 	}
-
 	CartridgeType Cartridge::GetCartridgeType() {
 		if (loaded) {
 			return (CartridgeType)header_.cartridgeType;
 		}
 	}
-
 	// Returns the number of 8KB RAM banks
 	// TODO: constexpr, return from constexpr array
 	int Cartridge::GetRamSize() {
@@ -54,7 +53,6 @@ namespace TKPEmu::Gameboy::Devices {
 			case 5: return 8;
 		}
 	}
-
 	// Returns the number of 16kb ROM banks
 	int Cartridge::GetRomSize() {
 		switch (header_.romSize) {
@@ -66,12 +64,4 @@ namespace TKPEmu::Gameboy::Devices {
 			return std::pow(2, (header_.romSize + 1));
 		}
 	}
-	void Cartridge::PrintHeader() {
-		std::cout << "Header: {"
-				<< "\nname: " << header_.name
-				<< "\ncartridge_type:" << (int)header_.cartridgeType
-				<< "\nrom_size: " << (int)header_.romSize
-				<< "\nram_size: " << (int)header_.ramSize
-				<< "\n}" << std::endl;
-	}
 }
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
index 7c0cb2b0e81290a6023d28ff7cf9f63d2ff60851..96fef151d762735dc0f5e92f351e875549a57734 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.h
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -54,8 +54,6 @@ namespace TKPEmu::Gameboy::Devices {
 		CartridgeType GetCartridgeType();
 		int GetRamSize();
 		int GetRomSize();
-		// TODO: return string&&, make window that shows the string
-		void PrintHeader();
 	};
 }
 #endif

From b70eca97bab2c0beb3ebaf6a573d2952b5674e63 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 7 Dec 2021 02:30:08 +0200
Subject: [PATCH] see previous commit

---
 TKPEmu/gb_tkp/gameboy.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 52b45e2c5e1c6a9c9e11f19aaed2b478e9497fee..cc4e980cbedf4f53170d3bc2cf6904d9d67a77ac 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -88,6 +88,7 @@ namespace TKPEmu::Gameboy {
 					update();
 				}
 			}
+			std::terminate();
 		};
 		UpdateThread = std::thread(func);
 		UpdateThread.detach();
@@ -95,10 +96,12 @@ namespace TKPEmu::Gameboy {
 	void Gameboy::start_debug() {
 		auto func = [this]() {
 			std::lock_guard<std::mutex> lguard(ThreadStartedMutex);
-			Reset();
+			Loaded = true;
+			Loaded.notify_all();
 			Paused = true;
 			Stopped = false;
 			Step = false;
+			Reset();
 			// Emulation doesn't break on first instruction
 			bool first_instr = true;
 			while (!Stopped.load()) {
@@ -127,7 +130,6 @@ namespace TKPEmu::Gameboy {
 					InstructionBreak.store(cpu_.PC);
 				}
 			}
-			return;
 		};
 		UpdateThread = std::thread(func);
 		UpdateThread.detach();

From 78aa452bf6f0ed65ed7d41e9f5f2cd0ca53901fb Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 7 Dec 2021 03:35:04 +0200
Subject: [PATCH] timer fix

---
 TKPEmu/gb_tkp/gb_cpu.cpp   |  2 +-
 TKPEmu/gb_tkp/gb_cpu.h     |  2 +-
 TKPEmu/gb_tkp/gb_timer.cpp | 11 ++++-------
 3 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index fc675b4f94b8a5b053e0cb7605e1ec4ee74be052..6ca7a11cdd8864c0c499674f1800d9fdcbb98cec 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2325,7 +2325,7 @@ namespace TKPEmu::Gameboy::Devices {
 		(this->*Instructions[bus_->Read(PC++)].op)();
 		handle_interrupts();
 		TClock += tTemp;
-		TotalClocks += tTemp;
+		TotalClocks += 1;
 		return tTemp;
 	}
 	void CPU::handle_interrupts() {
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index d19690bb48f9d75d0be1809d06b6df15dfc06329..bb9ba3fbf69391149a31ca082045e905ecf0d5ae 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -142,7 +142,7 @@ namespace TKPEmu::Gameboy::Devices {
 		// Memory mapped registers, they are a reference to a position in memory
 		RegisterType &IF, &IE, &LY, &JOYP;
 
-		const int ClockSpeed = 4194304;
+		const int ClockSpeed = 4194304 * 4;
 		const int MaxCycles = ClockSpeed / 60;
 		int TClock = 0;
 		unsigned long TotalClocks = 0;
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 32ef80415b54656baf32e951979bd84431a20947..3818068144a97dca7a9e7be60543dd6f892e1fd0 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -20,10 +20,7 @@ namespace TKPEmu::Gameboy::Devices {
     }
     bool Timer::Update(uint8_t cycles, uint8_t old_if) {
 		bool enabled = TAC & 0b100;
-		if (!enabled) {
-			return false;
-		}
-        if (tima_overflow_) {
+        if (tima_overflow_ && enabled) {
 			// TIMA might've changed in this strange cycle (see the comment below)
 			// If it changes in that cycle, it doesn't update to be equal to TMA
 			if (TIMA == 0) {
@@ -38,7 +35,7 @@ namespace TKPEmu::Gameboy::Devices {
         int freq = interr_times_[TAC & 0b11];
 		if (bus_->DIVReset) {
 			bus_->DIVReset = false;
-			if (div_reset_index_ >= freq / 2) {
+			if (div_reset_index_ >= freq / 2 && enabled) {
 				TIMA++;
 			}
 			oscillator_ = 0;
@@ -50,12 +47,12 @@ namespace TKPEmu::Gameboy::Devices {
 		DIV = oscillator_ >> 8;
 		if (div_reset_index_ != -1)
 			div_reset_index_ += cycles;
-		if (div_reset_index_ > freq) {
+		if (div_reset_index_ > freq && enabled) {
 			TIMA++;
 			div_reset_index_ = -1;
 		}
 		timer_counter_ += cycles;
-		while (timer_counter_ >= freq) {
+		while (timer_counter_ >= freq && enabled) {
 			timer_counter_ -= freq;
 			//timer_counter_ = get_clk_freq();
 			if (TIMA == 0xFF) {

From 27e7e73023a7af94dda4ce9671a8b8378c5dde5e Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 7 Dec 2021 20:15:59 +0200
Subject: [PATCH] timer temp commit

---
 TKPEmu/gb_tkp/gameboy.cpp  | 33 +++++++++++++++++++--------------
 TKPEmu/gb_tkp/gameboy.h    |  4 ++++
 TKPEmu/gb_tkp/gb_cpu.cpp   |  1 -
 TKPEmu/gb_tkp/gb_cpu.h     |  4 +---
 TKPEmu/gb_tkp/gb_timer.cpp |  6 +++---
 5 files changed, 27 insertions(+), 21 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index cc4e980cbedf4f53170d3bc2cf6904d9d67a77ac..b93cc8789b736498d531b075ca81a57045dc0bce 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -1,5 +1,6 @@
 #include <iostream>
 #include <atomic>
+#include <chrono>
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
 #include "../lib/md5.h"
@@ -112,7 +113,6 @@ namespace TKPEmu::Gameboy {
 						for (const auto& bp : Breakpoints) {
 							bool brk = bp.Check();
 							if (brk) {
-								std::cout << "Breakpoint hit - Last PC: " << std::hex << cpu_.LastPC << std::endl;
 								InstructionBreak.store(cpu_.PC);
 								Paused.store(true);
 								broken = true;
@@ -147,20 +147,25 @@ namespace TKPEmu::Gameboy {
 		ppu_.Reset();
 	}
 	void Gameboy::update() {
-		if (cpu_.PC == 0x100) {
-			bus_.BiosEnabled = false;
-		}
-		uint8_t old_if = interrupt_flag_;
-		int clk = cpu_.Update();
-		if (timer_.Update(clk, old_if)) {
-			cpu_.halt_ = false;
-		}
-		ppu_.Update(clk);
-		if (cpu_.TClock >= cpu_.MaxCycles) {
-			cpu_.TClock = 0;
-			limit_fps();
+		if ((cpu_.TClock / 2) < cpu_.MaxCycles || FastMode) {
+			if (cpu_.PC == 0x100) {
+				bus_.BiosEnabled = false;
+			}
+			uint8_t old_if = interrupt_flag_;
+			int clk = cpu_.Update();
+			if (timer_.Update(clk, old_if)) {
+				cpu_.halt_ = false;
+			}
+			ppu_.Update(clk);
+			log_state();
+		} else {
+			auto end = std::chrono::system_clock::now();
+			auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(end - frame_start).count();
+			if (dur > 16.6f) {
+				frame_start = std::chrono::system_clock::now();
+				cpu_.TClock = 0;
+			}
 		}
-		log_state();
 	}
 	std::string Gameboy::print() const { 
 		return "GameboyTKP for TKPEmu\n"
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 258d51b3743be3d4b4170adb39b24b44d2da008b..216f0bdcfb7117d38663b71d67320a178fc3a119 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -50,6 +50,10 @@ namespace TKPEmu::Gameboy {
 		GameboyKeys direction_keys_;
 		GameboyKeys action_keys_;
 		uint8_t& joypad_, &interrupt_flag_;
+		std::chrono::system_clock::time_point frame_start = std::chrono::system_clock::now();
+		std::chrono::system_clock::time_point second_start = std::chrono::system_clock::now();
+		int frames = 0;
+		int frame_counter = 0;
 		std::unique_ptr<std::vector<LogType>> log_types_ptr_;
 		void v_log_state() override;
 		void start_normal() override;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 6ca7a11cdd8864c0c499674f1800d9fdcbb98cec..fb9847f11eac35847cce29b85be5134bdb86bbf0 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2318,7 +2318,6 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
-		LastPC = PC;
 		if (halt_) {
 			PC--;
 		}
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index bb9ba3fbf69391149a31ca082045e905ecf0d5ae..164d64797be136154f325993e230f323d960c538 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -138,11 +138,9 @@ namespace TKPEmu::Gameboy::Devices {
 		// CPU registers
 		RegisterType A, B, C, D, E, H, L, F;
 		BigRegisterType PC, SP;
-		BigRegisterType LastPC;
 		// Memory mapped registers, they are a reference to a position in memory
 		RegisterType &IF, &IE, &LY, &JOYP;
-
-		const int ClockSpeed = 4194304 * 4;
+		const int ClockSpeed = 4194304;
 		const int MaxCycles = ClockSpeed / 60;
 		int TClock = 0;
 		unsigned long TotalClocks = 0;
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 3818068144a97dca7a9e7be60543dd6f892e1fd0..233d35c15a6c60b91f9201ebd96cafe0a6d4c7e2 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -20,7 +20,7 @@ namespace TKPEmu::Gameboy::Devices {
     }
     bool Timer::Update(uint8_t cycles, uint8_t old_if) {
 		bool enabled = TAC & 0b100;
-        if (tima_overflow_ && enabled) {
+        if (tima_overflow_) {
 			// TIMA might've changed in this strange cycle (see the comment below)
 			// If it changes in that cycle, it doesn't update to be equal to TMA
 			if (TIMA == 0) {
@@ -35,7 +35,7 @@ namespace TKPEmu::Gameboy::Devices {
         int freq = interr_times_[TAC & 0b11];
 		if (bus_->DIVReset) {
 			bus_->DIVReset = false;
-			if (div_reset_index_ >= freq / 2 && enabled) {
+			if (div_reset_index_ >= freq / 2) {
 				TIMA++;
 			}
 			oscillator_ = 0;
@@ -47,7 +47,7 @@ namespace TKPEmu::Gameboy::Devices {
 		DIV = oscillator_ >> 8;
 		if (div_reset_index_ != -1)
 			div_reset_index_ += cycles;
-		if (div_reset_index_ > freq && enabled) {
+		if (div_reset_index_ > freq) {
 			TIMA++;
 			div_reset_index_ = -1;
 		}

From 6a37e5c92d71be3572de6a957342fb9b75216945 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Tue, 7 Dec 2021 20:25:41 +0200
Subject: [PATCH] cpu_instrs fix

---
 TKPEmu/gb_tkp/gb_timer.cpp | 32 +++++++++++++++++---------------
 1 file changed, 17 insertions(+), 15 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 233d35c15a6c60b91f9201ebd96cafe0a6d4c7e2..5d20b8ba7ad21b8f0664222319cddac602c7ed43 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -51,21 +51,23 @@ namespace TKPEmu::Gameboy::Devices {
 			TIMA++;
 			div_reset_index_ = -1;
 		}
-		timer_counter_ += cycles;
-		while (timer_counter_ >= freq && enabled) {
-			timer_counter_ -= freq;
-			//timer_counter_ = get_clk_freq();
-			if (TIMA == 0xFF) {
-				/*TIMA = TMA;
-				IF |= 1 << 2;
-				halt_ = false;*/
-				// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
-				TIMA = 0;
-				tima_overflow_ = true;
-				return true;
-			}
-			else {
-				TIMA++;
+		if (enabled) {
+			timer_counter_ += cycles;
+			while (timer_counter_ >= freq) {
+				timer_counter_ -= freq;
+				//timer_counter_ = get_clk_freq();
+				if (TIMA == 0xFF) {
+					/*TIMA = TMA;
+					IF |= 1 << 2;
+					halt_ = false;*/
+					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
+					TIMA = 0;
+					tima_overflow_ = true;
+					return true;
+				}
+				else {
+					TIMA++;
+				}
 			}
 		}
 		return false;

From 5652783f1d9d01488ce61a22695e0555b9252fb7 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 11:34:13 +0000
Subject: [PATCH] Gameboy tracelogger qol

---
 TKPEmu/gb_tkp/gameboy.cpp        |  4 ++++
 TKPEmu/gb_tkp/gb_bus.cpp         |  2 ++
 TKPEmu/gb_tkp/gb_bus.h           |  1 +
 TKPEmu/gb_tkp/gb_disassembler.h  |  3 ++-
 TKPEmu/gb_tkp/gb_tracelogger.cpp | 29 ++++++++++++++++++++++-------
 TKPEmu/gb_tkp/gb_tracelogger.h   |  4 ++++
 6 files changed, 35 insertions(+), 8 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index b93cc8789b736498d531b075ca81a57045dc0bce..13614510877bb53faec8a0a577e5b83f94a6f236 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -79,6 +79,10 @@ namespace TKPEmu::Gameboy {
 			}
 			*ofstream_ptr_ << " ";
 		}
+		if (bus_.WriteToVram) {
+			// TODO: add checkbox for this (tracelogger)
+			*ofstream_ptr_ << "(VRAM)";
+		}
 		*ofstream_ptr_ << "\n";
 	}
 	void Gameboy::start_normal() { 
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 1cc31f1ba02436239668f7b21a986aa0feaa8e7c..df13b714dd96ec43e5dae5515ae656ca84c52b17 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -47,6 +47,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	uint8_t& Bus::redirect_address(uint16_t address) {
 		unused_mem_area_ = 0;
+		WriteToVram = false;
 		// Return address from ROM banks
 		// TODO: create better exceptions
 		switch (address & 0xF000) {
@@ -110,6 +111,7 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 			case 0x8000:
 			case 0x9000: {
+				WriteToVram = true;
 				return vram_[address % 0x2000];
 			}
 			case 0xA000:
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 25d661f2b81df7b6788378a83cf0f8aef1f50a0a..b8f8b7b82754a41ab5f4eecfd28686adc7d170ca 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -71,6 +71,7 @@ namespace TKPEmu::Gameboy::Devices {
         std::array<Sprite, 40> OAM;
         bool DIVReset = false;
         bool TACChanged = false;
+        bool WriteToVram = false;
         uint8_t NextMode = 0;
         uint8_t DirectionKeys = 0b1110'1111;
         uint8_t ActionKeys = 0b1101'1111;
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index 808d3ce6bceac9b033e95d0774bfa1e9b91aa315..8435614653baec3cefa4fc9fbdfd336bb5029238 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -6,6 +6,7 @@
 #include <unordered_map>
 // TODO: task.h is deprecated warning
 // TODO: enter press on breakpoint adds breakpoint
+// TODO: list of instructions combo box
 #include <execution>
 #include "../include/base_application.h"
 #include "gb_breakpoint.h"
@@ -47,4 +48,4 @@ namespace TKPEmu::Applications {
         }
     };
 }
-#endif
+#endif
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index 388ba0e0e8d94ef1703f5636573c7ecf326c0f3e..85d461d14ce476827525624cc4a72cb47b4188ca 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -8,17 +8,22 @@ namespace TKPEmu::Applications {
 	GameboyTracelogger::GameboyTracelogger(std::string menu_title, std::string window_title)
 		: IMApplication(menu_title, window_title)
 	{
+        std::fill(available_types_.begin(), available_types_.end(), true);
         std::string path = std::filesystem::current_path();
         if (path.length() < PATH_MAX) {
             strncpy(path_buf_, path.data(), PATH_MAX);
         } else {
             std::cerr << "Error: Executable path too long" << std::endl;
+            exit(1);
         }
     }
 	void GameboyTracelogger::v_draw() {
         static bool path_changed = false;
         static bool file_exists = false;
         static bool overwrite = false;
+        if (is_logging_) {
+            push_disabled();
+        }
         if (ImGui::InputText("##path", &(path_buf_[0]), PATH_MAX, ImGuiInputTextFlags_EnterReturnsTrue)) {
             ready_to_log_ = false;
             path_changed = true;
@@ -30,22 +35,24 @@ namespace TKPEmu::Applications {
             path_changed = true;
             overwrite = false;
         }
+        if (is_logging_) {
+            pop_disabled();
+        }
         if (path_changed) {
             path_changed = false;
             if (std::filesystem::is_directory(path_buf_)) {
-                std::cout << "Error: Path is directory" << std::endl;
+                std::cerr << "Error: Path is directory" << std::endl;
             } else if (!overwrite && std::filesystem::exists(path_buf_)) {
                 file_exists = true;
                 ImGui::OpenPopup("Overwrite?");
             } else {
+                std::filesystem::create_directories(std::filesystem::path(path_buf_).parent_path());
                 ready_to_log_ = true;
                 log_path_ = path_buf_;
             }
         }
         if (!ready_to_log_) {
-            // This push makes the button seem disabled
-            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.6f);
-            ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+            push_disabled();
         }
         if (!is_logging_) {
             if (ImGui::Button("Start logging")) {
@@ -55,6 +62,7 @@ namespace TKPEmu::Applications {
                     is_logging_ = true;
                 } else {
                     std::cerr << "Error: Emulator is nullptr" << std::endl;
+                    exit(1);
                 }
             }
         } else {
@@ -64,13 +72,12 @@ namespace TKPEmu::Applications {
                     is_logging_ = false;
                 } else {
                     std::cerr << "Error: Emulator is nullptr" << std::endl;
+                    exit(1);
                 }
             }
         }
         if (!ready_to_log_) {
-            // Pop disabled
-            ImGui::PopItemFlag();
-            ImGui::PopStyleVar();
+            pop_disabled();
         }
 		ImGui::NewLine();
 		ImGui::TextUnformatted("Memory to log:");
@@ -107,4 +114,12 @@ namespace TKPEmu::Applications {
 		}
 		static_cast<Gameboy*>(emulator_)->SetLogTypes(std::move(ptr));
 	}
+    void GameboyTracelogger::push_disabled() {
+        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.6f);
+        ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+    }
+    void GameboyTracelogger::pop_disabled() {
+            ImGui::PopItemFlag();
+            ImGui::PopStyleVar();
+    }
 }
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.h b/TKPEmu/gb_tkp/gb_tracelogger.h
index c507ce909bf5c4091daca855408798ad78013b1c..382d582652f4d8f7bf636c036525a757403ecfc6 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.h
+++ b/TKPEmu/gb_tkp/gb_tracelogger.h
@@ -1,6 +1,8 @@
 #pragma once
 #ifndef TKP_GB_TRACELOGGER_H
 #define TKP_GB_TRACELOGGER_H
+// TODO: if no selected registers, show message
+// TODO: writes to vram have special string
 #include <array>
 #include "../include/base_application.h"
 #include "gameboy.h"
@@ -18,6 +20,8 @@ namespace TKPEmu::Applications {
         bool is_logging_ = false;
 		void v_draw() override;
 		void set_logtypes();
+		void push_disabled();
+		void pop_disabled();
 	};
 }
 #endif

From dfb0aa34370a52ec3986ee5ba07a7c501e928f7d Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 12:08:36 +0000
Subject: [PATCH] writing down passed tests

---
 TKPEmu/gb_tkp/README.md      | 61 +++++++++++++++++++++++++++-----------------
 TKPEmu/gb_tkp/gb_cartridge.h |  1 +
 2 files changed, 39 insertions(+), 23 deletions(-)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index 9ba915aad56e2b64e724934078f6f356ce535189..fd80d2f2d82f3503f08e50dd1cec9b062b23cebe 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -23,29 +23,44 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 
 |Test| GameboyTKP |
 |--|--|
-| bits/mem_oam |  |
-| bits/reg_f |  |
-| bits/unused_hwio_GS |  |
-| instr/daa |  |
-| interrupts/ie_push |  |
-| oam_dma/basic |  |
-| oam_dma/reg_read |  |
-| oam_dma/sources-GS |  (needs MBC5)|
-| ppu/... |  (untested)|
-| serial/... |  (untested)|
-| timer/div_write |  |
-| timer/rapid_toggle |  |
-| timer/tim00 |  |
-| timer/tim00_div_trigger |  |
-| timer/tim01 |  (Issue [#4](https://github.com/OFFTKP/TKPEmu/issues/4))|
-| timer/tim01_div_trigger |  |
-| timer/tim10 |  |
-| timer/tim10_div_trigger |  |
-| timer/tim11 |  |
-| timer/tim11_div_trigger |  |
-| timer/tima_reload |  |
-| timer/tima_write_reloading |  |
-| timer/tma_write_reloading |  |
+| acceptance/div_timing |  |
+| acceptance/if_ie_registers |  |
+| acceptance/boot_regs-dmgABC |  |
+| acceptance/bits/mem_oam |  |
+| acceptance/bits/reg_f |  |
+| acceptance/bits/unused_hwio_GS |  |
+| acceptance/instr/daa |  |
+| acceptance/interrupts/ie_push |  |
+| acceptance/oam_dma/basic |  |
+| acceptance/oam_dma/reg_read |  |
+| acceptance/ppu/... |  (untested)|
+| acceptance/serial/... |  (untested)|
+| acceptance/timer/div_write |  |
+| acceptance/timer/rapid_toggle |  |
+| acceptance/timer/tim00 |  |
+| acceptance/timer/tim00_div_trigger |  |
+| acceptance/timer/tim01 |  |
+| acceptance/timer/tim01_div_trigger |  |
+| acceptance/timer/tim10 |  |
+| acceptance/timer/tim10_div_trigger |  |
+| acceptance/timer/tim11 |  |
+| acceptance/timer/tim11_div_trigger |  |
+| acceptance/timer/tima_reload |  |
+| acceptance/timer/tima_write_reloading |  |
+| acceptance/timer/tma_write_reloading |  |
+| emulator-only/mbc1/bits_bank1 |  | 
+| emulator-only/mbc1/bits_bank2 |  | 
+| emulator-only/mbc1/bits_mode |  | 
+| emulator-only/mbc1/bits_ramg |  | 
+| emulator-only/mbc1/multicart_rom_8Mb |  | 
+| emulator-only/mbc1/ram_256kb |  | 
+| emulator-only/mbc1/ram_64kb |  | 
+| emulator-only/mbc1/rom_16Mb |  | 
+| emulator-only/mbc1/rom_1Mb |  (multicart) | 
+| emulator-only/mbc1/rom_2Mb |  (multicart) | 
+| emulator-only/mbc1/rom_4Mb |  | 
+| emulator-only/mbc1/rom_512kb |  |
+| emulator-only/mbc1/rom_8Mb |  | 
 
 **[mattcurie](https://github.com/mattcurrie)'s tests:**
 |Test|GameboyTKP  |
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
index 96fef151d762735dc0f5e92f351e875549a57734..7fb37f635aaf5bc23f5f8ce41d279f82dc2c223e 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.h
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -1,6 +1,7 @@
 #pragma once
 #ifndef TKP_GB_CARTRIDGE_H
 #define TKP_GB_CARTRIDGE_H
+// TODO: fix crashes when loading bad roms (utils)
 #include <string>
 #include <vector>
 #include <array>

From 3082bd44d0e37384d66522f3a46783584bb491eb Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 13:02:00 +0000
Subject: [PATCH] pass ei_timing/sequence/halt_ime0_ei

---
 TKPEmu/gb_tkp/README.md  |  3 +++
 TKPEmu/gb_tkp/gb_cpu.cpp | 15 +++++++++++----
 TKPEmu/gb_tkp/gb_cpu.h   |  1 +
 3 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index fd80d2f2d82f3503f08e50dd1cec9b062b23cebe..1a2f4aad5490292621909d0dbcaa7108d045055c 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -24,6 +24,9 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 |Test| GameboyTKP |
 |--|--|
 | acceptance/div_timing |  |
+| acceptance/ei_timing |  |
+| acceptance/ei_sequence |  |
+| acceptance/halt_ime0_ei |  |
 | acceptance/if_ie_registers |  |
 | acceptance/boot_regs-dmgABC |  |
 | acceptance/bits/mem_oam |  |
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index fb9847f11eac35847cce29b85be5134bdb86bbf0..807c6045555a1cfa8d262af21c6a81ef3da4628a 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1101,7 +1101,7 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::RET() {
 		PC = bus_->ReadL(SP);
 		SP += 2;
-		tTemp = 12;
+		tTemp = 16;
 	}
 	void CPU::RETI() {
 		ime_ = true;
@@ -1174,10 +1174,12 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::DI() {
-		ime_ = false; tTemp = 4;
+		ime_ = false;
+		tTemp = 4;
 	}
 	void CPU::EI() {
-		ime_ = true; tTemp = 4;
+		ime_scheduled_ = true;
+		tTemp = 4;
 	}
 	void CPU::RLA() {
 		bool carry = F & FLAG_CARRY_MASK;
@@ -1396,7 +1398,10 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::HALT() {
-		halt_ = true;
+		if (ime_scheduled_)
+			ime_ = true;
+		else
+			halt_ = true;
 	}
 	void CPU::XXX() {
 		stop_ = true;
@@ -2323,6 +2328,8 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
 		handle_interrupts();
+		if (ime_scheduled_)
+			ime_ = true;
 		TClock += tTemp;
 		TotalClocks += 1;
 		return tTemp;
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 164d64797be136154f325993e230f323d960c538..7bf2568fb529925009f135f22207f0b42d713fc1 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -15,6 +15,7 @@ namespace TKPEmu::Gameboy::Devices {
 	private:
 		Bus* bus_;
 		bool ime_ = false;
+		bool ime_scheduled_ = false;
 		int tTemp = 0;
 		int div_reset_index_ = -1;
 		int old_tac_ = 0;

From f10911154493e91ad427a65a6e6fcf88c33291f6 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 13:57:42 +0000
Subject: [PATCH] added todo

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 807c6045555a1cfa8d262af21c6a81ef3da4628a..012e04a844bfc31029b57cec5909a48ce3ee4afb 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2336,6 +2336,9 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::handle_interrupts() {
 		if (auto temp = IE & IF; ime_ && IF) {
+			//if (halt_) {
+			//	PC += 1;
+			//} TODO: fix halt_ime1_timing.gb (works in other emu)
 			// Starting from the lowest bit (highest priority) and going up,
 			// we are effectively queueing interrupts in case there's multiple.
 			for (int i = 0; i < 5; i++) {

From d6410bed2ef7c6104f80c459019a0b0ae596937b Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 21:13:41 +0200
Subject: [PATCH] identation changes

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index fb9847f11eac35847cce29b85be5134bdb86bbf0..06df76f49e68abcecbf9a7911a77c7cbf4d0b428 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1114,7 +1114,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x80) == 0x00) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RETZ() {
@@ -1122,7 +1122,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x80) == 0x80) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RETNC() {
@@ -1130,7 +1130,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x10) == 0x00) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RETC() {
@@ -1138,7 +1138,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x10) == 0x10) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RST0() {

From 5b257d7065ca0b2641b7671673ad7722157e9129 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 21:29:46 +0200
Subject: [PATCH] massive drmario/other basic game fixes

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 127 ++++++++++++++++++-----------------------------
 TKPEmu/gb_tkp/gb_cpu.h   |  46 +++++++++--------
 2 files changed, 71 insertions(+), 102 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 012e04a844bfc31029b57cec5909a48ce3ee4afb..3ddfe75cde4f05e6194699f671546278571568d0 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -14,32 +14,28 @@ namespace TKPEmu::Gameboy::Devices {
 		halt_ = false; stop_ = false;
 		bus_->Write(0xFF00, 0b11011111);
 	}
-	inline void CPU::reg_dec(RegisterType& reg) {
+	void CPU::reg_dec(RegisterType& reg) {
 		auto temp = reg - 1;
 		auto flag = FLAG_NEG_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
 		flag |= (((reg & 0xF) - (1 & 0xF)) < 0) << FLAG_HCARRY_SHIFT;
-		// Carry doesn't reset after DEC
 		F &= FLAG_CARRY_MASK;
 		F |= flag;
 		reg = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_inc(RegisterType& reg) {
+	void CPU::reg_inc(RegisterType& reg) {
 		auto temp = reg + 1;
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
 		flag |= (((reg & 0xF) + (1 & 0xF)) > 0xF) << FLAG_HCARRY_SHIFT;
-		// Carry doesn't reset after INC 
 		F &= FLAG_CARRY_MASK;
 		F |= flag;
 		temp &= 0xFF;
 		reg = temp;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_sub(RegisterType& reg) {
+	void CPU::reg_sub(RegisterType& reg) {
 		auto temp = A - reg;
 		auto flag = FLAG_NEG_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -49,8 +45,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_sbc(RegisterType& reg) {
+	void CPU::reg_sbc(RegisterType& reg) {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = A - reg - carry;
 		auto flag = FLAG_NEG_MASK;
@@ -61,8 +56,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_and(RegisterType& reg) {
+	void CPU::reg_and(RegisterType& reg) {
 		auto temp = A & reg;
 		auto flag = FLAG_HCARRY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -70,8 +64,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_add(RegisterType& reg) {
+	void CPU::reg_add(RegisterType& reg) {
 		auto temp = A + reg;
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -81,8 +74,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_adc(RegisterType& reg) {
+	void CPU::reg_adc(RegisterType& reg) {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = A + reg + carry;
 		auto flag = FLAG_EMPTY_MASK;
@@ -93,8 +85,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_cmp(RegisterType& reg) {
+	void CPU::reg_cmp(RegisterType& reg) {
 		auto temp = A - reg;
 		auto flag = FLAG_NEG_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -103,8 +94,7 @@ namespace TKPEmu::Gameboy::Devices {
 		F = flag;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_or(RegisterType& reg) {
+	void CPU::reg_or(RegisterType& reg) {
 		auto temp = A | reg;
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -112,8 +102,7 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::reg_xor(RegisterType& reg) {
+	void CPU::reg_xor(RegisterType& reg) {
 		auto temp = A ^ reg;
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -121,8 +110,21 @@ namespace TKPEmu::Gameboy::Devices {
 		A = temp & 0xFF;
 		tTemp = 4;
 	}
-
-	inline void CPU::hl_add(BigRegisterType& big_reg) {
+	void CPU::big_reg_inc(RegisterType& big_reg, RegisterType& small_reg) {
+		++small_reg;
+		if (small_reg == 0) {
+			++big_reg;
+		}
+		tTemp = 8;
+	}
+	void CPU::big_reg_dec(RegisterType& big_reg, RegisterType& small_reg) {
+		--small_reg;
+		if (small_reg == 0xFF) {
+			--big_reg;
+		}
+		tTemp = 8;
+	}
+	void CPU::hl_add(BigRegisterType& big_reg) {
 		uint16_t t = (H << 8) | L;
 		auto temp = t + big_reg;
 		auto flag = FLAG_EMPTY_MASK;
@@ -135,8 +137,7 @@ namespace TKPEmu::Gameboy::Devices {
 		L = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_ch(RegisterType reg, unsigned shift) {
+	void CPU::bit_ch(RegisterType reg, unsigned shift) {
 		auto temp = reg & (1 << shift);
 		auto flag = FLAG_HCARRY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -144,13 +145,11 @@ namespace TKPEmu::Gameboy::Devices {
 		F |= flag;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_res(RegisterType& reg, unsigned shift) {
+	void CPU::bit_res(RegisterType& reg, unsigned shift) {
 		reg &= ~(1 << shift);
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_swap(RegisterType& reg) {
+	void CPU::bit_swap(RegisterType& reg) {
 		auto temp = ((reg & 0xF0) >> 4) | ((reg & 0x0F) << 4);
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -158,8 +157,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_rrc(RegisterType& reg) {
+	void CPU::bit_rrc(RegisterType& reg) {
 		auto temp = (reg >> 1) + ((reg & 0x1) << 7) + ((reg & 0x1) << 8);
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -168,8 +166,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_rl(RegisterType& reg) {
+	void CPU::bit_rl(RegisterType& reg) {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = (reg << 1) + carry;
 		auto flag = FLAG_EMPTY_MASK;
@@ -179,8 +176,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_rr(RegisterType& reg) {
+	void CPU::bit_rr(RegisterType& reg) {
 		bool carry = F & FLAG_CARRY_MASK;
 		auto temp = (reg >> 1) + (carry << 7) + ((reg & 0x1) << 8);
 		auto flag = FLAG_EMPTY_MASK;
@@ -190,8 +186,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_sl(RegisterType& reg) {
+	void CPU::bit_sl(RegisterType& reg) {
 		auto temp = (reg << 1);
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -200,8 +195,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_sr(RegisterType& reg) {
+	void CPU::bit_sr(RegisterType& reg) {
 		auto temp = ((reg >> 1) | (reg & 0x80)) + ((reg & 0x1) << 8);
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -210,8 +204,7 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::bit_srl(RegisterType& reg) {
+	void CPU::bit_srl(RegisterType& reg) {
 		auto temp = (reg >> 1) + ((reg & 0x1) << 8);
 		auto flag = FLAG_EMPTY_MASK;
 		flag |= ((temp & 0xFF) == 0) << FLAG_ZERO_SHIFT;
@@ -220,15 +213,13 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
-
-	inline void CPU::rst(RegisterType addr) {
+	void CPU::rst(RegisterType addr) {
 		SP -= 2;
 		bus_->WriteL(SP, PC);
 		PC = addr;
 		tTemp = 16;
 	}
-
-	inline void CPU::bit_set(RegisterType& reg, unsigned shift) {
+	void CPU::bit_set(RegisterType& reg, unsigned shift) {
 		reg |= 1 << shift;
 		tTemp = 8;
 	}
@@ -852,54 +843,29 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 12;
 	}
 	void CPU::INCBC() {
-		// TODO: big reg inc
-		C = (C + 1) & 0xFF;
-		if (!C) {
-			B = (B + 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_inc(B, C);
 	}
 	void CPU::INCDE() {
-		E = (E + 1) & 0xFF;
-		if (!E) {
-			D = (D + 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_inc(D, E);
 	}
 	void CPU::INCHL() {
-		L = (L + 1) & 0xFF;
-		if (!L) {
-			H = (H + 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_inc(H, L);
 	}
 	void CPU::INCSP() {
-		SP++;
+		++SP;
 		tTemp = 8;
 	}
 	void CPU::DECBC() {
-		C = (C - 1) & 0xFF;
-		if (C == 0xFF) {
-			B = (B - 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_dec(B, C);
 	}
 	void CPU::DECDE() {
-		E = (E - 1) & 0xFF;
-		if (E == 0xFF) {
-			D = (D - 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_dec(D, E);
 	}
 	void CPU::DECHL() {
-		L = (L - 1) & 0xFF;
-		if (L == 0xFF) {
-			H = (H - 1) & 0xFF;
-		}
-		tTemp = 8;
+		big_reg_dec(H, L);
 	}
 	void CPU::DECSP() {
-		SP = (SP - 1) & 0xFFFF;
+		--SP;
 		tTemp = 8;
 	}
 	void CPU::JP16() {
@@ -1114,7 +1080,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x80) == 0x00) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RETZ() {
@@ -1122,7 +1088,7 @@ namespace TKPEmu::Gameboy::Devices {
 		if ((F & 0x80) == 0x80) {
 			PC = bus_->ReadL(SP);
 			SP += 2;
-			; tTemp += 12;
+			tTemp += 12;
 		}
 	}
 	void CPU::RETNC() {
@@ -1175,6 +1141,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::DI() {
 		ime_ = false;
+		ime_scheduled_ = false;
 		tTemp = 4;
 	}
 	void CPU::EI() {
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 7bf2568fb529925009f135f22207f0b42d713fc1..6bf968f29a98d645a1771ed3651029b1ad7cd7db 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -63,28 +63,30 @@ namespace TKPEmu::Gameboy::Devices {
 		void XXX();
 
 		// Helper functions that also deal with the flags
-		inline void reg_dec(RegisterType& reg);
-		inline void reg_inc(RegisterType& reg);
-		inline void reg_sub(RegisterType& reg);
-		inline void reg_sbc(RegisterType& reg);
-		inline void reg_and(RegisterType& reg);
-		inline void reg_add(RegisterType& reg);
-		inline void reg_adc(RegisterType& reg);
-		inline void reg_cmp(RegisterType& reg);
-		inline void reg_or (RegisterType& reg);
-		inline void reg_xor(RegisterType& reg);
-		inline void hl_add(BigRegisterType& big_reg);
-		inline void bit_ch(RegisterType reg, unsigned shift);
-		inline void bit_res(RegisterType& reg, unsigned shift);
-		inline void bit_set(RegisterType& reg, unsigned shift);
-		inline void bit_swap(RegisterType& reg);
-		inline void bit_rrc(RegisterType& reg);
-		inline void bit_rl(RegisterType& reg);
-		inline void bit_rr(RegisterType& reg);
-		inline void bit_sl(RegisterType& reg);
-		inline void bit_sr(RegisterType& reg);
-		inline void bit_srl(RegisterType& reg);
-		inline void rst(RegisterType addr);
+		void reg_dec(RegisterType& reg);
+		void reg_inc(RegisterType& reg);
+		void reg_sub(RegisterType& reg);
+		void reg_sbc(RegisterType& reg);
+		void reg_and(RegisterType& reg);
+		void reg_add(RegisterType& reg);
+		void reg_adc(RegisterType& reg);
+		void reg_cmp(RegisterType& reg);
+		void reg_or (RegisterType& reg);
+		void reg_xor(RegisterType& reg);
+		void big_reg_inc(RegisterType& big_reg, RegisterType& small_reg);
+		void big_reg_dec(RegisterType& big_reg, RegisterType& small_reg);
+		void hl_add(BigRegisterType& big_reg);
+		void bit_ch(RegisterType reg, unsigned shift);
+		void bit_res(RegisterType& reg, unsigned shift);
+		void bit_set(RegisterType& reg, unsigned shift);
+		void bit_swap(RegisterType& reg);
+		void bit_rrc(RegisterType& reg);
+		void bit_rl(RegisterType& reg);
+		void bit_rr(RegisterType& reg);
+		void bit_sl(RegisterType& reg);
+		void bit_sr(RegisterType& reg);
+		void bit_srl(RegisterType& reg);
+		void rst(RegisterType addr);
 		void handle_interrupts();
 		void execute_interrupt(int bit);
 		void update_timers(int cycles);

From 2c1c4139615411b76ff63bceb43e6f8694a0b5df Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 21:46:58 +0200
Subject: [PATCH] final commit of branch

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 3ddfe75cde4f05e6194699f671546278571568d0..13127fd7592ee852a5ed6fb666b7931001100c19 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2287,6 +2287,7 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		TClock = 0;
 		halt_ = false; stop_ = false;
+		ime_ = false;
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {

From 5c804c5f10855872cfa388d061ecc8e33fb65bac Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 19:49:26 +0000
Subject: [PATCH] Merge pull request #17 from OFFTKP/ei_fix

Ei fix - bunch of roms start now - instr_timing gets past timer check

From 3eec14e09f301b728a975023c932fe473cc77916 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 9 Dec 2021 23:26:12 +0200
Subject: [PATCH] Added images for gameboy readme

---
 TKPEmu/gb_tkp/Images/sml.bmp | Bin 0 -> 69174 bytes
 TKPEmu/gb_tkp/Images/tet.bmp | Bin 0 -> 69174 bytes
 TKPEmu/gb_tkp/README.md      |   6 +++++-
 3 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/Images/sml.bmp b/TKPEmu/gb_tkp/Images/sml.bmp
new file mode 100644
index 0000000000000000000000000000000000000000..b566e5633e407d033501593a85f6a0f18afbdfec
GIT binary patch
literal 69174
zcmeHP+mYNx43rY^w?l9Q`gZBxIVl8(;2@lzjXl)0TA1PNyqDxQtB%!!X*4hma!<OF
z?)zWge*606aecF|KkVxt`}*6yzJB@L?)mFaU2;GUT-Jdfx^C^jWgkp6Ugf~8A6^~q
zN7X|h(q$d^SC<@+0~dF|K7MclVYlK=KBOnYxDD`06=w$=U&SAEewBvR=hFwwEYc+h
z<bWKI11EIgKV7$W;DnEyTAJuU`Qf!fWkT3p%@5@|mTsLT0<cJH|D1a{+;P~}lve(@
zhgOmQ8psVW9xrrqg}%eKX0`ICn1=ZpfZ$6yLG{g``>?Hvt^7eBtlZHxsC=PxbD+E1
z*4$QpcVnLD!!?|OLFKEY4;tQ@-pU`eF&!%+gUXjkA9uS|p_M;wqYsqt<C>RHm|}IS
zNGpGelNxTfjji))<##t05?@s}w6SM7@vyB@t^6s5yrk%q&O1cL56cQi_^2`FA93c!
z_g9?T|9&-g><Axq#rz}A#Q5fN6FYy26zp<fcL&x?3bGx7mff8j+*xaG=dV(OV+O*7
zmMjjOg7R+4?~ZIM)ZO7Z6WKS%X{69OlMA%Ltvyu+n>=m0x#t%;{0x-dTqhe7S&P7i
z5{o*&f$VDYSL@$k1WS*w)c>X8OKrKdINN@N#}CNL<7!f<cYvKg!u4udCd+0C3a)Sf
zwmY!91FMyS?gk*$t#GHroo=9(fpEc6ivxFn!Ss%b=TF(`3D<I*M!Fqiscw;5Chl~`
zYWW2xKLdJmVaa@8CeIh$rFiM)cbW9_4>{W^PAR0}*4ubFuP)bc{VWzSFXY&TT3s}(
zKG{q7c8MnY{NIpua`#T&-i85<mpHA5*~YTLaTD&Xa6;3LTC%uZ{2K}HJ(`ZwxkY?8
z5nFahElMdg<85QUI0YgGJh-U0b+R}MKu0ah^(;2QgV^ejotRQ?!`t?0GQRqJacVyl
zX4GmdbT|<~0N&k+D;vP?gW|CQn@FY3&ZCuUWgE^0D|H?g(7TK*1QFQ=DoYy;|99JG
zY8_&@-fgASwxc~QgoX_;ewr8v$hG)~(&OWrgXuCTELw&h3RS#q8?ghMtO48$iD%xj
zBcMG$mn}Jn-7@eLB!(q&K|o|FXewu9zA#x2F70!jxHWI$eh0v^zAjP>FisV)n{LgG
z^c8w^Pao9yj%>lX?d?%R+mBOy9s!`KhYx{YZb#{T`bTQnct;6u9p8fSLCr_X);f8R
z`**ydVJoz*N}sr&o#*Q#Mx;-6-7!zDyvVK*S<A(1i?IUOu3aa0^;GRmw`*MRF~ZO9
zzYIRYkK3sXJbyD29h)Nc7-8<hTYP>?&(@*YIo{F~5pN@m*Mk0`?IRv<^$isUr!$yd
zW4PYm8kY*3?iqC_7Mju43I{qS)seEIb7@vO&@`_ma%BUet#+VtYL&Fr-Acd1fv2;3
zO6Vx6l${O~CRo_o*`aC;I*^@XHaJ*F>92AiOfxKB)s^Z_bO192m?$o(GdN(A)o{-+
z2=yQb<bWKI19CtP$N@PZ2jqYpkOOi+4#)vHAP3}t9FPNYKn}<OIUon*fE<tmazGBq
z0XZNC<bWKI19CtP$N@PZ2jqYpkOOla@P9CmJH!!j&>csjz)lBveE5AD7^MLO9dz(_
z9!Is<0gMlTr<o06%FHYTZOe4HsPG;K3gb&>HyF`~_skSkj)rT5bd<=-Ze@d>f-TJ#
z9&Q8h+@}!gVl=bjC>I2^T<1X9a~rXj<_7@5v@2`{zQ@b8QZ+@UIAFFvbv_KPm2Z7M
zO__2Qi5xjl<3GQZEBHsfDL%!4nvq!{&;ZKSjaJDl>u7h-fx;9%M)deQEOQu#(pi4s
zXu02k?8p!VKx1jdwh#mWU*P2q*id*bjI+Ic(0~4T>M1`fqTpr+d}{T>YUOV}j>^da
zIUon*z&kkLKL^nLt`5AzGyKkHyz6tTbGZZW{A|C&+4Y>?+ktm@hTr*&_kMbHIyoQ*
z<bWKI19CtP$N@PZ2jqYpkOOky9UQpU&vx`rYc|XaCObgI5VvJ^3qb>%!tpFNGTyi#
z4nD^V`b~8UI;a~!tA0rLC5tRNSGF#KXdv_h0>|rdNJpX%*NOsw>BrBSfOPCKFpMSC
zvY?)sR?G_42fZ}<<W6dEeWAb%b!`_B10dJ*z#JqpFoKQMBaZDJ2)s1RngK(H;~_mP
zvrG>bwt`6C5>-5%%hlkHqNr#fO~>xUeoV74UvDEc<87opSj4xOke(t$vgCqJmLD{q
zF0=ZqoMNOr6@N+yQnvJzG#<8?mf~z(Q}B;v+YO)35Vx&>u{6M#iz1$_+sf?Y7fRdK
zNAJJ%kDh&ti<YHoc2SPSxx{!p+lI;dWbJM^%Lzg6q`se!&dXGUcT?QTKT^OEn1G;x
znmBXLjB&0rH>uv_z)lDF9rqW+t0NxXn!o|gvcTlvQJgu93w+iODc*C<ofBOUS*#y|
zzGOa=3vuX_0V{yXB{;~~IKE^utASv&Y#fQK<7AKUofQJ#Q$jfp9x1R|XoFLlFf@Z8
z;@*-iT^4afLOfIl%@eT<w6Jt?2--4@vmoy>W*z6_?f}Z3<#*5G2*?m*Ci7E_2yzjD
zY*6!M2!`~hOBP|NGDa5knUA0Wi~BN7VOqciH3&l1fCo8?F^hYg@2uleoO^_kWrS2e
zyX(w)K8u7bu2{xg)UYotWdw7@Ac!S%Qq0wPH;sFQ@6P9lVTgF#mLPx+01jxp<+vsi
zbdYFq##m<g9s~!8m4Fk2KDJupTsnwg$($5(Mcz&0h&Zsj^AYEC!yq_Lmm$%YxU(99
u25REWVLVHRHG#P|FT`6YoedUppYlNn02Kj1KqS-+1Ya`QF=zsJb>M%}HlfA<

literal 0
HcmV?d00001

diff --git a/TKPEmu/gb_tkp/Images/tet.bmp b/TKPEmu/gb_tkp/Images/tet.bmp
new file mode 100644
index 0000000000000000000000000000000000000000..99ed1135169e3de80f8b5e0f82f48daf3d58570a
GIT binary patch
literal 69174
zcmeI2(a|GGZiMd~(6dZ93+`E=clop?oCz{w?bGR-&HZyTP*oTff0Er~PY0(afdUc<
zpvjw9>A(Nypa1dqzx{ar$)A7l=YRS0FaG@fZ~w_TfBtLs{NKO-J#*jVgKGM@hwDK(
zzyJRGZ@>M<>E{mO2af2D>fcO3eD<CgX3Xh)aF&PQ>2ft3(;7&&O@rQFief5$<u@&W
z7*6xcbO8Ppe)s))#q^jsTlO?GpXofwoqoilM4dTjPgTGHQ$KZ+$EJa9Z35uYIpy~i
ziP?L>S@gXyjWmMYzJ`OTU_g2BPnRox(sN>%;u&Y&`zh)|0GS37U=tvIpBZl_z<yH3
zM=gy0;z`2S;38mZYV2HDlCc5p=PiCb<-w`(j;DB32p*Z70`lC5DN3YD0Aw1Be#nWj
z_);scAknRZ<-vp&+&>DFfR~*T+zUgD!UPhNm=h2d8@N39SAB6++P5%3dBk6wn64{O
zOvFt6<{<#=Fqyg)CS6s=Ip9h15tFFiRRY3iKUs0qlb&8YJUpls;8gCYAHRAWPp+J9
zARe0ry?<Jll*Vsnf#fI4xAITVeng}|LJTK_Q-+5-rCddOa>cm!(yvW{UO!aRPcPu9
zx0Y?7a?`%-BqlLU^&$x-M#Gs-;Ned6P!3v3_u5oi?GULHX93{Rtz%Y%yIrh!Uf`eh
zmAx0-OM;E~)9$wspPSX96$~y9{yX+tNH80Iu2%75Y4NQ5tG<*~PDqNUm?z&a@(}En
zjRDLPzfJ|HwdtJ4VfG&Ji_o+M6qCC06n|NPO#{W-oc6VvgR`=9ViJjwHoyx$RHqz;
zq&dYD>=*&X+liTvS`axnADm=ueZ=ELn+9UDX)yZnaO=mWfv#+3Q(zh)0KiF%ZjGIV
zXZjFNj7R`4_#lIF6q4qtDmjU1Zb^qn{pwUO&hp^j?TZvhoM_WPgf<OEf9b-e0l7Rj
zSA8k0oX#qKo3Ig+y<k4|LutxUg3^{T1&Z<R1e|3PHn3U{IXEAjyB&!qRY54zpqMK^
zrIW{|fo^S1`?8bZ#LmhRi3uh~+5j*3P@QrVqI4=5vBanyZk6IJNOa{>4EW2V+^yC~
zDI}N;e-l5}70=2~A$KG|eD+?j*j6VD#7q2G@fjYJP);IOs^ll82~h8zhFVy~?>4gH
zd4YeouU^v0_lrFAtL4OUdbtW{I(@JGj(uhCiTkgBrbLWh{w8>LK21DDDMx^G_DfNW
zf)h(Q9z7a}sKDjH-{_fMky1!78~!GK<QLD%|JBovzbVQ|yiQVnc>nMSbBb+s5=@N5
zD|p%$SC9Ijgc7hx=SmoU=~)Fp0)tKfk0SAuM^sz-Nr6O!I&B)<=r3K^G!TzX_~}LG
zA8mF2N^w?7O$-Au(yU-`d5GugQ6Jdghs_&FJ&6_L9tE6bQvgoo7V+}$iiau_Z5oKs
zrorgP!>u2i2D-92?aNMr6FbZN1rSV(d*K#b9-PEH>Z1~{QM!mJrYfo(X)wkFqf?&r
z7x9?N-O^7=CfYO*n@xk!kB3`7HVt%TbJ`cT?y+DqPXSrPyBA`><-tkJqdqDjkyA-_
z5@S39_3LS%SusVt{JY|zGNEY;DCR1@bYas#JT_N-DXg5%Dt?<M-!Jlz>XwZG%+r1W
zHHE)C_?g4jNBkqt9saSdbgujq9s9yVmi@+%h;4O}LJXV)D7ZA`t5MH=9ty!pt~9TN
zNsnR_oS0io9;gg@sx7q*)w8eMj)9ux9Or<i*8>SLUg9cvYdC!{C2rsEN)LXupC`_~
z^!INYJ&(G|j)WU#I%;mYf`OQy?zblyZ<|RHeEWXgtfXeYV0e52h-vCR<VxbHn-5MN
zY0Fdov2O2oN0bm-k{1lQ*j6VD#6U%Wf>XJ$a<}|rQ})0H6(*&{ygHTQ9+l!O`F+9(
zkE=WhP(p>Q*`|f*$|g!246tdSTbu4kz<tRSL*gVKF_AEvgaB}PlvSLVjUUd{M<uwW
zv=~+=F{>+)s7;h)zpJ_r@vAPU*lYsSj{WWq54V178tBTV+c9wN2%I%u$%71Hv@8XK
z%cIER#BBUftv+Ot%dICMp7C@Hk$Q+J;Opkc-`uW>KFUuCH7-J%5@rE5<>B;0qOd_R
zvm;>w)Sa*7!7L=A%2P4c%oVsiiZ4#g#;^9Lr%G@o%_5nejuBA2otS9g)FVCIKJ_E<
zsn&BqM*3}{C;c`JbZe8uu`jU^14!(wERmRCVmutKz~xbVabh-pI9DH);8r?CGChfz
z`sMu5=N}JB1n{qlKFUvt)g1m*6MsqPSi1L{Ap26vc=jVA9yVg20xNi>f6G5MWe<g*
z!lX2~c@(3533KCpiVHmhG^L+<mAxmX$G$GX#4vEeej40U<!v)t!fxL$JZeYs5;rAY
zf0eyI12=Q%%a#4UU^3{reZMR5FVMMF0-bvI@|5_Ir}s0Q@~nn{AM)mwtCQ~+c@n9)
z8IMCd)+1q@exw|;tiYy$Qf#tZlK^BkbI9NklL)g&05AARGle{XQI$N75m3A^=czsj
zwmgK{1jtlJX|DXa3*vLXq)^3$0ENU=3>1@`q&)Q_&5~*vQ_zTis=_<S(eJTKwoLq`
z3!4V&-Dd8BE18NJPiKu+@|=9X$kT(`FZhc8j=|ivK9ZM1My<@U0-FXUtSnS!_MW(q
zqyS-pi4h6l1t02CjzXTms7fA*Q9F2)qO2F_+$w=Q>C7{`NVeY3aLP0Go-+~K>LilV
z5Q-#aJPA{Xa*$JcrAmHcRsm1ab~o)x=d=CIh*bLI`_((ZsRzvhyNg)Od6#Duzv6$C
zpRV0|;?LMGU3kC3t2wXyIUG@GN~`!?|BAoymmgvMgc3jXTkSXpQksW&df_yG6a0`X
z3b|-ch_F?_ee+K?G+^%Xtm2^(p-b2_(3Q<HaGM5-FQ)kgni092G*cI<7d#Yl#iF*D
zgb}QVt1o!ZUX*S^nVeGc{j(6-G*Ahf07lJezs!|CdrwR{Dg8tI_Z!@0plGj(TXCu#
znTfY5lCCz*0C0&ds%fzJO=#0VSvCP%`z77V3x?{ak8)pm{!|hHG_nfQxNbk;p}UO7
zREc!njm4j8#oze-g;kbKgW^weV+0$&9YDOM#HoiC1a=qU#4n~Ff8*TcS;epT8$Ww2
z55YXeiHTEcEnXf>^nl;=LA<x1)@Ve|)tp!U)dW`YyZ#mbqx{Vr9#!J?JPdhN^x5;@
z<=>6p?W>7jU7g?0(Db#{+ne}~c{<%d6R>H3f0utZo)XjF;T2D6OHBOv_qbB1X4Q^n
zo_IBish@Omvye>#-O8MjJkUuk{ST`p$!tm>%-Ry0;q3s;t~57um|nrdOt|u7G^>?=
zO7cJ_b#tM`919UJeTba;-@=J_Z9z*(JWinZ&@bsCG>?Wb_4jPwzoqoneytgh7$tA9
z%Be`LgDU~`CCs_?frRu-5!=e2k<Y-?)qVkba@}La>^(7&Uj%>tJ?6gNQzWg-QM@B}
zHIv9#$|JVo#KgbLzZ*{p7FwRBuB47<8IfcZ+83MBFiIUgM0)t#CKk!<=SbdrZfCwP
za#elBmc1t?KB+LZ%@xnH{jQ#>R#;-x4l$UCx1{zZwy2H@&fXJeYiMJ_M=4ZY2}o5d
zOnh^-)df77NuD^jNDd5c=8#t?{LX$0mHJJma6gBw{jv@?y%giV#CWSj$<rz3G4h<A
zW)9gD;=i+B(#4iTFn>B5e8+xa(~7Aj-0)AYNQ5DI-f_RFUzpSL*Ki)b-?0Rq=Cifm
z6rZ@^pI(vs*89!g6Vq%lpRr$!)P<%KwsUL0`r7Kdme_1J0<>wrju)rRlY{I%F|s{&
z0Ooi0YpR@vXtPk>j(BUoq^liONjx$)9@0G)11oP5&vTW%C#DNOsQu1<Nf%Y=+WdfW
zHJV%dP3FWSZSTq4#C_IzZc}q&6c+QF`~7~)Tl?ijMSp(dgugH2y%?G~e87I$h1N<h
z!tb@6@2k~*r*l~CH~qqvkyq(VOpMG7zJ+J&`#X}C5|;GYpqWEnF$DiU_k$X5@sx$8
zIgWP~zqMa|ZO31yvD{~SnmK4w-q$zxTiBSYnO75biUPLwONv^9q~KM#PxY_n;PGli
z-`TII7@&c%tK@j?1lYf|-(*N^wu^x5Ju&SU^PBtCJjFTUoOZ^fe`~+vFSB0bB)kG{
z=5WV;ONs`F)052IWpMfl&MW8Mv0rk_uans>0<_=h9LkXW{XJ?jTl-D%iH{P0RNd@7
zF?x#0cs1ceq`G>lT45CGYdiir9U}g~qRkv~dQzw%A9YGYs#;-1sx@LT6YKUmXZD`B
zOz#W>DUwzuQk$zYH1aYH%^X%&=l3%`UQ~4Ibxr)T!Jed0_MRAd=ilQ>q4z7GzJxh1
z^~v57GlVj|GmNE3TA8DGN1maJS88zM1(Xp<(oz4i@;{!7s-oE@VZ5t)aDKs8{QsY8
zQ0F<b_rztAm^tLv>vwf8u>q3j{bDA5z4&7*X77n}fGA|b$Lf@TRJFqBY_5*&;>FdQ
zIph_pp0VFjqVIiczr3iB>vc`sm-xKf>^(7^mf=5Rzpir2VDH#3v|2H}2;WlZlVY^f
z=^WmAzbQWPC++T*Ub6SZ<QDVozQ6wF3iwUFWh@^Plf5T?&3^p~-7?Ru-)9Kb4kZe{
zrPe3Ktmfe1Yeet${Y~+SKWTBd^pd?NCbyVR+V3qQ6|?pI<)uY`{vrwAUhXp@n>l>I
ze%X=MN-x5nv9;T~(0-?LSnW6c!Ya4&=WPmG#jpHZ-`|l$o)mBe+{_`b7=?eISA$yl
z$>mC?fCjsYU-`H8tFP_&>!i}xIh#3X&Yt$&`-Q>tG#j484ru&a`-MlXse0n9bp@Qg
zC)WJEg&X(lERRkTmT5LjN2b$$ryFeTw~*U3+eLsIFM#&bgL&hA$GO2{r#NLMb^u`I
z-`X!PDm;2!6KA0-;OsrI=j>_UxL?IPOFW)r@n<ktVHx8@z#aP~ODh&RI0>(SwbSVw
za`*&zzekN_YriQz@loQBs++whMo%#ruO@tmR98<`D~v*YZT0phK1BS1MYH$BNXqF+
zp@w|aDGjM=g%zoGh`~&(+v}X!d*U*^GYq6iTA4^~uFlZN%QQ4|SY4gp&-8dv(W%!p
z@yiB#l0w;gV&t8Fk1K`VuYmdz=DgG=dr!;|R?|DbzY%|_<@R$p{~lKg>5F$&4>4cx
z$1nEP_M5#YZdSjV>UsQHqW9}{UvR&r_ngUj_O+{|c{#QE>zu36H6vQ3oX3xNUR3nt
zFOu+eHmgpXIh<!-yGp!Y0re=XuCH@u?}?ef?o`hc--y4?X4UCxDb0vhDd+Jco_AFb
zs=nZ_e?R{<lXrQ~r!SSnd%s>c!SB-719h(EaMb@DVXN+Hzf=DO_xtX1nCjOTmaF__
z7JlIO;w`A?`mN{C?^lafkHT-Uln08;-V@(fBBz}UkMbv{a55WnWn93>@Y$ZyzRkP4
z7DJ}vk+~u-{$xm;oW{;gz%B2p9{gYM*T0|tnu!Ov3&xG$5s6n|PJ1$Ig`Jh4Fl4Ux
zOMK!?zXHzQ6W`Z+PS^~&g>(x0wwO~Yr%!{OV$K3e`p284eVg|+K2672c45;%iD?S|
z^mN4pWbvZn(d(M{r-UCCki93qyUpB`Ny_l=_B+uanT@$sF9M03coC4jCw`aqz0(AU
zPc!km^z|s6*?Zzg@jsg<H5*fucU2G0FZk=<&wtH?5pDf<!lQz{(*$~{ykD=I7+qcJ
zeCs*nT8&wsaRHawY(IyizLHyY%lc%}7cVXN&)=iKSKDthhpjmu72NMvi&l@q*WB-P
z4rOI$m`ss`x!Uj4kMj&&yi!9mha9FPrRVi{s$r_1$nlri-{Mz}_wZWH9CCx`lzEh3
zS5H;o)qc^b)(9y0s1}Z@yP88z5^b1ADO6nvNLAp~ey4uz`q(aBT)mk?P7+lbujFM`
z3f}T7I0+MvR1%P?z!_!?kA98EU#C=i1$_G)ykEvx7Ln#1*o0%QJUT5Po!)5z0@Rm4
z;>^7Q&fXK#dzsicUI%DUGRL8%f5e5vbw?fvaC`$yGRBOwpY0hZAWs<)X6`q$JRc|8
zBar^vu}he3Yrnj!df@qjzyAC4Uo&B<o-hE@`<35gH%R}Zu*oez%>Ah>?-w(1a$W&v
z?}>AU%)$Ewmn%<c%b&sEDT!iqwe|fi<ThR9BEXFoK>O*z%>5oRoUQ%xqM~1~YvMzc
zA6PVdPmH8-zXz_E(yE@SRv7W>MIiBkqduf`_MR9qIX!99kdHd0Ayut#5uafqxz3rr
zCmu(1hMA<o1|yYsRS#ib@Ylbe|C-6T-)5d?yV9%Z{d(Q#)YYZV)f~>YwcGWuzE$w0
vHrvl(HKOzT>5G>Zoqzrw1-{yTn>n0+k1K`VuYh_KzUF?Xb68F9RQ~@5fnq+Q

literal 0
HcmV?d00001

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index 1a2f4aad5490292621909d0dbcaa7108d045055c..f3d3b05bdecfca634a113921ce3b826489bcf4cb 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -1,13 +1,17 @@
 # GameboyTKP
 Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 ## Features
-
+ - Customizable palette
  - Disassembler/Debugger with step/reset/pause functionality
  - Advanced breakpoints. You can create a breakpoint for a specific instruction with specific register values
  - Real time register values shown on disassembler
  - Trace logger
  - Save states (WIP)
  - Rewind functionality (WIP)
+## Images
+![Super Mario Land](./Images/sml.bmp)
+![Tetris](./Images/tet.bmp)
+
 ## Tests
 
 **[Blargg](https://github.com/gblargg)'s tests:**

From 812020f96ef69f95cc6ad53f5dd2292f2236dd62 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 10 Dec 2021 12:04:33 +0200
Subject: [PATCH] instr_timing passes, fixes #3

---
 TKPEmu/gb_tkp/gameboy.cpp      |  8 +++----
 TKPEmu/gb_tkp/gb_bus.cpp       |  1 +
 TKPEmu/gb_tkp/gb_cartridge.cpp | 10 ++-------
 TKPEmu/gb_tkp/gb_cartridge.h   |  2 ++
 TKPEmu/gb_tkp/gb_cpu.cpp       | 50 +++++++++++++++++++++---------------------
 5 files changed, 34 insertions(+), 37 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 13614510877bb53faec8a0a577e5b83f94a6f236..3c4bae8ea47a92841ba11a2b01ba9de984274ca9 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -180,12 +180,12 @@ namespace TKPEmu::Gameboy {
 		static const uint8_t joy_action = 0b1101'1111;
 		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
 			int index = it_dir - direction_keys_.begin();
-			bus_.DirectionKeys = (~(1UL << index)) & joy_direction;
+			bus_.DirectionKeys &= (~(1UL << index));// & joy_direction;
 			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
 			int index = it_dir - action_keys_.begin();
-			bus_.ActionKeys = (~(1UL << index)) & joy_action;
+			bus_.ActionKeys &= (~(1UL << index));// & joy_action;
 			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 	}
@@ -194,11 +194,11 @@ namespace TKPEmu::Gameboy {
 		static const uint8_t joy_action = 0b1101'1111;
 		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
 			int index = it_dir - direction_keys_.begin();
-			bus_.DirectionKeys = (1UL << index) | joy_direction;
+			bus_.DirectionKeys |= (1UL << index);// | joy_direction;
 		}
 		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
 			int index = it_dir - action_keys_.begin();
-			bus_.ActionKeys = (1UL << index) | joy_action;
+			bus_.ActionKeys |= (1UL << index);// | joy_action;
 		}
 	}
 	void Gameboy::load_file(std::string path) {
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index df13b714dd96ec43e5dae5515ae656ca84c52b17..655b50bcb7c133d878de5d19a1047e19336348be 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -152,6 +152,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 		}
+		return unused_mem_area_;
 	}
 
 	uint8_t Bus::Read(uint16_t address) {
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 81de81ba6189adf366c8733c2cd361f21cf8e00c..c8ea5f811b3b19f517d2540aabd69116609e0c32 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -41,17 +41,11 @@ namespace TKPEmu::Gameboy::Devices {
 		if (loaded) {
 			return (CartridgeType)header_.cartridgeType;
 		}
+		return CartridgeType::ERROR;
 	}
 	// Returns the number of 8KB RAM banks
-	// TODO: constexpr, return from constexpr array
 	int Cartridge::GetRamSize() {
-		switch (header_.ramSize) {
-			case 0: return 0;
-			case 2: return 1;
-			case 3: return 4;
-			case 4: return 16;
-			case 5: return 8;
-		}
+		return ram_sizes_[header_.ramSize];
 	}
 	// Returns the number of 16kb ROM banks
 	int Cartridge::GetRomSize() {
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
index 7fb37f635aaf5bc23f5f8ce41d279f82dc2c223e..2cc714fed38b87364727bab4a221d47b5907b8bb 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.h
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -8,6 +8,7 @@
 #define ENTRY_POINT 0x100
 namespace TKPEmu::Gameboy::Devices {
 	enum class CartridgeType {
+		ERROR = 0x4,
 		ROM_ONLY = 0x0,
 		MBC1 = 0x1,
 		MBC1_RAM = 0x2,
@@ -49,6 +50,7 @@ namespace TKPEmu::Gameboy::Devices {
 			char ramSize;
 			char unusedData3[6];
 		} header_;
+		static constexpr std::array<int, 6> ram_sizes_ { 0, 0, 1, 4, 16, 8 };
 		bool loaded;
 	public:
 		void Load(const std::string& fileName, std::vector<std::array<uint8_t, 0x4000>>& romBanks, std::vector<std::array<uint8_t, 0x2000>>& ramBanks);
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b39afe616963e36078020eb4d17d5cc58b9384c8..b61dbc6a3dbadead0ad2e6659c3d0a0043e75579 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -940,7 +940,7 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 		if ((F & 0x80) == 0x80) {
 			PC += i;
-			; tTemp += 4;
+			tTemp += 4;
 		}
 	}
 	void CPU::JRNC8() {
@@ -1195,48 +1195,48 @@ namespace TKPEmu::Gameboy::Devices {
 			SP -= 2;
 			bus_->WriteL(SP, PC + 2);
 			PC = bus_->ReadL(PC);
-			; tTemp += 12;
+			tTemp = 24;
 		}
 		else {
 			PC += 2;
+			tTemp = 12;
 		}
-		; tTemp += 12;
 	}
 	void CPU::CALLZ16() {
 		if ((F & 0x80) == 0x80) {
 			SP -= 2;
 			bus_->WriteL(SP, PC + 2);
 			PC = bus_->ReadL(PC);
-			; tTemp += 8;
+			tTemp = 24;
 		}
 		else {
 			PC += 2;
+			tTemp = 12;
 		}
-		tTemp = 12;
 	}
 	void CPU::CALLNC16() {
 		if ((F & 0x10) == 0x00) {
 			SP -= 2;
 			bus_->WriteL(SP, PC + 2);
 			PC = bus_->ReadL(PC);
-			; tTemp += 8;
+			tTemp = 24;
 		}
 		else {
 			PC += 2;
+			tTemp = 12;
 		}
-		tTemp = 12;
 	}
 	void CPU::CALLC16() {
 		if ((F & 0x10) == 0x10) {
 			SP -= 2;
 			bus_->WriteL(SP, PC + 2);
 			PC = bus_->ReadL(PC);
-			; tTemp += 8;
+			tTemp = 24;
 		}
 		else {
 			PC += 2;
+			tTemp = 12;
 		}
-		tTemp = 12;
 	}
 	void CPU::LDSP16() {
 		SP = bus_->ReadL(PC);
@@ -1858,7 +1858,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 0);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES0A() {
 		bit_res(A, 0);
@@ -1885,7 +1885,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 1);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES1A() {
 		bit_res(A, 1);
@@ -1912,7 +1912,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 2);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES2A() {
 		bit_res(A, 2);
@@ -1939,7 +1939,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 3);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES3A() {
 		bit_res(A, 3);
@@ -1966,7 +1966,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 4);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES4A() {
 		bit_res(A, 4);
@@ -1993,7 +1993,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 5);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES5A() {
 		bit_res(A, 5);
@@ -2020,7 +2020,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 6);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES6A() {
 		bit_res(A, 6);
@@ -2047,7 +2047,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_res(t, 7);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::RES7A() {
 		bit_res(A, 7);
@@ -2074,7 +2074,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 0);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET0A() {
 		bit_set(A, 0);
@@ -2101,7 +2101,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 1);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET1A() {
 		bit_set(A, 1);
@@ -2128,7 +2128,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 2);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET2A() {
 		bit_set(A, 2);
@@ -2155,7 +2155,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 3);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET3A() {
 		bit_set(A, 3);
@@ -2182,7 +2182,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 4);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET4A() {
 		bit_set(A, 4);
@@ -2209,7 +2209,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 5);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET5A() {
 		bit_set(A, 5);
@@ -2236,7 +2236,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 6);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET6A() {
 		bit_set(A, 6);
@@ -2263,7 +2263,7 @@ namespace TKPEmu::Gameboy::Devices {
 		auto t = bus_->Read((H << 8) | L);
 		bit_set(t, 7);
 		bus_->Write((H << 8) | L, t);
-		; tTemp += 8;
+		tTemp += 8;
 	}
 	void CPU::SET7A() {
 		bit_set(A, 7);

From 561dde4164b757fbd66d711f3e11a3a7fe039ced Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Fri, 10 Dec 2021 20:55:22 +0200
Subject: [PATCH] all ram fixes and ramg test fixes

---
 TKPEmu/gb_tkp/gb_bus.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 655b50bcb7c133d878de5d19a1047e19336348be..98ac3a9003a30597f96abafa7368992310e09efb 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -14,7 +14,7 @@ namespace TKPEmu::Gameboy::Devices {
 			case CartridgeType::MBC1_RAM:
 			case CartridgeType::MBC1_RAM_BATTERY: {
 				if (address <= 0x1FFF) {
-					if (data == 0xA) {
+					if ((data & 0b1111) == 0b1010) {
 						ram_enabled_ = true;
 					}
 					else {
@@ -122,6 +122,7 @@ namespace TKPEmu::Gameboy::Devices {
 					auto sel = (banking_mode_ ? selected_ram_bank_ : 0) % cartridge_->GetRamSize();
 					return (ram_banks_[sel])[address % 0x2000];
 				} else {
+					unused_mem_area_ = 0xFF;
 					return unused_mem_area_;
 				}
 			}

From f1e2d7f9f4f9af9b5eca9905d98aeb86e5726ed6 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Fri, 10 Dec 2021 22:24:43 +0200
Subject: [PATCH] temp1

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 24 +++++++++++++++---------
 TKPEmu/gb_tkp/gb_cpu.h   |  2 +-
 TKPEmu/gb_tkp/gb_ppu.cpp |  2 +-
 3 files changed, 17 insertions(+), 11 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b61dbc6a3dbadead0ad2e6659c3d0a0043e75579..328136e62841abf7bb034ec1bace2165b184ad24 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2291,31 +2291,37 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
-		if (halt_) {
-			PC--;
+		bool queued = handle_interrupts();
+		if (halt_ && queued) {
+			halt_ = false; 
+			PC++;
 		}
-		(this->*Instructions[bus_->Read(PC++)].op)();
-		handle_interrupts();
 		if (ime_scheduled_)
 			ime_ = true;
+		if (halt_) {
+			return 4;
+		}
+		(this->*Instructions[bus_->Read(PC++)].op)();
+
 		TClock += tTemp;
 		TotalClocks += 1;
 		return tTemp;
 	}
-	void CPU::handle_interrupts() {
+	bool CPU::handle_interrupts() {
 		if (auto temp = IE & IF; ime_ && IF) {
-			//if (halt_) {
-			//	PC += 1;
-			//} TODO: fix halt_ime1_timing.gb (works in other emu)
 			// Starting from the lowest bit (highest priority) and going up,
 			// we are effectively queueing interrupts in case there's multiple.
 			for (int i = 0; i < 5; i++) {
 				if (auto bit = (temp >> i) & 0x1; bit) {
 					execute_interrupt(i);
-					return;
+					return true;
 				}
 			}
 		}
+		if (IF & IE) 
+			return true;
+		else 
+			return false;
 	}
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 6bf968f29a98d645a1771ed3651029b1ad7cd7db..c8a5a4d5d7da04980db8354d2356500cf780f895 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -87,7 +87,7 @@ namespace TKPEmu::Gameboy::Devices {
 		void bit_sr(RegisterType& reg);
 		void bit_srl(RegisterType& reg);
 		void rst(RegisterType addr);
-		void handle_interrupts();
+		bool handle_interrupts();
 		void execute_interrupt(int bit);
 		void update_timers(int cycles);
 		int get_clk_freq();
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index ae7dcded6112c99315c1faf305872c355ae319b6..e101fc0b2eedf24fc410e5fc389d6b5b78a20bf6 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -67,7 +67,7 @@ namespace TKPEmu::Gameboy::Devices {
 		LY = 0x90;
 		LCDC = 0b1001'0001;
 		STAT = 0b1000'0000;
-		next_stat_mode = 2;
+		next_stat_mode = 3;
 		clock_ = 0;
 		clock_target_ = 0;
 	}

From 9959d33eae726a2616b9bfc8b96dea5a267342dc Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Fri, 10 Dec 2021 23:10:25 +0200
Subject: [PATCH] zelda/poke midori/sml playing seemingly perfectly pokemon red
 crashing after menu

---
 TKPEmu/gb_tkp/gb_bus.cpp       | 48 ++++++++++++++++++++++++++++++++++++++++++
 TKPEmu/gb_tkp/gb_cartridge.cpp |  5 ++++-
 TKPEmu/gb_tkp/gb_cpu.cpp       |  1 -
 3 files changed, 52 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 98ac3a9003a30597f96abafa7368992310e09efb..ae841043c14a74cf9f738c473b02a1abb145a887 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -40,6 +40,37 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				break;
 			}
+			case CartridgeType::MBC3:
+			case CartridgeType::MBC3_RAM:
+			case CartridgeType::MBC3_RAM_BATTERY: {
+				if (address <= 0x1FFF) {
+					if ((data & 0b1111) == 0b1010) {
+						ram_enabled_ = true;
+						// TODO: enable writing to RTC mbc3 registers
+					}
+					else {
+						ram_enabled_ = false;
+					}
+				}
+				else if (address <= 0x3FFF) {
+					// BANK register 1 (TODO: this doesnt happen on mbc0?)
+					selected_rom_bank_ &= 0b1100000;
+					selected_rom_bank_ |= data & 0b11111;
+					selected_rom_bank_ %= rom_banks_size_;
+				}
+				else if (address <= 0x5FFF) {
+					// BANK register 2
+					selected_rom_bank_ &= 0b11111;
+					selected_rom_bank_ |= ((data & 0b11) << 5);
+					selected_rom_bank_ %= rom_banks_size_;
+					selected_ram_bank_ = data & 0b11;
+				}
+				else {
+					// MODE register
+					banking_mode_ = data & 0b1;
+				}
+				break;
+			}
 			default: {
 				return;
 			}
@@ -104,6 +135,23 @@ namespace TKPEmu::Gameboy::Devices {
 						}
 						break;
 					}
+					case CartridgeType::MBC3:
+					case CartridgeType::MBC3_RAM:
+					case CartridgeType::MBC3_RAM_BATTERY: {
+						if (address <= 0x3FFF) {
+							auto sel = (banking_mode_ ? selected_rom_bank_ & 0b1100000 : 0) % cartridge_->GetRomSize();
+							return (rom_banks_[sel])[address % 0x4000];
+						}
+						else {
+							auto sel = selected_rom_bank_ % cartridge_->GetRomSize();
+							if (sel == 0) {
+								// Accessing 20/40/60 is supported in mbc3
+								sel += 1;
+							}
+							return (rom_banks_[sel])[address % 0x4000];
+						}
+						break;
+					}
 				}
 				std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
 				exit(1);
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index c8ea5f811b3b19f517d2540aabd69116609e0c32..33a6494bd96eb7d970cce1ec5532f2ec7d673b26 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -16,7 +16,10 @@ namespace TKPEmu::Gameboy::Devices {
 				case CartridgeType::ROM_ONLY:
 				case CartridgeType::MBC1:
 				case CartridgeType::MBC1_RAM:
-				case CartridgeType::MBC1_RAM_BATTERY: {
+				case CartridgeType::MBC1_RAM_BATTERY:
+				case CartridgeType::MBC3:
+				case CartridgeType::MBC3_RAM:
+				case CartridgeType::MBC3_RAM_BATTERY: {
 					auto sz = GetRomSize();
 					romBanks.resize(sz);
 					for (int i = 0; i < sz; i++) {
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 328136e62841abf7bb034ec1bace2165b184ad24..b40815017c6669d0a6260dcfb014e0098e50dfc5 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2294,7 +2294,6 @@ namespace TKPEmu::Gameboy::Devices {
 		bool queued = handle_interrupts();
 		if (halt_ && queued) {
 			halt_ = false; 
-			PC++;
 		}
 		if (ime_scheduled_)
 			ime_ = true;

From 505f4ec5b016df45d1668df3b6cf4cdba18b0641 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 11 Dec 2021 18:11:19 +0200
Subject: [PATCH] tracelogger additions

---
 TKPEmu/gb_tkp/gameboy.cpp    | 29 +++++++++++++++++++++++++++++
 TKPEmu/gb_tkp/gb_addresses.h | 18 ++++++++++++------
 TKPEmu/gb_tkp/gb_bus.cpp     |  5 ++++-
 TKPEmu/gb_tkp/gb_bus.h       |  1 +
 TKPEmu/gb_tkp/gb_cpu.h       |  4 ++--
 5 files changed, 48 insertions(+), 9 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 3c4bae8ea47a92841ba11a2b01ba9de984274ca9..24cf6a680a66d11246849b86ebfc4201c5561f23 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -34,8 +34,17 @@ namespace TKPEmu::Gameboy {
 	void Gameboy::v_log_state() {
 		*ofstream_ptr_ << std::setfill('0');
 		bool first_type = true;
+		int inst = bus_.ReadSafe(cpu_.PC);
 		for (const auto& t : *log_types_ptr_) {
 			switch (t) {
+				case LogType::InstrName: {
+					*ofstream_ptr_ << std::setfill(' ') << std::setw(8) << cpu_.Instructions[inst].name << std::setfill('0');
+					break;
+				}
+				case LogType::InstrNum: {
+					*ofstream_ptr_ << std::setw(2) << std::hex << inst;
+					break;
+				}
 				case LogType::PC: {
 					*ofstream_ptr_ << "PC:" << std::setw(4) << std::hex <<  cpu_.PC;
 					break;
@@ -76,6 +85,26 @@ namespace TKPEmu::Gameboy {
 					*ofstream_ptr_ << "L:" << std::setw(2) << std::hex << (int)cpu_.L;
 					break;
 				}
+				case LogType::LY: {
+					*ofstream_ptr_ << "LY:" << std::setw(2) << std::hex << (int)cpu_.LY;
+					break;
+				}
+				case LogType::IF: {
+					*ofstream_ptr_ << "IF:" << std::setw(2) << std::hex << (int)cpu_.IF;
+					break;
+				}
+				case LogType::IE: {
+					*ofstream_ptr_ << "IE:" << std::setw(2) << std::hex << (int)cpu_.IE;
+					break;
+				}
+				case LogType::IME: {
+					*ofstream_ptr_ << "IME:" << (int)cpu_.ime_;
+					break;
+				}
+				case LogType::HALT: {
+					*ofstream_ptr_ << "HALT:" << (int)cpu_.halt_;
+					break;
+				}
 			}
 			*ofstream_ptr_ << " ";
 		}
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index f8184ef5adcf6bbbf5aa79b0e038137b16e010bc..97c352ab5bf0bf5184e22b8ff8fce51c42e76a84 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -8,11 +8,13 @@ using RegisterType = uint8_t;
 using BigRegisterType = uint16_t;
 using DisInstr = TKPEmu::Tools::DisInstr;
 using GBBPArguments = TKPEmu::Gameboy::Utils::GBBPArguments;
-constexpr size_t LogTypeSize = 10;
+constexpr size_t LogTypeSize = 17;
 enum class LogType {
+    InstrName, InstrNum,
     A, B, C, D, 
     E, F, H, L,
-    PC, SP,
+    PC, SP, LY,
+    IF, IE, IME, HALT
 };
 enum LCDCFlag {
     BG_ENABLE = 1 << 0,
@@ -64,14 +66,18 @@ const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
     { "c57eada752f746347951f79c828391b9", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
+    LogType::InstrName, LogType::InstrNum,
     LogType::A, LogType::B, LogType::C, LogType::D,
     LogType::E, LogType::F, LogType::H, LogType::L,
-    LogType::PC, LogType::SP
+    LogType::PC, LogType::SP, LogType::LY, LogType::IF,
+    LogType::IE, LogType::IME, LogType::HALT
 };
 const static std::array<std::string, LogTypeSize> LogTypeNames {
-    "A   ", "B   ", "C   ", "D   ",
-    "E   ", "F   ", "H   ", "L   ",
-    "PC  ", "SP  "
+    "Instr. ", "Opcode ",
+    "A      ", "B      ", "C      ", "D      ",
+    "E      ", "F      ", "H      ", "L      ",
+    "PC     ", "SP     ", "LY     ", "IF     ",
+    "IE     ", "IME    ", "HALT   ",
 };
 constexpr std::array<uint8_t, 0x100> InstrTimes = {
     0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index ae841043c14a74cf9f738c473b02a1abb145a887..ab7ac72731450d1db30b30aa30facec3c2cec44e 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -205,7 +205,10 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 
 	uint8_t Bus::Read(uint16_t address) {
-		// Making copy so you can't write to this
+		return ReadSafe(address);
+	}
+	uint8_t Bus::ReadSafe(uint16_t address) {
+		// ReadSafe does not alter the machine state
 		switch(address) {
 			case addr_joy: {
 				if (action_key_mode_) { 
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index b8f8b7b82754a41ab5f4eecfd28686adc7d170ca..9811609dc644527251898cb7168de7d00653d615 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -56,6 +56,7 @@ namespace TKPEmu::Gameboy::Devices {
         };
         Bus(std::vector<DisInstr>& instrs);
         uint8_t Read(uint16_t address);
+        uint8_t ReadSafe(uint16_t address);
         uint16_t ReadL(uint16_t address);
         uint8_t& GetReference(uint16_t address);
         void Write(uint16_t address, uint8_t data);
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index c8a5a4d5d7da04980db8354d2356500cf780f895..1d9818c1f5c9a2d15eb5d8cb4be06f30c96efdb7 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -14,7 +14,6 @@ namespace TKPEmu::Gameboy::Devices {
 	class CPU {
 	private:
 		Bus* bus_;
-		bool ime_ = false;
 		bool ime_scheduled_ = false;
 		int tTemp = 0;
 		int div_reset_index_ = -1;
@@ -95,12 +94,13 @@ namespace TKPEmu::Gameboy::Devices {
 	public:
 		CPU(Bus* bus);
 		bool halt_ = false;
+		bool ime_ = false;
 		struct Instruction {
 			std::string name;
 			void(CPU::* op)() = nullptr;
+			// TODO: remove instr times, use the ones in gb_addresses instead
 			int skip = 0;
 		};
-		// TODO: remove instr times, use the ones in gb_addresses instead
 		std::array<Instruction, 0x100> Instructions = { {
 			{ "NOP" , &CPU::NOP }, { "LDBC16" , &CPU::LDBC16 , 2}, { "LDBCA" , &CPU::LDBCA }, { "INCBC" , &CPU::INCBC }, { "INCB" , &CPU::INCB }, { "DECB" , &CPU::DECB }, { "LDB8" , &CPU::LDB8 , 1}, { "RLCA" , &CPU::RLCA }, { "LD16SP" , &CPU::LD16SP }, { "ADDHLBC" , &CPU::ADDHLBC }, { "LDABC" , &CPU::LDABC }, { "DECBC" , &CPU::DECBC }, { "INCC" , &CPU::INCC }, { "DECC" , &CPU::DECC }, { "LDC8" , &CPU::LDC8 , 1}, { "RRCA" , &CPU::RRCA },
 			{ "STOP" , &CPU::STOP }, { "LDDE16" , &CPU::LDDE16 , 2}, { "LDDEA" , &CPU::LDDEA }, { "INCDE" , &CPU::INCDE }, { "INCD" , &CPU::INCD }, { "DECD" , &CPU::DECD }, { "LDD8" , &CPU::LDD8 , 1}, { "RLA" , &CPU::RLA }, { "JR8" , &CPU::JR8 , 1}, { "ADDHLDE" , &CPU::ADDHLDE }, { "LDADE" , &CPU::LDADE }, { "DECDE" , &CPU::DECDE }, { "INCE" , &CPU::INCE }, { "DECE" , &CPU::DECE }, { "LDE8" , &CPU::LDE8 , 1}, { "RRA" , &CPU::RRA },

From 6e76aa2c6f4d5b165f5f2c09f14e1def68161bcf Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 11 Dec 2021 18:13:47 +0200
Subject: [PATCH] halt_ime0 passes

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b40815017c6669d0a6260dcfb014e0098e50dfc5..1643d5f164eb23003970273ae9ffa2532efb33e8 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1365,10 +1365,7 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::HALT() {
-		if (ime_scheduled_)
-			ime_ = true;
-		else
-			halt_ = true;
+		halt_ = true;
 	}
 	void CPU::XXX() {
 		stop_ = true;

From 8e6a9fece2889e07efab05ea6ab8e479b89e468c Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 11 Dec 2021 18:43:20 +0200
Subject: [PATCH] stability commit - haltime0 pass ime1 fail but with data

---
 TKPEmu/gb_tkp/gameboy.cpp  | 4 +++-
 TKPEmu/gb_tkp/gb_cpu.cpp   | 9 ++++-----
 TKPEmu/gb_tkp/gb_timer.cpp | 3 ---
 3 files changed, 7 insertions(+), 9 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 24cf6a680a66d11246849b86ebfc4201c5561f23..c8524756865faaa40f9b6cc93667f6d9e9643121 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -187,7 +187,9 @@ namespace TKPEmu::Gameboy {
 			uint8_t old_if = interrupt_flag_;
 			int clk = cpu_.Update();
 			if (timer_.Update(clk, old_if)) {
-				cpu_.halt_ = false;
+				if (cpu_.halt_) {
+					cpu_.halt_ = false;
+				}
 			}
 			ppu_.Update(clk);
 			log_state();
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 1643d5f164eb23003970273ae9ffa2532efb33e8..b4f4f55cf4b60ed9c8fa364d7b42df8b7ff388ce 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1366,6 +1366,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::HALT() {
 		halt_ = true;
+		tTemp = 4;
 	}
 	void CPU::XXX() {
 		stop_ = true;
@@ -2289,16 +2290,14 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	int CPU::Update() {
 		bool queued = handle_interrupts();
-		if (halt_ && queued) {
-			halt_ = false; 
-		}
 		if (ime_scheduled_)
 			ime_ = true;
-		if (halt_) {
+		if (halt_ && queued) {
+			halt_ = false; 
+		} else if (halt_) {
 			return 4;
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
-
 		TClock += tTemp;
 		TotalClocks += 1;
 		return tTemp;
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index 5d20b8ba7ad21b8f0664222319cddac602c7ed43..fa0c7f4ca56cf62f9b2fc0fbf196e529a622cf89 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -57,9 +57,6 @@ namespace TKPEmu::Gameboy::Devices {
 				timer_counter_ -= freq;
 				//timer_counter_ = get_clk_freq();
 				if (TIMA == 0xFF) {
-					/*TIMA = TMA;
-					IF |= 1 << 2;
-					halt_ = false;*/
 					// After TIMA overflows, it stays 00 for 1 clock and *then* becomes =TMA
 					TIMA = 0;
 					tima_overflow_ = true;

From c58e9eccc9d393b4061b0956141b144fdf56cf9d Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 13 Dec 2021 17:41:26 +0200
Subject: [PATCH] added more breakpoints, wrote down blargg hashes

---
 TKPEmu/gb_tkp/gameboy.cpp         | 10 ++++++++--
 TKPEmu/gb_tkp/gb_addresses.h      | 36 ++++++++++++++++++++++++------------
 TKPEmu/gb_tkp/gb_breakpoint.h     |  2 ++
 TKPEmu/gb_tkp/gb_cpu.cpp          |  7 +++++--
 TKPEmu/gb_tkp/gb_disassembler.cpp | 30 ++++++++++++++++--------------
 TKPEmu/gb_tkp/gb_disassembler.h   | 11 +++--------
 6 files changed, 58 insertions(+), 38 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index c8524756865faaa40f9b6cc93667f6d9e9643121..fc3681868aa76c674f8e1b3ba07fe5bb821592b5 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -180,15 +180,20 @@ namespace TKPEmu::Gameboy {
 		ppu_.Reset();
 	}
 	void Gameboy::update() {
+		static bool skip_next = false;
 		if ((cpu_.TClock / 2) < cpu_.MaxCycles || FastMode) {
 			if (cpu_.PC == 0x100) {
 				bus_.BiosEnabled = false;
 			}
 			uint8_t old_if = interrupt_flag_;
-			int clk = cpu_.Update();
+			int clk = 0;
+			if (!skip_next)
+				clk = cpu_.Update();	
+			skip_next = false;
 			if (timer_.Update(clk, old_if)) {
 				if (cpu_.halt_) {
 					cpu_.halt_ = false;
+					skip_next = true;
 				}
 			}
 			ppu_.Update(clk);
@@ -274,7 +279,8 @@ namespace TKPEmu::Gameboy {
 		if (bp.PC_using) { register_checks.push_back([this, gbbp = bp.PC_value]() { return cpu_.PC == gbbp; }); }
 		if (bp.SP_using) { register_checks.push_back([this, gbbp = bp.SP_value]() { return cpu_.SP == gbbp; }); }
 		if (bp.SP_using) { register_checks.push_back([this, gbbp = bp.SP_value]() { return cpu_.SP == gbbp; }); }
-		if (bp.Ins_using) { register_checks.push_back([this, gbbp = bp.Ins_value]() { return (bus_.Read(cpu_.PC)) == gbbp; }); }
+		if (bp.Ins_using) { register_checks.push_back([this, gbbp = bp.Ins_value]() { return (bus_.ReadSafe(cpu_.PC)) == gbbp; }); }
+		if (bp.Clocks_using) { register_checks.push_back([this, gbbp = bp.Clocks_value]() { return cpu_.TotalClocks == gbbp; }); }
 		auto lamb = [rc = std::move(register_checks)]() {
 			for (auto& check : rc) {
 				if (!check()) {
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 97c352ab5bf0bf5184e22b8ff8fce51c42e76a84..3f39fceffda6975aaaa728fac571da6dc51de7e4 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -52,18 +52,30 @@ struct ExpectedResult {
 // This map helps with quality assurance, we can check multiple test roms
 // at once and compare their finished hashes with these known good results
 const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
-    // cpu_instrs
-    { "662f04537286d13ee55a6df9de4dce24", { 0, "error-hash" } },
-    // bits_bank1
-    { "31d2ad77d05566b1dcb92d7ff7232767", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
-    // bits_bank2
-    { "d7c8eb26b8c276f0d13e2a272a17c308", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
-    // bits_mode
-    { "d807288f6cfe34225989dd0d9293043e", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
-    // if_ie_registers
-    { "cd20692d8453b777bb2918bef8431117", { 0, "f2ead6ee6dc0a2f45504a43ad6536ba6" } },
-    // div_write
-    { "c57eada752f746347951f79c828391b9", { 0, "f0553923b341e4e57f091f1ce8cc8cf0" } },
+    // blargg
+    // 01-special
+    { "7d95af543a521ed036dc85f6f232d103", { 1'300'000, "42d5abde92c2678617996dd8f782989c" } },
+    // 02-interrupts
+    { "d36a85bb94d4c1b373c0e7be0f6f0971", { 200'000, "0f384cd6115fd9b2c33f7d9fc42200b5" } },
+    // 03-op sp,hl
+    { "5bccf6b03f661d92b2903694d458510c", { 1'150'000, "3caaa1d70619add931ecfa9e88e3a7ff" } },
+    // 04-op r,imm
+    { "e97a5202d7725a3caaf3495e559f2e98", { 1'400'000, "cccde7fb4b57b51d73147233e2789d0e" } },
+    // 05-op rp
+    { "43fc8bfc94938b42d8ecc9ea8b6b811a", { 1'900'000, "2d0258217d9411ae7dc9390b4022e7fa" } },
+    // 06-ld r,r
+    { "24da4eed7ef73ec32aae5ffd50ebec55", { 300'000, "45f17918f8da5383982f33eda50b3714" } },
+    // 07-jr,jp,call,ret,rst
+    { "6dbf4e754ef2f844246fd08718d1c377", { 400'000, "c81680b1a44aab843cea7936de3da10f" } },
+    // 08-misc instrs
+    { "c21ddacbfa44d61919c8e2d6c3e7d26e", { 350'000, "820df31460734f4451ef46673a5e297c" } },
+    // 09-op r,r
+    { "e4c4dd4eebad0c9d6f2ef575331c3aee", { 4'500'000, "7a0cae7fe13aba1179096a74161dbd81" } },
+    // 10-bit ops
+    { "64632849778ee83ae85db8bf68c84ebc", { 7'000'000, "56d069d71d8b2114149a6a605df2ef28" } },
+    // 11-op a,(hl)
+    { "6e64346be4d7ccf26f53de105d6cb5f6", { 7'500'000, "3215a908fc7e7aac137f20b9dec08e9e" } },
+    
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::InstrName, LogType::InstrNum,
diff --git a/TKPEmu/gb_tkp/gb_breakpoint.h b/TKPEmu/gb_tkp/gb_breakpoint.h
index ef60051fdeac4d7a7a38d10a9388f07cc2e13f6c..416017daecd54277cad8317c1a6ffe1303a1ba50 100644
--- a/TKPEmu/gb_tkp/gb_breakpoint.h
+++ b/TKPEmu/gb_tkp/gb_breakpoint.h
@@ -15,6 +15,7 @@ namespace TKPEmu::Gameboy::Utils {
 		bool PC_using = false; uint16_t PC_value = 0;
 		bool SP_using = false; uint16_t SP_value = 0;
 		bool Ins_using = false; uint16_t Ins_value = 0;
+		bool Clocks_using = false; unsigned long long Clocks_value;
 	};
 	struct GameboyBreakpoint {
 	public:
@@ -48,6 +49,7 @@ namespace TKPEmu::Gameboy::Utils {
 				if (Args.PC_using) { ss << "PC=" << std::hex << std::setw(4) << Args.PC_value << "&&"; }
 				if (Args.SP_using) { ss << "SP=" << std::hex << std::setw(4) << Args.SP_value << "&&"; BPFromTable = false; }
 				if (Args.Ins_using) { ss << "Ins=" << std::hex << std::setw(2) << Args.Ins_value << "&&"; BPFromTable = false; }
+				if (Args.Clocks_using) { ss << "Clocks=" << Args.Clocks_value << "&&"; BPFromTable = false; }
 				ss.seekp(-2, ss.cur);
 				ss << "  ";
 				name = ss.str();
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b4f4f55cf4b60ed9c8fa364d7b42df8b7ff388ce..a5bf5932eb999d3d8b616ae4406bf28b56323042 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2284,6 +2284,7 @@ namespace TKPEmu::Gameboy::Devices {
 			LY = 0x91;
 		}
 		TClock = 0;
+		TotalClocks = 0;
 		halt_ = false; stop_ = false;
 		ime_ = false;
 		JOYP = 0b1110'1111;
@@ -2294,7 +2295,9 @@ namespace TKPEmu::Gameboy::Devices {
 			ime_ = true;
 		if (halt_ && queued) {
 			halt_ = false; 
-		} else if (halt_) {
+			//PC++;
+		} else 
+		if (halt_) {
 			return 4;
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
@@ -2303,7 +2306,7 @@ namespace TKPEmu::Gameboy::Devices {
 		return tTemp;
 	}
 	bool CPU::handle_interrupts() {
-		if (auto temp = IE & IF; ime_ && IF) {
+		if (auto temp = IE & IF & 0x1F; ime_ && IF) {
 			// Starting from the lowest bit (highest priority) and going up,
 			// we are effectively queueing interrupts in case there's multiple.
 			for (int i = 0; i < 5; i++) {
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 3b7e956d9c7f5bfc6299e0cfff00c8950a980573..663f8b64811283237104a8ad36bca31b446953ec 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -277,6 +277,7 @@ namespace TKPEmu::Applications {
                 ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
                 ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
             }
+            ImGui::Text("Clocks: %d", t.TotalClocks);
             ImGui::Checkbox("Hex", &use_hex);
             ImGui::EndChild();
             // TODO: add switch from hex to binary on every textbox here
@@ -284,32 +285,33 @@ namespace TKPEmu::Applications {
                 ImGui::OpenPopup("Add breakpoint");
                 bp_add_popup = false;
             }
-            ImGui::SetNextWindowSize(ImVec2(250, 250));
+            ImGui::SetNextWindowSize(ImVec2(250, 350));
             ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
             if (ImGui::BeginPopupModal("Add breakpoint", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
                 ImGui::Text("Configure the breakpoint:");
                 ImGui::Separator();
                 static GBBPArguments bp_arg;
                 {
-                    ImGui::BeginChild("bpChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.9f));
-                    breakpoint_register_checkbox("A:", bp_arg.A_value, bp_arg.A_using);
-                    breakpoint_register_checkbox("B:", bp_arg.B_value, bp_arg.B_using);
-                    breakpoint_register_checkbox("D:", bp_arg.D_value, bp_arg.D_using);
-                    breakpoint_register_checkbox("H:", bp_arg.H_value, bp_arg.H_using);
-                    breakpoint_register_checkbox("PC:", bp_arg.PC_value, bp_arg.PC_using, ImGuiDataType_U16);
-                    breakpoint_register_checkbox("Instr:", bp_arg.Ins_value, bp_arg.Ins_using);
+                    ImGui::BeginChild("bpChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, ImGui::GetContentRegionAvail().y * 0.85f));
+                    breakpoint_register_checkbox("A:", "##A_reg", "%02x", bp_arg.A_value, bp_arg.A_using);
+                    breakpoint_register_checkbox("B:", "##B_reg", "%02x", bp_arg.B_value, bp_arg.B_using);
+                    breakpoint_register_checkbox("D:", "##D_reg", "%02x", bp_arg.D_value, bp_arg.D_using);
+                    breakpoint_register_checkbox("H:", "##H_reg", "%02x", bp_arg.H_value, bp_arg.H_using);
+                    breakpoint_register_checkbox("PC:", "##PC_reg", "%04x", bp_arg.PC_value, bp_arg.PC_using, 40, ImGuiDataType_U16);
+                    breakpoint_register_checkbox("Instr:", "##Instr", "%02x", bp_arg.Ins_value, bp_arg.Ins_using);
                     ImGui::EndChild();
                 }
                 ImGui::SameLine();
                 {
-                    ImGui::BeginChild("bpChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.9f));
-                    breakpoint_register_checkbox("F:", bp_arg.F_value, bp_arg.F_using);
-                    breakpoint_register_checkbox("C:", bp_arg.C_value, bp_arg.C_using);
-                    breakpoint_register_checkbox("E:", bp_arg.E_value, bp_arg.E_using);
-                    breakpoint_register_checkbox("L:", bp_arg.L_value, bp_arg.L_using);
-                    breakpoint_register_checkbox("SP:", bp_arg.SP_value, bp_arg.SP_using, ImGuiDataType_U16);
+                    ImGui::BeginChild("bpChildR", ImVec2(ImGui::GetContentRegionAvail().x, ImGui::GetContentRegionAvail().y * 0.85f));
+                    breakpoint_register_checkbox("F:", "##F_reg", "%02x", bp_arg.F_value, bp_arg.F_using);
+                    breakpoint_register_checkbox("C:", "##C_reg", "%02x", bp_arg.C_value, bp_arg.C_using);
+                    breakpoint_register_checkbox("E:", "##E_reg", "%02x", bp_arg.E_value, bp_arg.E_using);
+                    breakpoint_register_checkbox("L:", "##L_reg", "%02x", bp_arg.L_value, bp_arg.L_using);
+                    breakpoint_register_checkbox("SP:", "##SP_reg", "%04x", bp_arg.SP_value, bp_arg.SP_using, 40, ImGuiDataType_U16);
                     ImGui::EndChild();
                 }
+                breakpoint_register_checkbox("Clocks:", "##Clocks", "%d", bp_arg.Clocks_value, bp_arg.Clocks_using, 200, ImGuiDataType_U64);
                 if (ImGui::Button("Add", ImVec2(120, 0))) {
                     bool pc_only = gameboy->AddBreakpoint(bp_arg);
                     if (pc_only) {
diff --git a/TKPEmu/gb_tkp/gb_disassembler.h b/TKPEmu/gb_tkp/gb_disassembler.h
index 8435614653baec3cefa4fc9fbdfd336bb5029238..e874935bd2adc5813f53c0e439a93d11e2ebfb33 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.h
+++ b/TKPEmu/gb_tkp/gb_disassembler.h
@@ -31,17 +31,12 @@ namespace TKPEmu::Applications {
         void focus(int item);
 
         template<typename T>
-        void breakpoint_register_checkbox(const char* checkbox_l, T& value, bool& is_used, ImGuiDataType type = ImGuiDataType_U8) {
+        void breakpoint_register_checkbox(const char* checkbox_l, const char* label, const char* input_format, T& value, bool& is_used, int width = 20, ImGuiDataType type = ImGuiDataType_U8) {
             ImGui::Checkbox(checkbox_l, &is_used);
             if (is_used) {
                 ImGui::SameLine();
-                int w = 20;
-                if (type == ImGuiDataType_U16)
-                    w = 40;
-                ImGui::PushItemWidth(w);
-                char id[6] = "##IDt";
-                id[4] = checkbox_l[0];
-                ImGui::InputScalar(id, type, &value, 0, 0, w == 20 ? "%02X" : "%04X",
+                ImGui::PushItemWidth(width);
+                ImGui::InputScalar(label, type, &value, 0, 0, input_format,
                     ImGuiInputTextFlags_AllowTabInput | ImGuiInputTextFlags_CharsHexadecimal);
                 ImGui::PopItemWidth();
             }

From fbb261554e631b92f06f7a48c0ae91368c7e3be8 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 13 Dec 2021 19:10:18 +0200
Subject: [PATCH] Test suite implemented, can now run from console with '-t'

---
 TKPEmu/gb_tkp/gameboy.cpp    | 31 +++++++++++++++++++++++++++----
 TKPEmu/gb_tkp/gameboy.h      |  1 +
 TKPEmu/gb_tkp/gb_addresses.h | 28 ----------------------------
 3 files changed, 28 insertions(+), 32 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index fc3681868aa76c674f8e1b3ba07fe5bb821592b5..a1e0a22ddc9519a0de1663943638df0d4ead33ab 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -4,6 +4,7 @@
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
 #include "../lib/md5.h"
+#include "../include/console_colors.h"
 namespace TKPEmu::Gameboy {
 	Gameboy::Gameboy() : 
 		bus_(Instructions),
@@ -12,18 +13,18 @@ namespace TKPEmu::Gameboy {
 		timer_(&bus_),
 		joypad_(bus_.GetReference(addr_joy)),
 		interrupt_flag_(bus_.GetReference(addr_if))
-	{
-		init_image();
-	}
+	{}
 	Gameboy::Gameboy(GameboyKeys dirkeys, GameboyKeys actionkeys) :
 		Gameboy()
 	{
 		direction_keys_ = std::move(dirkeys);
 		action_keys_ = std::move(actionkeys);
+		init_image();
 	}
 	Gameboy::~Gameboy() {
 		Stopped.store(true);
-		glDeleteTextures(1, &EmulatorImage.texture);
+		if (start_options != EmuStartOptions::Console)
+			glDeleteTextures(1, &EmulatorImage.texture);
 	}
 	void Gameboy::SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr) {
 		log_types_ptr_ = std::move(types_ptr);
@@ -127,6 +128,28 @@ namespace TKPEmu::Gameboy {
 		UpdateThread = std::thread(func);
 		UpdateThread.detach();
 	}
+	void Gameboy::start_console() {
+		if (ScreenshotClocks == 0) {
+			std::cerr << color_error "Error: " color_reset "ScreenshotClocks not specified in emulator_results for this rom" << std::endl;
+			return;
+		}
+		Paused = false;
+		Stopped = false;
+		Reset();
+		while (!Stopped.load()) {
+			if (!Paused.load()) {
+				update();
+				if (cpu_.TotalClocks == ScreenshotClocks) {
+					if (ScreenshotHash == GetScreenshotHash()) {
+						std::cout << "[" << color_success << RomHash << color_reset "]: Passed" << std::endl;
+					} else {
+						std::cout << "[" << color_error << RomHash << color_reset "]: Failed" << std::endl;
+					}
+					Stopped = true;
+				}
+			}
+		}
+	}
 	void Gameboy::start_debug() {
 		auto func = [this]() {
 			std::lock_guard<std::mutex> lguard(ThreadStartedMutex);
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 216f0bdcfb7117d38663b71d67320a178fc3a119..28f346792aa8dee6b8933ffa94a8da346b5c69a7 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -58,6 +58,7 @@ namespace TKPEmu::Gameboy {
 		void v_log_state() override;
 		void start_normal() override;
 		void start_debug() override;
+		void start_console() override;
 		void reset_normal() override;
 		void reset_skip() override;
 		void load_file(std::string path) override;
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 3f39fceffda6975aaaa728fac571da6dc51de7e4..efb02e8cd99dac0e49289e29dc620fd311fcdbb6 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -49,34 +49,6 @@ struct ExpectedResult {
     // Represents the hash of the screenshot taken after Clocks
     Hash ExpectedHash;
 };
-// This map helps with quality assurance, we can check multiple test roms
-// at once and compare their finished hashes with these known good results
-const static std::unordered_map<Hash, ExpectedResult> PassedTestMap {
-    // blargg
-    // 01-special
-    { "7d95af543a521ed036dc85f6f232d103", { 1'300'000, "42d5abde92c2678617996dd8f782989c" } },
-    // 02-interrupts
-    { "d36a85bb94d4c1b373c0e7be0f6f0971", { 200'000, "0f384cd6115fd9b2c33f7d9fc42200b5" } },
-    // 03-op sp,hl
-    { "5bccf6b03f661d92b2903694d458510c", { 1'150'000, "3caaa1d70619add931ecfa9e88e3a7ff" } },
-    // 04-op r,imm
-    { "e97a5202d7725a3caaf3495e559f2e98", { 1'400'000, "cccde7fb4b57b51d73147233e2789d0e" } },
-    // 05-op rp
-    { "43fc8bfc94938b42d8ecc9ea8b6b811a", { 1'900'000, "2d0258217d9411ae7dc9390b4022e7fa" } },
-    // 06-ld r,r
-    { "24da4eed7ef73ec32aae5ffd50ebec55", { 300'000, "45f17918f8da5383982f33eda50b3714" } },
-    // 07-jr,jp,call,ret,rst
-    { "6dbf4e754ef2f844246fd08718d1c377", { 400'000, "c81680b1a44aab843cea7936de3da10f" } },
-    // 08-misc instrs
-    { "c21ddacbfa44d61919c8e2d6c3e7d26e", { 350'000, "820df31460734f4451ef46673a5e297c" } },
-    // 09-op r,r
-    { "e4c4dd4eebad0c9d6f2ef575331c3aee", { 4'500'000, "7a0cae7fe13aba1179096a74161dbd81" } },
-    // 10-bit ops
-    { "64632849778ee83ae85db8bf68c84ebc", { 7'000'000, "56d069d71d8b2114149a6a605df2ef28" } },
-    // 11-op a,(hl)
-    { "6e64346be4d7ccf26f53de105d6cb5f6", { 7'500'000, "3215a908fc7e7aac137f20b9dec08e9e" } },
-    
-};
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::InstrName, LogType::InstrNum,
     LogType::A, LogType::B, LogType::C, LogType::D,

From 95c5d893a3e02867ac8467f80493050307966c4b Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 13 Dec 2021 19:30:41 +0200
Subject: [PATCH] Printing filenames as passed/failed

---
 TKPEmu/gb_tkp/gameboy.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index a1e0a22ddc9519a0de1663943638df0d4ead33ab..938f5b43464e35fd7a738d6262bba115366980d5 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -141,9 +141,10 @@ namespace TKPEmu::Gameboy {
 				update();
 				if (cpu_.TotalClocks == ScreenshotClocks) {
 					if (ScreenshotHash == GetScreenshotHash()) {
-						std::cout << "[" << color_success << RomHash << color_reset "]: Passed" << std::endl;
+						// TODO: Print success protected function
+						std::cout << "[" << color_success << CurrentFilename << color_reset "]: Passed" << std::endl;
 					} else {
-						std::cout << "[" << color_error << RomHash << color_reset "]: Failed" << std::endl;
+						std::cout << "[" << color_error << CurrentFilename << color_reset "]: Failed" << std::endl;
 					}
 					Stopped = true;
 				}

From 917794614872c725d02ad813d002301723f45c94 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Tue, 14 Dec 2021 12:24:37 +0200
Subject: [PATCH] mbc3 changes

---
 TKPEmu/gb_tkp/gb_bus.cpp | 15 +++++++++------
 TKPEmu/gb_tkp/gb_bus.h   |  1 +
 TKPEmu/gb_tkp/gb_cpu.cpp | 41 +++++++++++++++++++++++++++++++++++++++--
 TKPEmu/gb_tkp/gb_cpu.h   |  2 +-
 4 files changed, 50 insertions(+), 9 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index ab7ac72731450d1db30b30aa30facec3c2cec44e..856b025c2087d6d0410f8be37a512ae5a89c89e3 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -53,17 +53,20 @@ namespace TKPEmu::Gameboy::Devices {
 					}
 				}
 				else if (address <= 0x3FFF) {
-					// BANK register 1 (TODO: this doesnt happen on mbc0?)
 					selected_rom_bank_ &= 0b1100000;
 					selected_rom_bank_ |= data & 0b11111;
 					selected_rom_bank_ %= rom_banks_size_;
+					//redirect_address(address) = selected_ram_bank_ & 0b1111111;
 				}
 				else if (address <= 0x5FFF) {
-					// BANK register 2
-					selected_rom_bank_ &= 0b11111;
-					selected_rom_bank_ |= ((data & 0b11) << 5);
-					selected_rom_bank_ %= rom_banks_size_;
-					selected_ram_bank_ = data & 0b11;
+					if (data <= 0b11) {
+						selected_rom_bank_ &= 0b11111;
+						selected_rom_bank_ |= ((data & 0b11) << 5);
+						selected_rom_bank_ %= rom_banks_size_;
+						selected_ram_bank_ = data & 0b11; 
+					} else {
+						// TODO: mbc3 rtc
+					}
 				}
 				else {
 					// MODE register
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 9811609dc644527251898cb7168de7d00653d615..99221839cfe242889c7deb2985c61a4a2a146858 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -78,6 +78,7 @@ namespace TKPEmu::Gameboy::Devices {
         uint8_t ActionKeys = 0b1101'1111;
     private:
         bool ram_enabled_ = false;
+        bool rtc_enabled_ = false;
         uint8_t selected_ram_bank_ = 0;
         uint8_t selected_rom_bank_ = 1;
         uint8_t rom_banks_size_ = 2;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index a5bf5932eb999d3d8b616ae4406bf28b56323042..cb16bce0d64c072a2ad8837db3682c1d28943e51 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1366,6 +1366,10 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::HALT() {
 		halt_ = true;
+		if ((IE & IF & 0x1F) && ime_ == 0) {
+			std::cout << "halt bug" << std::endl;
+			halt_ = false;
+		}
 		tTemp = 4;
 	}
 	void CPU::XXX() {
@@ -2290,13 +2294,20 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
-		bool queued = handle_interrupts();
+		/*bool queued = handle_interrupts();
 		if (ime_scheduled_)
 			ime_ = true;
 		if (halt_ && queued) {
 			halt_ = false; 
 			//PC++;
 		} else 
+		if (halt_) {
+			return 4;
+		}*/
+		handle_interrupts();
+		if (ime_scheduled_) {
+			ime_ = true;
+		}
 		if (halt_) {
 			return 4;
 		}
@@ -2305,7 +2316,28 @@ namespace TKPEmu::Gameboy::Devices {
 		TotalClocks += 1;
 		return tTemp;
 	}
-	bool CPU::handle_interrupts() {
+	void CPU::handle_interrupts() {
+		uint8_t interr_bits = IF & IE & 0x1F;
+		if (interr_bits != 0) {
+			if (ime_) {
+				for (int i = 0; i < 5; i++) {
+					auto bit = (interr_bits >> i) & 0x1;
+					if (bit) {
+						execute_interrupt(i);
+						halt_ = false;
+						return;
+					}
+				}	
+			} else {
+				if (halt_) {
+					halt_ = false;
+					tTemp = 4;
+					return;
+				}
+			}
+		}
+		halt_ = false; // maybe remove?
+		/*
 		if (auto temp = IE & IF & 0x1F; ime_ && IF) {
 			// Starting from the lowest bit (highest priority) and going up,
 			// we are effectively queueing interrupts in case there's multiple.
@@ -2320,6 +2352,7 @@ namespace TKPEmu::Gameboy::Devices {
 			return true;
 		else 
 			return false;
+			*/
 	}
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;
@@ -2327,5 +2360,9 @@ namespace TKPEmu::Gameboy::Devices {
 		SP -= 2;
 		bus_->WriteL(SP, PC);
 		PC = 0x40 + bit * 0x8;
+		tTemp = 20;
+		if (halt_) {
+			tTemp = 24;
+		}
 	}
 }
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 1d9818c1f5c9a2d15eb5d8cb4be06f30c96efdb7..0ead26f0e459600d50286bc2918e0ce07a9daf68 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -86,7 +86,7 @@ namespace TKPEmu::Gameboy::Devices {
 		void bit_sr(RegisterType& reg);
 		void bit_srl(RegisterType& reg);
 		void rst(RegisterType addr);
-		bool handle_interrupts();
+		void handle_interrupts();
 		void execute_interrupt(int bit);
 		void update_timers(int cycles);
 		int get_clk_freq();

From d9ab8877d8f0d98dc9907ffaffca5b9608f3ea10 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Tue, 14 Dec 2021 12:41:44 +0200
Subject: [PATCH] mbc3 banking fixes, pokemon red should run normally

---
 TKPEmu/gb_tkp/gb_bus.cpp | 20 +++++++-------------
 1 file changed, 7 insertions(+), 13 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 856b025c2087d6d0410f8be37a512ae5a89c89e3..3e1522bb8217930b3d6bb33c26139cccd30483f0 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -53,17 +53,14 @@ namespace TKPEmu::Gameboy::Devices {
 					}
 				}
 				else if (address <= 0x3FFF) {
-					selected_rom_bank_ &= 0b1100000;
-					selected_rom_bank_ |= data & 0b11111;
-					selected_rom_bank_ %= rom_banks_size_;
-					//redirect_address(address) = selected_ram_bank_ & 0b1111111;
+					selected_rom_bank_ = data & 0b0111'1111;
+					if (selected_rom_bank_ == 0) {
+						selected_rom_bank_ = 1;
+					}
 				}
 				else if (address <= 0x5FFF) {
 					if (data <= 0b11) {
-						selected_rom_bank_ &= 0b11111;
-						selected_rom_bank_ |= ((data & 0b11) << 5);
-						selected_rom_bank_ %= rom_banks_size_;
-						selected_ram_bank_ = data & 0b11; 
+						selected_ram_bank_ = data & (cartridge_->GetRamSize() - 1); 
 					} else {
 						// TODO: mbc3 rtc
 					}
@@ -147,10 +144,6 @@ namespace TKPEmu::Gameboy::Devices {
 						}
 						else {
 							auto sel = selected_rom_bank_ % cartridge_->GetRomSize();
-							if (sel == 0) {
-								// Accessing 20/40/60 is supported in mbc3
-								sel += 1;
-							}
 							return (rom_banks_[sel])[address % 0x4000];
 						}
 						break;
@@ -170,7 +163,8 @@ namespace TKPEmu::Gameboy::Devices {
 				if (ram_enabled_) {
 					if (cartridge_->GetRamSize() == 0)
 						return eram_default_[address % 0x2000];
-					auto sel = (banking_mode_ ? selected_ram_bank_ : 0) % cartridge_->GetRamSize();
+					auto sel = (banking_mode_ ? selected_ram_bank_ : 0);
+					std::cout << cartridge_->GetRamSize() << std::endl;
 					return (ram_banks_[sel])[address % 0x2000];
 				} else {
 					unused_mem_area_ = 0xFF;

From d5c964fc634c766e9f8a77af4a10b58715b21c36 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Tue, 14 Dec 2021 12:44:56 +0200
Subject: [PATCH] useless comment removal

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 28 +---------------------------
 1 file changed, 1 insertion(+), 27 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index cb16bce0d64c072a2ad8837db3682c1d28943e51..9c91d1fb6c5e8a72d5449ba889e126d504fa8e7e 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2294,16 +2294,6 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
-		/*bool queued = handle_interrupts();
-		if (ime_scheduled_)
-			ime_ = true;
-		if (halt_ && queued) {
-			halt_ = false; 
-			//PC++;
-		} else 
-		if (halt_) {
-			return 4;
-		}*/
 		handle_interrupts();
 		if (ime_scheduled_) {
 			ime_ = true;
@@ -2336,23 +2326,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 		}
-		halt_ = false; // maybe remove?
-		/*
-		if (auto temp = IE & IF & 0x1F; ime_ && IF) {
-			// Starting from the lowest bit (highest priority) and going up,
-			// we are effectively queueing interrupts in case there's multiple.
-			for (int i = 0; i < 5; i++) {
-				if (auto bit = (temp >> i) & 0x1; bit) {
-					execute_interrupt(i);
-					return true;
-				}
-			}
-		}
-		if (IF & IE) 
-			return true;
-		else 
-			return false;
-			*/
+		halt_ = false;
 	}
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;

From 9705ba564616e8a594308477e7dc13a999564341 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Tue, 14 Dec 2021 14:25:05 +0200
Subject: [PATCH] Added gameboyromdata class, early

---
 TKPEmu/gb_tkp/gameboy.cpp      |  3 +++
 TKPEmu/gb_tkp/gameboy.h        |  2 +-
 TKPEmu/gb_tkp/gb_bus.cpp       |  6 ++++--
 TKPEmu/gb_tkp/gb_bus.h         |  3 ++-
 TKPEmu/gb_tkp/gb_cartridge.cpp | 48 +++++++++++++++++++++++++++++++++++++-----
 TKPEmu/gb_tkp/gb_cartridge.h   | 11 +++++++---
 TKPEmu/gb_tkp/gb_romdata.cpp   | 12 +++++++++++
 TKPEmu/gb_tkp/gb_romdata.h     | 17 +++++++++++++++
 8 files changed, 90 insertions(+), 12 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 938f5b43464e35fd7a738d6262bba115366980d5..6e5887ed047507cd74e6ba7e88c68e577685a9d6 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -331,6 +331,9 @@ namespace TKPEmu::Gameboy {
 	float* Gameboy::GetScreenData() {
 		return ppu_.GetScreenData();
 	}
+	const Devices::Cartridge* const Gameboy::GetCartridge() const {
+		return bus_.GetCartridge();
+	}
 	const auto& Gameboy::GetOpcodeDescription(uint8_t opc) {
 		return cpu_.Instructions[opc].name;
 	}
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 28f346792aa8dee6b8933ffa94a8da346b5c69a7..ef908baed92ea32124e43238967a8eaa76b647cd 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -38,6 +38,7 @@ namespace TKPEmu::Gameboy {
 		void RemoveBreakpoint(int index);
 		const auto& GetOpcodeDescription(uint8_t opc);
 		GameboyPalettes& GetPalette();
+		const Cartridge* const GetCartridge() const;
 		CPU& GetCPU() { return cpu_; }
 		std::vector<GameboyBreakpoint> Breakpoints{};
 		std::vector<DisInstr> Instructions{};
@@ -46,7 +47,6 @@ namespace TKPEmu::Gameboy {
 		CPU cpu_;
 		PPU ppu_;
 		Timer timer_;
-		Cartridge cartridge_;
 		GameboyKeys direction_keys_;
 		GameboyKeys action_keys_;
 		uint8_t& joypad_, &interrupt_flag_;
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 3e1522bb8217930b3d6bb33c26139cccd30483f0..c2b0c4e5d062f2ea66337d80a48a366bc4455cb2 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -164,7 +164,6 @@ namespace TKPEmu::Gameboy::Devices {
 					if (cartridge_->GetRamSize() == 0)
 						return eram_default_[address % 0x2000];
 					auto sel = (banking_mode_ ? selected_ram_bank_ : 0);
-					std::cout << cartridge_->GetRamSize() << std::endl;
 					return (ram_banks_[sel])[address % 0x2000];
 				} else {
 					unused_mem_area_ = 0xFF;
@@ -389,9 +388,12 @@ namespace TKPEmu::Gameboy::Devices {
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;
 	}
+	const Cartridge* const Bus::GetCartridge() const {
+		return cartridge_.get();
+	}
 	void Bus::LoadCartridge(std::string fileName) {
 		Reset();
-		cartridge_ = std::unique_ptr<Cartridge>(new Cartridge());
+		cartridge_ = std::make_unique<Cartridge>();
 		cartridge_->Load(fileName, rom_banks_, ram_banks_);
 		rom_banks_size_ = cartridge_->GetRomSize();
 	}
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 99221839cfe242889c7deb2985c61a4a2a146858..35315a95bf1772e236186e3d3127ec14488c4d20 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -63,10 +63,11 @@ namespace TKPEmu::Gameboy::Devices {
         void WriteL(uint16_t address, uint16_t data);
         void Reset();
         void SoftReset();
+        const Cartridge* const GetCartridge() const;
         void LoadCartridge(std::string fileName);
         std::string GetVramDump();
         std::array<std::array<float, 3>, 4> Palette;
-        std::array<uint8_t, 4> BGPalette{};
+        std::array<uint8_t, 4> BGPalette{};const Cartridge* const GetCartridge();
         std::array<uint8_t, 4> OBJ0Palette{};
         std::array<uint8_t, 4> OBJ1Palette{};
         std::array<Sprite, 40> OAM;
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 33a6494bd96eb7d970cce1ec5532f2ec7d673b26..68d5fcea52993a6f4532c6db50895ab714b2f87d 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -40,18 +40,18 @@ namespace TKPEmu::Gameboy::Devices {
 			std::cerr << "Error: Could not open file" << std::endl;
 		}
 	}
-	CartridgeType Cartridge::GetCartridgeType() {
+	CartridgeType Cartridge::GetCartridgeType() const {
 		if (loaded) {
 			return (CartridgeType)header_.cartridgeType;
 		}
 		return CartridgeType::ERROR;
 	}
-	// Returns the number of 8KB RAM banks
-	int Cartridge::GetRamSize() {
+	int Cartridge::GetRamSize() const {
+		// Returns the number of 8KB RAM banks
 		return ram_sizes_[header_.ramSize];
 	}
-	// Returns the number of 16kb ROM banks
-	int Cartridge::GetRomSize() {
+	int Cartridge::GetRomSize() const {
+		// Returns the number of 16kb ROM banks
 		switch (header_.romSize) {
 		// Likely inaccurate according to pandocs, no roms using these are known
 		[[unlikely]] case 0x52: return 72;
@@ -61,4 +61,42 @@ namespace TKPEmu::Gameboy::Devices {
 			return std::pow(2, (header_.romSize + 1));
 		}
 	}
+	bool Cartridge::IsGameboyColor() const {
+		return header_.gameboyColor;
+	}
+	const char* Cartridge::GetCartridgeName() const {
+		return header_.name;
+	}
+	const char* Cartridge::GetCartridgeTypeName() const {
+		auto ct = GetCartridgeType();
+		switch (ct) {
+			case CartridgeType::ROM_ONLY: {
+				return "None (32Kb rom)";
+			}
+			case CartridgeType::MBC1: {
+				return "MBC1";
+			}
+			case CartridgeType::MBC1_RAM: {
+				return "MBC1 w/ RAM";
+			}
+			case CartridgeType::MBC1_RAM_BATTERY: {
+				return "MBC1 w/ RAM, BATTERY";
+			}
+			case CartridgeType::MBC3: {
+				return "MBC3";
+			}
+			case CartridgeType::MBC3_RAM: {
+				return "MBC3 w/ RAM";
+			}
+			case CartridgeType::MBC3_RAM_BATTERY: {
+				return "MBC3 w/ RAM, BATTERY";
+			}
+			case CartridgeType::MBC3_TIMER_RAM_BATTERY: {
+				return "MBC3 w/ RAM, BATTERY, TIMER";
+			}
+			default: {
+				return  std::to_string(static_cast<int>(ct)).c_str();
+			}
+		}
+	}
 }
diff --git a/TKPEmu/gb_tkp/gb_cartridge.h b/TKPEmu/gb_tkp/gb_cartridge.h
index 2cc714fed38b87364727bab4a221d47b5907b8bb..5dfe862c963ac626d36fbea1987a7b417bbe6430 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.h
+++ b/TKPEmu/gb_tkp/gb_cartridge.h
@@ -33,6 +33,8 @@ namespace TKPEmu::Gameboy::Devices {
 		MBC5_RUMBLE = 0x1C,
 		MBC5_RUMBLE_RAM = 0x1D,
 		MBC5_RUMBLE_RAM_BATTERY = 0x1E,
+		MBC6_RAM_BATTERY = 0x20,
+		MBC7_RAM_BATTERY_ACCELEROMETER = 0x22,
 		POCKET_CAMERA = 0xFC,
 		BANDAITAMA5 = 0xFD,
 		HuC3 = 0xFE,
@@ -54,9 +56,12 @@ namespace TKPEmu::Gameboy::Devices {
 		bool loaded;
 	public:
 		void Load(const std::string& fileName, std::vector<std::array<uint8_t, 0x4000>>& romBanks, std::vector<std::array<uint8_t, 0x2000>>& ramBanks);
-		CartridgeType GetCartridgeType();
-		int GetRamSize();
-		int GetRomSize();
+		CartridgeType GetCartridgeType() const;
+		int GetRamSize() const;
+		int GetRomSize() const;
+		bool IsGameboyColor() const;
+		const char* GetCartridgeTypeName() const;
+		const char* GetCartridgeName() const;
 	};
 }
 #endif
diff --git a/TKPEmu/gb_tkp/gb_romdata.cpp b/TKPEmu/gb_tkp/gb_romdata.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..99a36c8b98ae4afd9329be9b62cc35c13bc83fbd
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_romdata.cpp
@@ -0,0 +1,12 @@
+#include "gb_romdata.h"
+namespace TKPEmu::Applications {
+    GameboyRomData::GameboyRomData(std::string menu_title, std::string window_title) 
+        : IMApplication(menu_title, window_title) 
+    {
+        max_size = ImVec2(400, 400);
+    }
+    void GameboyRomData::v_draw() {
+        static Gameboy* gb_ptr = static_cast<Gameboy*>(emulator_);
+        ImGui::Text(gb_ptr->GetCartridge()->GetCartridgeTypeName());
+    }
+}
\ No newline at end of file
diff --git a/TKPEmu/gb_tkp/gb_romdata.h b/TKPEmu/gb_tkp/gb_romdata.h
new file mode 100644
index 0000000000000000000000000000000000000000..35094c97cfd588d5023e0af7fe802a669ee01fa3
--- /dev/null
+++ b/TKPEmu/gb_tkp/gb_romdata.h
@@ -0,0 +1,17 @@
+#pragma once
+#ifndef TKPEMU_GB_ROMDATA_H
+#define TKPEMU_GB_ROMDATA_H
+#include <string>
+#include "../include/base_application.h"
+#include "gameboy.h"
+#include "gb_cartridge.h"
+namespace TKPEmu::Applications {
+    using Gameboy = TKPEmu::Gameboy::Gameboy;
+    class GameboyRomData : public IMApplication {
+    public:
+        GameboyRomData(std::string menu_title, std::string window_title);
+    private:
+        void v_draw() override;
+    };
+}
+#endif
\ No newline at end of file

From f5b124f1e682b9facae9d84342fbe6eeb3785f67 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 01:20:35 +0200
Subject: [PATCH] some logging changes to match bizhawk tracelogger

---
 TKPEmu/gb_tkp/gameboy.cpp    |  2 +-
 TKPEmu/gb_tkp/gb_addresses.h | 12 ++++++------
 TKPEmu/gb_tkp/gb_cpu.cpp     |  4 +++-
 3 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 6e5887ed047507cd74e6ba7e88c68e577685a9d6..e1aad9efec2aac2d76dfc71a99e1b8926c24ead7 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -47,7 +47,7 @@ namespace TKPEmu::Gameboy {
 					break;
 				}
 				case LogType::PC: {
-					*ofstream_ptr_ << "PC:" << std::setw(4) << std::hex <<  cpu_.PC;
+					*ofstream_ptr_ << std::setw(4) << std::hex << cpu_.PC << ":";
 					break;
 				}
 				case LogType::SP: {
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index efb02e8cd99dac0e49289e29dc620fd311fcdbb6..469e3e67b5425adff109f19c4b162bbca71214ea 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -10,10 +10,10 @@ using DisInstr = TKPEmu::Tools::DisInstr;
 using GBBPArguments = TKPEmu::Gameboy::Utils::GBBPArguments;
 constexpr size_t LogTypeSize = 17;
 enum class LogType {
-    InstrName, InstrNum,
+    PC, InstrName, InstrNum,
     A, B, C, D, 
     E, F, H, L,
-    PC, SP, LY,
+    LY, SP, 
     IF, IE, IME, HALT
 };
 enum LCDCFlag {
@@ -50,17 +50,17 @@ struct ExpectedResult {
     Hash ExpectedHash;
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
-    LogType::InstrName, LogType::InstrNum,
+    LogType::PC, LogType::InstrName, LogType::InstrNum,
     LogType::A, LogType::B, LogType::C, LogType::D,
     LogType::E, LogType::F, LogType::H, LogType::L,
-    LogType::PC, LogType::SP, LogType::LY, LogType::IF,
+    LogType::LY, LogType::SP, LogType::IF,
     LogType::IE, LogType::IME, LogType::HALT
 };
 const static std::array<std::string, LogTypeSize> LogTypeNames {
-    "Instr. ", "Opcode ",
+    "PC     ", "Instr. ", "Opcode ",
     "A      ", "B      ", "C      ", "D      ",
     "E      ", "F      ", "H      ", "L      ",
-    "PC     ", "SP     ", "LY     ", "IF     ",
+    "LY     ", "SP     ", "IF     ",
     "IE     ", "IME    ", "HALT   ",
 };
 constexpr std::array<uint8_t, 0x100> InstrTimes = {
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 9c91d1fb6c5e8a72d5449ba889e126d504fa8e7e..bbad19bd06b8669c67856df55fe6c2d76c3d3232 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2290,13 +2290,14 @@ namespace TKPEmu::Gameboy::Devices {
 		TClock = 0;
 		TotalClocks = 0;
 		halt_ = false; stop_ = false;
-		ime_ = false;
+		ime_ = false; ime_scheduled_ = false;
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
 		handle_interrupts();
 		if (ime_scheduled_) {
 			ime_ = true;
+			ime_scheduled_ = false;
 		}
 		if (halt_) {
 			return 4;
@@ -2330,6 +2331,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;
+		ime_scheduled_ = false;
 		IF &= ~(1U << bit);
 		SP -= 2;
 		bus_->WriteL(SP, PC);

From c5262dca99a3296e83bf903f6fdded998660d94d Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 11:30:22 +0200
Subject: [PATCH] halt ime0 pass, ime1 pass, ppu tests start dmgacid still
 bugged

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index bbad19bd06b8669c67856df55fe6c2d76c3d3232..dadd204e6a0cd666b2764870070d2bc664c8fd55 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1370,6 +1370,10 @@ namespace TKPEmu::Gameboy::Devices {
 			std::cout << "halt bug" << std::endl;
 			halt_ = false;
 		}
+		if (ime_scheduled_) {
+			ime_ = true;
+			ime_scheduled_ = false;
+		}
 		tTemp = 4;
 	}
 	void CPU::XXX() {
@@ -2327,7 +2331,6 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 		}
-		halt_ = false;
 	}
 	void CPU::execute_interrupt(int bit) {
 		ime_ = false;

From 398011a14e16232f7f4199181cb32ddd79d1f906 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 12:58:18 +0200
Subject: [PATCH] changes on ppu and console commands

---
 TKPEmu/gb_tkp/gameboy.h  | 1 -
 TKPEmu/gb_tkp/gb_ppu.cpp | 7 ++++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index ef908baed92ea32124e43238967a8eaa76b647cd..6b6b1b2905edcaf79a319c9e78f7d6a67e3456aa 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -24,7 +24,6 @@ namespace TKPEmu::Gameboy {
 		using DisInstr = TKPEmu::Tools::DisInstr;
 		using GameboyBreakpoint = TKPEmu::Gameboy::Utils::GameboyBreakpoint;
 	public:
-		// TODO: use unordered_map or map (key = sdl_key value = 1<<i <SDL_Keycode, int>)
 		Gameboy();
 		Gameboy(GameboyKeys dirkeys, GameboyKeys actionkeys);
 		~Gameboy();
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index e101fc0b2eedf24fc410e5fc389d6b5b78a20bf6..31350a074b781c9df705d980777dd25abab4b939 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -14,9 +14,8 @@ namespace TKPEmu::Gameboy::Devices {
 		IF(bus->GetReference(0xFF0F))
 	{}
 	void PPU::Update(uint8_t cycles) {
-		IF &= 0b11111110;
-		clock_ += cycles;
 		if (LCDC & LCDCFlag::LCD_ENABLE) {
+			clock_ += cycles;
 			if (clock_ >= clock_target_) {
 				if (LY == 153) {
 					next_stat_mode = 2;
@@ -25,7 +24,8 @@ namespace TKPEmu::Gameboy::Devices {
 					clock_target_ = FRAME_CYCLES;
 				}
 				IF |= set_mode(next_stat_mode);
-				if (int mode = get_mode(); mode == 2) {
+				int mode = get_mode(); 
+				if (mode == 2) {
 					clock_target_ += 80;
 					next_stat_mode = 3;
 					LY += 1;
@@ -58,6 +58,7 @@ namespace TKPEmu::Gameboy::Devices {
 			}
 		}
 		else {
+			LY = 0;
 			if (clock_ >= FRAME_CYCLES) {
 				clock_ %= FRAME_CYCLES;
 			}

From 82cc241acf0018a3ad99cbce63978b3045c51e95 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 18:15:02 +0200
Subject: [PATCH] random bug fixes

---
 TKPEmu/gb_tkp/gb_romdata.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_romdata.cpp b/TKPEmu/gb_tkp/gb_romdata.cpp
index 99a36c8b98ae4afd9329be9b62cc35c13bc83fbd..54e8bff2b9e1689ca0e598a9ee92b5842f4d7cd2 100644
--- a/TKPEmu/gb_tkp/gb_romdata.cpp
+++ b/TKPEmu/gb_tkp/gb_romdata.cpp
@@ -6,7 +6,7 @@ namespace TKPEmu::Applications {
         max_size = ImVec2(400, 400);
     }
     void GameboyRomData::v_draw() {
-        static Gameboy* gb_ptr = static_cast<Gameboy*>(emulator_);
+        Gameboy* gb_ptr = static_cast<Gameboy*>(emulator_);
         ImGui::Text(gb_ptr->GetCartridge()->GetCartridgeTypeName());
     }
 }
\ No newline at end of file

From 4b157b777cc1c3450d8faa71c8684e02049c9704 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 23:14:30 +0200
Subject: [PATCH] oam dma fixes, add_sp_timing booting fix

---
 TKPEmu/gb_tkp/gb_addresses.h |  8 ++++----
 TKPEmu/gb_tkp/gb_bus.cpp     | 12 ++++++++----
 TKPEmu/gb_tkp/gb_bus.h       |  1 +
 3 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 469e3e67b5425adff109f19c4b162bbca71214ea..4e9294c08ba8b237b1eac6be6b2cf840756c1461 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -51,15 +51,15 @@ struct ExpectedResult {
 };
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::PC, LogType::InstrName, LogType::InstrNum,
-    LogType::A, LogType::B, LogType::C, LogType::D,
-    LogType::E, LogType::F, LogType::H, LogType::L,
+    LogType::A, LogType::F, LogType::B, LogType::C,
+    LogType::D, LogType::E,  LogType::H, LogType::L,
     LogType::LY, LogType::SP, LogType::IF,
     LogType::IE, LogType::IME, LogType::HALT
 };
 const static std::array<std::string, LogTypeSize> LogTypeNames {
     "PC     ", "Instr. ", "Opcode ",
-    "A      ", "B      ", "C      ", "D      ",
-    "E      ", "F      ", "H      ", "L      ",
+    "A      ", "F      ", "B      ", "C      ",
+    "D      ", "E      ", "H      ", "L      ",
     "LY     ", "SP     ", "IF     ",
     "IE     ", "IME    ", "HALT   ",
 };
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index c2b0c4e5d062f2ea66337d80a48a366bc4455cb2..2c49e523755a4f4f5bd72eeee533d24036e33ba1 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -270,10 +270,14 @@ namespace TKPEmu::Gameboy::Devices {
 					for (int i = 0; i <= (0x9F - 4); i += 4) {
 						uint16_t source = dma_addr | i;
 						// Each sprite is 4 bytes, so the array has size of 160/4 = 40 
-						OAM[i / 4].y_pos      = Read(source);
-						OAM[i / 4].x_pos      = Read(source + 1);
-						OAM[i / 4].tile_index = Read(source + 2);
-						OAM[i / 4].flags      = Read(source + 3);
+						oam_[i]         = ReadSafe(source);
+						oam_[i + 1]     = ReadSafe(source + 1);
+						oam_[i + 2]     = ReadSafe(source + 2);
+						oam_[i + 3]     = ReadSafe(source + 3);
+						OAM[i / 4].y_pos      = oam_[i];
+						OAM[i / 4].x_pos      = oam_[i + 1];
+						OAM[i / 4].tile_index = oam_[i + 2];
+						OAM[i / 4].flags      = oam_[i + 3];
 					}
 					break;
 				}
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 35315a95bf1772e236186e3d3127ec14488c4d20..8264186942d51a20549a36a89705ccc0dba7e48c 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -70,6 +70,7 @@ namespace TKPEmu::Gameboy::Devices {
         std::array<uint8_t, 4> BGPalette{};const Cartridge* const GetCartridge();
         std::array<uint8_t, 4> OBJ0Palette{};
         std::array<uint8_t, 4> OBJ1Palette{};
+        // TODO: remove big OAM
         std::array<Sprite, 40> OAM;
         bool DIVReset = false;
         bool TACChanged = false;

From 6a0f67c0e01a48c6b707944a71dcc790b35936b7 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Wed, 15 Dec 2021 23:25:04 +0200
Subject: [PATCH] Update README.md

---
 TKPEmu/gb_tkp/README.md | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index f3d3b05bdecfca634a113921ce3b826489bcf4cb..98dbffea0c04eac5e917ddae82e995d5a46794cf 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -18,7 +18,7 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 | Test | GameboyTKP  |
 |--|--|
 | cpu_instrs |  |
-| instr_timing |  (Issue [#3](https://github.com/OFFTKP/TKPEmu/issues/3))|
+| instr_timing |  |
 | mem_timing |  |
 | dmg_sound |  |
 | oam_bug |  |
@@ -58,15 +58,15 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 | emulator-only/mbc1/bits_bank1 |  | 
 | emulator-only/mbc1/bits_bank2 |  | 
 | emulator-only/mbc1/bits_mode |  | 
-| emulator-only/mbc1/bits_ramg |  | 
+| emulator-only/mbc1/bits_ramg |  | 
 | emulator-only/mbc1/multicart_rom_8Mb |  | 
-| emulator-only/mbc1/ram_256kb |  | 
-| emulator-only/mbc1/ram_64kb |  | 
+| emulator-only/mbc1/ram_256kb |  | 
+| emulator-only/mbc1/ram_64kb |  | 
 | emulator-only/mbc1/rom_16Mb |  | 
 | emulator-only/mbc1/rom_1Mb |  (multicart) | 
 | emulator-only/mbc1/rom_2Mb |  (multicart) | 
 | emulator-only/mbc1/rom_4Mb |  | 
-| emulator-only/mbc1/rom_512kb |  |
+| emulator-only/mbc1/rom_512kb |  (multicart) |
 | emulator-only/mbc1/rom_8Mb |  | 
 
 **[mattcurie](https://github.com/mattcurrie)'s tests:**

From 9e0889e205ec88abee8292c6e68e16290e8d325f Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 13:59:58 +0200
Subject: [PATCH] added parallel testing and simple result generation

---
 TKPEmu/gb_tkp/gameboy.cpp    | 11 +++++++----
 TKPEmu/gb_tkp/gb_addresses.h |  8 --------
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index e1aad9efec2aac2d76dfc71a99e1b8926c24ead7..e5f2b3f09be059c3f5136a63c3e3f54b139ca829 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -1,6 +1,7 @@
 #include <iostream>
 #include <atomic>
 #include <chrono>
+#include <syncstream>
 #include "../glad/glad/glad.h"
 #include "gameboy.h"
 #include "../lib/md5.h"
@@ -130,7 +131,7 @@ namespace TKPEmu::Gameboy {
 	}
 	void Gameboy::start_console() {
 		if (ScreenshotClocks == 0) {
-			std::cerr << color_error "Error: " color_reset "ScreenshotClocks not specified in emulator_results for this rom" << std::endl;
+			// Unknown rom
 			return;
 		}
 		Paused = false;
@@ -140,11 +141,13 @@ namespace TKPEmu::Gameboy {
 			if (!Paused.load()) {
 				update();
 				if (cpu_.TotalClocks == ScreenshotClocks) {
+					std::osyncstream scout(std::cout);
 					if (ScreenshotHash == GetScreenshotHash()) {
-						// TODO: Print success protected function
-						std::cout << "[" << color_success << CurrentFilename << color_reset "]: Passed" << std::endl;
+						scout << "[" << color_success << CurrentFilename << color_reset "]: Passed" << std::endl;
+						Result = TKPEmu::Testing::TestResult::Passed;
 					} else {
-						std::cout << "[" << color_error << CurrentFilename << color_reset "]: Failed" << std::endl;
+						scout << "[" << color_error << CurrentFilename << color_reset "]: Failed" << std::endl;
+						Result = TKPEmu::Testing::TestResult::Failed;
 					}
 					Stopped = true;
 				}
diff --git a/TKPEmu/gb_tkp/gb_addresses.h b/TKPEmu/gb_tkp/gb_addresses.h
index 4e9294c08ba8b237b1eac6be6b2cf840756c1461..1d6cfe363d61ab10eba5b1a176f2ee2e98878c04 100644
--- a/TKPEmu/gb_tkp/gb_addresses.h
+++ b/TKPEmu/gb_tkp/gb_addresses.h
@@ -41,14 +41,6 @@ enum IFInterrupt {
     SERIAL = 1 << 3,
     JOYPAD = 1 << 4
 };
-// Used in the map below, to compare rom hashes with expected results after
-// a hardcoded number of clocks
-using Hash = std::string;
-struct ExpectedResult {
-    unsigned long long Clocks;
-    // Represents the hash of the screenshot taken after Clocks
-    Hash ExpectedHash;
-};
 constexpr static std::array<LogType, LogTypeSize> LogTypeMap {
     LogType::PC, LogType::InstrName, LogType::InstrNum,
     LogType::A, LogType::F, LogType::B, LogType::C,

From 10cba36db00b93d2cf46a6afa72f54c8500a92ba Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:37:31 +0200
Subject: [PATCH] added automated test generation script and other arguments

---
 TKPEmu/gb_tkp/TEST_RESULTS.md          | 16 ++++++++++++++++
 TKPEmu/gb_tkp/gameboy.cpp              |  3 +++
 TKPEmu/gb_tkp/gameboy.h                |  1 +
 TKPEmu/gb_tkp/generate_test_results.sh | 22 ++++++++++++++++++++++
 4 files changed, 42 insertions(+)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
new file mode 100644
index 0000000000000000000000000000000000000000..feda6c632b48efbd8f6c8b9e1e07776d557ab166
--- /dev/null
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -0,0 +1,16 @@
+GameboyTKP test results generated by  on Thu Dec 16 03:35:40 PM EET 2021.\n
+**[Blargg](https://github.com/gblargg)'s tests:**
+| Test | GameboyTKP |
+| -- | -- |
+| 01-special.gb | :+1: |
+| 02-interrupts.gb | :+1: |
+| 03-op sp,hl.gb | :+1: |
+| 04-op r,imm.gb | :+1: |
+| 05-op rp.gb | :+1: |
+| 06-ld r,r.gb | :+1: |
+| 07-jr,jp,call,ret,rst.gb | :+1: |
+| 08-misc instrs.gb | :+1: |
+| 09-op r,r.gb | :+1: |
+| 10-bit ops.gb | :+1: |
+| 11-op a,(hl).gb | :+1: |
+**[Gekkio](https://github.com/Gekkio)'s tests:**
diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index e5f2b3f09be059c3f5136a63c3e3f54b139ca829..49a4c6416daeeaf1fe5c20df35456d4ca0d8e714 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -334,6 +334,9 @@ namespace TKPEmu::Gameboy {
 	float* Gameboy::GetScreenData() {
 		return ppu_.GetScreenData();
 	}
+	std::string Gameboy::GetEmulatorName() {
+		return "GameboyTKP";
+	}
 	const Devices::Cartridge* const Gameboy::GetCartridge() const {
 		return bus_.GetCartridge();
 	}
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 6b6b1b2905edcaf79a319c9e78f7d6a67e3456aa..7b8596895f5be9162e42d3dc796d45ab4b02aa8e 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -30,6 +30,7 @@ namespace TKPEmu::Gameboy {
 		void HandleKeyDown(SDL_Keycode key) override;
 		void HandleKeyUp(SDL_Keycode key) override;
 		float* GetScreenData() override;
+		std::string GetEmulatorName() override;
 		std::string GetScreenshotHash() override;
 		void SetLogTypes(std::unique_ptr<std::vector<LogType>> types_ptr);
         DisInstr GetInstruction(uint16_t address);
diff --git a/TKPEmu/gb_tkp/generate_test_results.sh b/TKPEmu/gb_tkp/generate_test_results.sh
new file mode 100755
index 0000000000000000000000000000000000000000..c4d59d7cafafcf8e0a0652f3a757d2674ff8fea9
--- /dev/null
+++ b/TKPEmu/gb_tkp/generate_test_results.sh
@@ -0,0 +1,22 @@
+#!/bin/sh
+if (( $# != 3 )); then
+    >&2 echo "Correct syntax: generate_test_results (TKPEmu path) (blargg individual roms directory) (mooneye-gb tests directory)"
+    exit
+fi
+emu=$1
+outf="./TEST_RESULTS.md"
+blargg=$2
+mooneye=$3
+
+# Delete file contents
+
+>$outf
+echo "GameboyTKP test results generated by $USER on $(date).\n" >> $outf
+echo "**[Blargg](https://github.com/gblargg)'s tests:**" >> $outf
+echo "Testing blargg directory $blargg"
+# Generate blargg tests
+$emu -T $blargg -p -g -G $outf
+echo "**[Gekkio](https://github.com/Gekkio)'s tests:**" >> $outf
+echo "Testing mooneye directory $mooneye"
+# Generate mooneye tests
+$emu -T $mooneye -r -p -g -G $outf

From b366cacef460b76772e1069220066b431257eb23 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:42:55 +0200
Subject: [PATCH] test fixes

---
 TKPEmu/gb_tkp/TEST_RESULTS.md          | 4 +++-
 TKPEmu/gb_tkp/generate_test_results.sh | 7 +++++--
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index feda6c632b48efbd8f6c8b9e1e07776d557ab166..e34d40fa8e32d82216d7199d266665370fad0a48 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by  on Thu Dec 16 03:35:40 PM EET 2021.\n
+GameboyTKP test results generated by offtkp on Thu Dec 16 03:42:30 PM EET 2021.
 **[Blargg](https://github.com/gblargg)'s tests:**
 | Test | GameboyTKP |
 | -- | -- |
@@ -13,4 +13,6 @@ GameboyTKP test results generated by  on Thu Dec 16 03:35:40 PM EET 2021.\n
 | 09-op r,r.gb | :+1: |
 | 10-bit ops.gb | :+1: |
 | 11-op a,(hl).gb | :+1: |
+-----
 **[Gekkio](https://github.com/Gekkio)'s tests:**
+To generate these test results, use generate_test_results.sh in /gb_tkp/
diff --git a/TKPEmu/gb_tkp/generate_test_results.sh b/TKPEmu/gb_tkp/generate_test_results.sh
index c4d59d7cafafcf8e0a0652f3a757d2674ff8fea9..6da3c164bb93d65945be6cd3521521d486bf08d0 100755
--- a/TKPEmu/gb_tkp/generate_test_results.sh
+++ b/TKPEmu/gb_tkp/generate_test_results.sh
@@ -3,20 +3,23 @@ if (( $# != 3 )); then
     >&2 echo "Correct syntax: generate_test_results (TKPEmu path) (blargg individual roms directory) (mooneye-gb tests directory)"
     exit
 fi
+
 emu=$1
 outf="./TEST_RESULTS.md"
 blargg=$2
 mooneye=$3
 
 # Delete file contents
-
 >$outf
-echo "GameboyTKP test results generated by $USER on $(date).\n" >> $outf
+
+echo "GameboyTKP test results generated by $USER on $(date)." >> $outf
 echo "**[Blargg](https://github.com/gblargg)'s tests:**" >> $outf
 echo "Testing blargg directory $blargg"
 # Generate blargg tests
 $emu -T $blargg -p -g -G $outf
+echo "-----" >> $outf
 echo "**[Gekkio](https://github.com/Gekkio)'s tests:**" >> $outf
 echo "Testing mooneye directory $mooneye"
 # Generate mooneye tests
 $emu -T $mooneye -r -p -g -G $outf
+echo "To generate these test results, use generate_test_results.sh in /gb_tkp/" >> $outf

From 5d2a52c2b814d02c730b48d2344efa586ae8ce2b Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:44:32 +0200
Subject: [PATCH] fix line endings test

---
 TKPEmu/gb_tkp/TEST_RESULTS.md          | 6 +++---
 TKPEmu/gb_tkp/generate_test_results.sh | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index e34d40fa8e32d82216d7199d266665370fad0a48..b370f52d80bdd1d79f72f8e2e4fb935eaa8d3941 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,5 +1,5 @@
-GameboyTKP test results generated by offtkp on Thu Dec 16 03:42:30 PM EET 2021.
-**[Blargg](https://github.com/gblargg)'s tests:**
+GameboyTKP test results generated by offtkp on Thu Dec 16 03:44:18 PM EET 2021.    
+**[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
 | 01-special.gb | :+1: |
@@ -14,5 +14,5 @@ GameboyTKP test results generated by offtkp on Thu Dec 16 03:42:30 PM EET 2021.
 | 10-bit ops.gb | :+1: |
 | 11-op a,(hl).gb | :+1: |
 -----
-**[Gekkio](https://github.com/Gekkio)'s tests:**
+**[Gekkio](https://github.com/Gekkio)'s tests:**    
 To generate these test results, use generate_test_results.sh in /gb_tkp/
diff --git a/TKPEmu/gb_tkp/generate_test_results.sh b/TKPEmu/gb_tkp/generate_test_results.sh
index 6da3c164bb93d65945be6cd3521521d486bf08d0..16c67516c69db02865a6926be860c37ad8047537 100755
--- a/TKPEmu/gb_tkp/generate_test_results.sh
+++ b/TKPEmu/gb_tkp/generate_test_results.sh
@@ -12,13 +12,13 @@ mooneye=$3
 # Delete file contents
 >$outf
 
-echo "GameboyTKP test results generated by $USER on $(date)." >> $outf
-echo "**[Blargg](https://github.com/gblargg)'s tests:**" >> $outf
+echo "GameboyTKP test results generated by $USER on $(date).    " >> $outf
+echo "**[Blargg](https://github.com/gblargg)'s tests:**    " >> $outf
 echo "Testing blargg directory $blargg"
 # Generate blargg tests
 $emu -T $blargg -p -g -G $outf
 echo "-----" >> $outf
-echo "**[Gekkio](https://github.com/Gekkio)'s tests:**" >> $outf
+echo "**[Gekkio](https://github.com/Gekkio)'s tests:**    " >> $outf
 echo "Testing mooneye directory $mooneye"
 # Generate mooneye tests
 $emu -T $mooneye -r -p -g -G $outf

From da8a081abb4673d23469421bfaaac0ab7ca14950 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:45:35 +0200
Subject: [PATCH] script changes

---
 TKPEmu/gb_tkp/generate_test_results.sh | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/TKPEmu/gb_tkp/generate_test_results.sh b/TKPEmu/gb_tkp/generate_test_results.sh
index 16c67516c69db02865a6926be860c37ad8047537..8962ae0f61bdac6d4b02906b5382275aa7a4739f 100755
--- a/TKPEmu/gb_tkp/generate_test_results.sh
+++ b/TKPEmu/gb_tkp/generate_test_results.sh
@@ -13,6 +13,7 @@ mooneye=$3
 >$outf
 
 echo "GameboyTKP test results generated by $USER on $(date).    " >> $outf
+echo "-----" >> $outf
 echo "**[Blargg](https://github.com/gblargg)'s tests:**    " >> $outf
 echo "Testing blargg directory $blargg"
 # Generate blargg tests
@@ -22,4 +23,5 @@ echo "**[Gekkio](https://github.com/Gekkio)'s tests:**    " >> $outf
 echo "Testing mooneye directory $mooneye"
 # Generate mooneye tests
 $emu -T $mooneye -r -p -g -G $outf
+echo "-----" >> $outf
 echo "To generate these test results, use generate_test_results.sh in /gb_tkp/" >> $outf

From 05ee753c74f2557aed23162a38624328ea9d3114 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:47:54 +0200
Subject: [PATCH] Update README.md

---
 TKPEmu/gb_tkp/README.md | 58 +++----------------------------------------------
 1 file changed, 3 insertions(+), 55 deletions(-)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index 98dbffea0c04eac5e917ddae82e995d5a46794cf..b7bb708b70ee0f28c923116cf3eaf748a3bb3d39 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -14,61 +14,9 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 
 ## Tests
 
-**[Blargg](https://github.com/gblargg)'s tests:**
-| Test | GameboyTKP  |
-|--|--|
-| cpu_instrs |  |
-| instr_timing |  |
-| mem_timing |  |
-| dmg_sound |  |
-| oam_bug |  |
-
-**[Gekkio](https://github.com/Gekkio)'s acceptance tests:**
-
-|Test| GameboyTKP |
-|--|--|
-| acceptance/div_timing |  |
-| acceptance/ei_timing |  |
-| acceptance/ei_sequence |  |
-| acceptance/halt_ime0_ei |  |
-| acceptance/if_ie_registers |  |
-| acceptance/boot_regs-dmgABC |  |
-| acceptance/bits/mem_oam |  |
-| acceptance/bits/reg_f |  |
-| acceptance/bits/unused_hwio_GS |  |
-| acceptance/instr/daa |  |
-| acceptance/interrupts/ie_push |  |
-| acceptance/oam_dma/basic |  |
-| acceptance/oam_dma/reg_read |  |
-| acceptance/ppu/... |  (untested)|
-| acceptance/serial/... |  (untested)|
-| acceptance/timer/div_write |  |
-| acceptance/timer/rapid_toggle |  |
-| acceptance/timer/tim00 |  |
-| acceptance/timer/tim00_div_trigger |  |
-| acceptance/timer/tim01 |  |
-| acceptance/timer/tim01_div_trigger |  |
-| acceptance/timer/tim10 |  |
-| acceptance/timer/tim10_div_trigger |  |
-| acceptance/timer/tim11 |  |
-| acceptance/timer/tim11_div_trigger |  |
-| acceptance/timer/tima_reload |  |
-| acceptance/timer/tima_write_reloading |  |
-| acceptance/timer/tma_write_reloading |  |
-| emulator-only/mbc1/bits_bank1 |  | 
-| emulator-only/mbc1/bits_bank2 |  | 
-| emulator-only/mbc1/bits_mode |  | 
-| emulator-only/mbc1/bits_ramg |  | 
-| emulator-only/mbc1/multicart_rom_8Mb |  | 
-| emulator-only/mbc1/ram_256kb |  | 
-| emulator-only/mbc1/ram_64kb |  | 
-| emulator-only/mbc1/rom_16Mb |  | 
-| emulator-only/mbc1/rom_1Mb |  (multicart) | 
-| emulator-only/mbc1/rom_2Mb |  (multicart) | 
-| emulator-only/mbc1/rom_4Mb |  | 
-| emulator-only/mbc1/rom_512kb |  (multicart) |
-| emulator-only/mbc1/rom_8Mb |  | 
-
+See generated test results [here](./TEST_RESULTS.md).    
+Always generate new test results before pushing a commit when changing the code.
+-----
 **[mattcurie](https://github.com/mattcurrie)'s tests:**
 |Test|GameboyTKP  |
 |--|--|

From f59029020ac23ed8817e0ef31fbaae9eb06f4c79 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Thu, 16 Dec 2021 15:48:23 +0200
Subject: [PATCH] Update README.md

---
 TKPEmu/gb_tkp/README.md | 1 +
 1 file changed, 1 insertion(+)

diff --git a/TKPEmu/gb_tkp/README.md b/TKPEmu/gb_tkp/README.md
index b7bb708b70ee0f28c923116cf3eaf748a3bb3d39..249d6934fa969caecc1804720f9795444ac6c145 100644
--- a/TKPEmu/gb_tkp/README.md
+++ b/TKPEmu/gb_tkp/README.md
@@ -16,6 +16,7 @@ Gameboy emulator written in C++ for [TKPEmu](https://github.com/OFFTKP/TKPEmu).
 
 See generated test results [here](./TEST_RESULTS.md).    
 Always generate new test results before pushing a commit when changing the code.
+
 -----
 **[mattcurie](https://github.com/mattcurrie)'s tests:**
 |Test|GameboyTKP  |

From 8b683f8b18be6a4ebfe954cf011a97ccce6f826b Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 17 Dec 2021 13:19:41 +0200
Subject: [PATCH] stable - debug, fixed ram ub bug

---
 TKPEmu/gb_tkp/gameboy.cpp    | 12 ++++--------
 TKPEmu/gb_tkp/gb_bus.cpp     |  3 ++-
 TKPEmu/gb_tkp/gb_romdata.cpp | 20 +++++++++++++++++++-
 3 files changed, 25 insertions(+), 10 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 49a4c6416daeeaf1fe5c20df35456d4ca0d8e714..3ba0d9d98d4a8e5c62674b5b961e26f1d5b383f0 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -239,29 +239,25 @@ namespace TKPEmu::Gameboy {
 		       "Read more: https://github.com/OFFTKP/TKPEmu/tree/master/TKPEmu/gb_tkp";
 	}
 	void Gameboy::HandleKeyDown(SDL_Keycode key) {
-		static const uint8_t joy_direction = 0b1110'1111;
-		static const uint8_t joy_action = 0b1101'1111;
 		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
 			int index = it_dir - direction_keys_.begin();
-			bus_.DirectionKeys &= (~(1UL << index));// & joy_direction;
+			bus_.DirectionKeys &= (~(1UL << index));
 			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
 			int index = it_dir - action_keys_.begin();
-			bus_.ActionKeys &= (~(1UL << index));// & joy_action;
+			bus_.ActionKeys &= (~(1UL << index));
 			interrupt_flag_ |= IFInterrupt::JOYPAD;
 		}
 	}
 	void Gameboy::HandleKeyUp(SDL_Keycode key) {
-		static const uint8_t joy_direction = 0b1110'1111;
-		static const uint8_t joy_action = 0b1101'1111;
 		if (auto it_dir = std::find(direction_keys_.begin(), direction_keys_.end(), key); it_dir != direction_keys_.end()) {
 			int index = it_dir - direction_keys_.begin();
-			bus_.DirectionKeys |= (1UL << index);// | joy_direction;
+			bus_.DirectionKeys |= (1UL << index);
 		}
 		if (auto it_dir = std::find(action_keys_.begin(), action_keys_.end(), key); it_dir != action_keys_.end()) {
 			int index = it_dir - action_keys_.begin();
-			bus_.ActionKeys |= (1UL << index);// | joy_action;
+			bus_.ActionKeys |= (1UL << index);
 		}
 	}
 	void Gameboy::load_file(std::string path) {
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 2c49e523755a4f4f5bd72eeee533d24036e33ba1..a549a81c5dc1e0afabab9470eaeb470ef3deb839 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -32,7 +32,7 @@ namespace TKPEmu::Gameboy::Devices {
 					selected_rom_bank_ &= 0b11111;
 					selected_rom_bank_ |= ((data & 0b11) << 5);
 					selected_rom_bank_ %= rom_banks_size_;
-					selected_ram_bank_ = data & 0b11;
+					selected_ram_bank_ = (data & 0b11) % cartridge_->GetRamSize();
 				}
 				else {
 					// MODE register
@@ -388,6 +388,7 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		hram_.fill(0);
 		oam_.fill(0);
+		vram_.fill(0);
 		selected_rom_bank_ = 1;
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;
diff --git a/TKPEmu/gb_tkp/gb_romdata.cpp b/TKPEmu/gb_tkp/gb_romdata.cpp
index 54e8bff2b9e1689ca0e598a9ee92b5842f4d7cd2..a95c4dfffb7f9375fa08df0c48d9eb85018e8c92 100644
--- a/TKPEmu/gb_tkp/gb_romdata.cpp
+++ b/TKPEmu/gb_tkp/gb_romdata.cpp
@@ -3,10 +3,28 @@ namespace TKPEmu::Applications {
     GameboyRomData::GameboyRomData(std::string menu_title, std::string window_title) 
         : IMApplication(menu_title, window_title) 
     {
-        max_size = ImVec2(400, 400);
+        min_size = ImVec2(400, 200);
+        max_size = ImVec2(500, 200);
     }
     void GameboyRomData::v_draw() {
         Gameboy* gb_ptr = static_cast<Gameboy*>(emulator_);
+        ImGui::Text(gb_ptr->CurrentFilename.c_str());
         ImGui::Text(gb_ptr->GetCartridge()->GetCartridgeTypeName());
+        ImGui::InputText("Rom hash", gb_ptr->RomHash.data(), gb_ptr->RomHash.length(), ImGuiInputTextFlags_ReadOnly);
+        static bool hashed = false;
+        static std::string hash = "?";
+        static std::string result = "?";
+        if (!hashed && gb_ptr->Paused) {
+            hashed = true;
+            hash = gb_ptr->GetScreenshotHash();
+            result = "{ \"" + gb_ptr->RomHash + "\", { " + std::to_string(gb_ptr->GetCPU().TotalClocks) + ", \"" + hash + "\" } },";
+        } else if (hashed && !gb_ptr->Paused) {
+            hashed = false;
+            hash = "Pause to get current screenshot hash";
+        }
+        ImGui::InputText("VRAM hash", hash.data(), hash.length(), ImGuiInputTextFlags_ReadOnly);
+        if (hashed) {
+            ImGui::InputText("emulator_results.h hash", result.data(), result.length(), ImGuiInputTextFlags_ReadOnly);
+        }
     }
 }
\ No newline at end of file

From 50af2ca72bba91e8fcc6528c55abb3e8a9609ea8 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 17 Dec 2021 13:21:37 +0200
Subject: [PATCH] another ram fix

---
 TKPEmu/gb_tkp/gb_bus.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index a549a81c5dc1e0afabab9470eaeb470ef3deb839..654fa86e7b867305de64adf93308740c5f16b991 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -32,7 +32,7 @@ namespace TKPEmu::Gameboy::Devices {
 					selected_rom_bank_ &= 0b11111;
 					selected_rom_bank_ |= ((data & 0b11) << 5);
 					selected_rom_bank_ %= rom_banks_size_;
-					selected_ram_bank_ = (data & 0b11) % cartridge_->GetRamSize();
+					selected_ram_bank_ = data & 0b11;
 				}
 				else {
 					// MODE register
@@ -60,7 +60,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				else if (address <= 0x5FFF) {
 					if (data <= 0b11) {
-						selected_ram_bank_ = data & (cartridge_->GetRamSize() - 1); 
+						selected_ram_bank_ = data; 
 					} else {
 						// TODO: mbc3 rtc
 					}
@@ -163,7 +163,7 @@ namespace TKPEmu::Gameboy::Devices {
 				if (ram_enabled_) {
 					if (cartridge_->GetRamSize() == 0)
 						return eram_default_[address % 0x2000];
-					auto sel = (banking_mode_ ? selected_ram_bank_ : 0);
+					auto sel = (banking_mode_ ? selected_ram_bank_ : 0) % cartridge_->GetRamSize();
 					return (ram_banks_[sel])[address % 0x2000];
 				} else {
 					unused_mem_area_ = 0xFF;

From 9a21f9bb904a68a839340143b875954d84a38ca6 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 17 Dec 2021 13:57:03 +0200
Subject: [PATCH] lots of warnings fixed, more to go

---
 TKPEmu/gb_tkp/gameboy.cpp         |  3 +--
 TKPEmu/gb_tkp/gameboy.h           |  2 +-
 TKPEmu/gb_tkp/gb_bus.cpp          | 14 +++++++-------
 TKPEmu/gb_tkp/gb_bus.h            |  4 ++--
 TKPEmu/gb_tkp/gb_disassembler.cpp |  5 ++++-
 TKPEmu/gb_tkp/gb_ppu.cpp          |  8 ++++----
 TKPEmu/gb_tkp/gb_ppu.h            |  7 +++----
 TKPEmu/gb_tkp/gb_timer.cpp        |  2 +-
 TKPEmu/gb_tkp/gb_tracelogger.cpp  |  5 +++--
 9 files changed, 26 insertions(+), 24 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 3ba0d9d98d4a8e5c62674b5b961e26f1d5b383f0..20943125dd28d5a3a2d952068bdfd1d8d1464005 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -35,7 +35,6 @@ namespace TKPEmu::Gameboy {
 	}
 	void Gameboy::v_log_state() {
 		*ofstream_ptr_ << std::setfill('0');
-		bool first_type = true;
 		int inst = bus_.ReadSafe(cpu_.PC);
 		for (const auto& t : *log_types_ptr_) {
 			switch (t) {
@@ -333,7 +332,7 @@ namespace TKPEmu::Gameboy {
 	std::string Gameboy::GetEmulatorName() {
 		return "GameboyTKP";
 	}
-	const Devices::Cartridge* const Gameboy::GetCartridge() const {
+	Devices::Cartridge* Gameboy::GetCartridge() {
 		return bus_.GetCartridge();
 	}
 	const auto& Gameboy::GetOpcodeDescription(uint8_t opc) {
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index 7b8596895f5be9162e42d3dc796d45ab4b02aa8e..e82e080f354c0899ba579495b7b4b3f1bff56324 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -38,7 +38,7 @@ namespace TKPEmu::Gameboy {
 		void RemoveBreakpoint(int index);
 		const auto& GetOpcodeDescription(uint8_t opc);
 		GameboyPalettes& GetPalette();
-		const Cartridge* const GetCartridge() const;
+		Cartridge* GetCartridge();
 		CPU& GetCPU() { return cpu_; }
 		std::vector<GameboyBreakpoint> Breakpoints{};
 		std::vector<DisInstr> Instructions{};
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 654fa86e7b867305de64adf93308740c5f16b991..9f170a2ae7a67815bdadbbaebe5123d6fa0dc869 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -148,9 +148,12 @@ namespace TKPEmu::Gameboy::Devices {
 						}
 						break;
 					}
+					default: {
+						// Unhandled cartridge type.
+						// TODO: stop emulator instead
+						return unused_mem_area_;
+					}
 				}
-				std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
-				exit(1);
 				break;
 			}
 			case 0x8000:
@@ -189,11 +192,8 @@ namespace TKPEmu::Gameboy::Devices {
 					// TODO: check if this is actually unused area
 					return unused_mem_area_;
 				}
-				else if (address <= 0xFFFF) {
-					return hram_[address % 0xFF00];
-				}
 				else {
-					std::cerr << "Error: Tried to access address " << address << std::endl;
+					return hram_[address % 0xFF00];
 				}
 			}
 		}
@@ -393,7 +393,7 @@ namespace TKPEmu::Gameboy::Devices {
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;
 	}
-	const Cartridge* const Bus::GetCartridge() const {
+	Cartridge* Bus::GetCartridge() {
 		return cartridge_.get();
 	}
 	void Bus::LoadCartridge(std::string fileName) {
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 8264186942d51a20549a36a89705ccc0dba7e48c..17463b7932dc74b8a05d9c0ea5a3bfa8f38928a1 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -63,11 +63,11 @@ namespace TKPEmu::Gameboy::Devices {
         void WriteL(uint16_t address, uint16_t data);
         void Reset();
         void SoftReset();
-        const Cartridge* const GetCartridge() const;
+        Cartridge* GetCartridge() ;
         void LoadCartridge(std::string fileName);
         std::string GetVramDump();
         std::array<std::array<float, 3>, 4> Palette;
-        std::array<uint8_t, 4> BGPalette{};const Cartridge* const GetCartridge();
+        std::array<uint8_t, 4> BGPalette{};
         std::array<uint8_t, 4> OBJ0Palette{};
         std::array<uint8_t, 4> OBJ1Palette{};
         // TODO: remove big OAM
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 663f8b64811283237104a8ad36bca31b446953ec..565f141f99076697f90dd8582caa43aa78155b9a 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -26,6 +26,9 @@ namespace TKPEmu::Applications {
                 shortcut = TKPShortcut::NONE;
                 break;
             }
+            default: {
+                break;
+            }
         }
     }
     void GameboyDisassembler::v_draw() {
@@ -277,7 +280,7 @@ namespace TKPEmu::Applications {
                 ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
                 ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
             }
-            ImGui::Text("Clocks: %d", t.TotalClocks);
+            ImGui::Text("Clocks: %lu", t.TotalClocks);
             ImGui::Checkbox("Hex", &use_hex);
             ImGui::EndChild();
             // TODO: add switch from hex to binary on every textbox here
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index 31350a074b781c9df705d980777dd25abab4b939..c47fcc9e5d190e718e40ba9fba96ed4249f4e32c 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -5,13 +5,13 @@ namespace TKPEmu::Gameboy::Devices {
 	PPU::PPU(Bus* bus, std::mutex* draw_mutex) : bus_(bus), draw_mutex_(draw_mutex), next_stat_mode(bus->NextMode),
 		LCDC(bus->GetReference(0xFF40)),
 		STAT(bus->GetReference(0xFF41)),
+		LYC(bus->GetReference(0xFF45)),
+		LY(bus->GetReference(0xFF44)),
+		IF(bus->GetReference(0xFF0F)),
 		SCY(bus->GetReference(0xFF42)),
 		SCX(bus->GetReference(0xFF43)),
-		LY(bus->GetReference(0xFF44)),
-		LYC(bus->GetReference(0xFF45)),
 		WY(bus->GetReference(0xFF4A)),
-		WX(bus->GetReference(0xFF4B)),
-		IF(bus->GetReference(0xFF0F))
+		WX(bus->GetReference(0xFF4B))
 	{}
 	void PPU::Update(uint8_t cycles) {
 		if (LCDC & LCDCFlag::LCD_ENABLE) {
diff --git a/TKPEmu/gb_tkp/gb_ppu.h b/TKPEmu/gb_tkp/gb_ppu.h
index ae6fab20de30a138af0b450e246063e582381cc3..663c9815781a61720dfe02012c657fcbbef40a2b 100644
--- a/TKPEmu/gb_tkp/gb_ppu.h
+++ b/TKPEmu/gb_tkp/gb_ppu.h
@@ -19,15 +19,14 @@ namespace TKPEmu::Gameboy::Devices {
 		float* GetScreenData();
 	private:
 		Bus* bus_;
+		std::mutex* draw_mutex_;
+		uint8_t& next_stat_mode;
 		std::array<float, 4 * 160 * 144> screen_color_data_{};
-
-		// PPU register pointers
+		// PPU memory mapped registers
 		uint8_t& LCDC, &STAT, &LYC, &LY, &IF, &SCY, &SCX, &WY, &WX;
 
 		int clock_ = 0;
 		int clock_target_ = 0;
-		uint8_t& next_stat_mode;
-		std::mutex* draw_mutex_ = nullptr;
 		int set_mode(int mode);
 		int get_mode();
 		int update_lyc();
diff --git a/TKPEmu/gb_tkp/gb_timer.cpp b/TKPEmu/gb_tkp/gb_timer.cpp
index fa0c7f4ca56cf62f9b2fc0fbf196e529a622cf89..99cbb9a42f53836aaa8ec540734971d1301e3461 100644
--- a/TKPEmu/gb_tkp/gb_timer.cpp
+++ b/TKPEmu/gb_tkp/gb_timer.cpp
@@ -4,8 +4,8 @@ namespace TKPEmu::Gameboy::Devices {
         bus_(bus), 
         DIV(bus->GetReference(addr_div)),
         TIMA(bus_->GetReference(addr_tim)),
-        TMA(bus_->GetReference(addr_tma)),
         TAC(bus_->GetReference(addr_tac)),
+        TMA(bus_->GetReference(addr_tma)),
         IF(bus_->GetReference(addr_ifl))
     {}
     void Timer::Reset() {
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index 85d461d14ce476827525624cc4a72cb47b4188ca..bfce6a4ed1a17642260d36ae6a0a6425247cd8d3 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -44,6 +44,7 @@ namespace TKPEmu::Applications {
                 std::cerr << "Error: Path is directory" << std::endl;
             } else if (!overwrite && std::filesystem::exists(path_buf_)) {
                 file_exists = true;
+                // TODO: get result of "Overwrite" and act accordingly
                 ImGui::OpenPopup("Overwrite?");
             } else {
                 std::filesystem::create_directories(std::filesystem::path(path_buf_).parent_path());
@@ -82,7 +83,7 @@ namespace TKPEmu::Applications {
 		ImGui::NewLine();
 		ImGui::TextUnformatted("Memory to log:");
 		ImGui::Separator();
-		for (int i = 0; i < LogTypeSize; i++) {
+		for (size_t i = 0; i < LogTypeSize; i++) {
 			ImGui::Checkbox(LogTypeNames[i].c_str(), &available_types_[i]);
 			if ((i + 1) % 5 != 0) {
 				ImGui::SameLine();
@@ -107,7 +108,7 @@ namespace TKPEmu::Applications {
 	}
 	void GameboyTracelogger::set_logtypes() {
 		std::unique_ptr<std::vector<LogType>> ptr = std::make_unique<std::vector<LogType>>();
-		for (int i = 0; i < LogTypeSize; i++) {
+		for (size_t i = 0; i < LogTypeSize; i++) {
 			if (available_types_[i]) {
 				ptr->push_back(LogTypeMap[i]);
 			}

From 931619e4210eac1bc2f9b31e0c667a67d22dcf4f Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 17 Dec 2021 14:58:04 +0200
Subject: [PATCH] updated test results for gameboy

---
 TKPEmu/gb_tkp/TEST_RESULTS.md  | 143 +++++++++++++++++++++++++++++++++++++----
 TKPEmu/gb_tkp/gb_cartridge.cpp |   2 +-
 2 files changed, 132 insertions(+), 13 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index b370f52d80bdd1d79f72f8e2e4fb935eaa8d3941..6c012dbe5ded295b92d07203f29784e00bf2f7ca 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,18 +1,137 @@
-GameboyTKP test results generated by offtkp on Thu Dec 16 03:44:18 PM EET 2021.    
+GameboyTKP test results generated by offtkp on Fri Dec 17 02:57:20 PM EET 2021.    
+-----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
-| 01-special.gb | :+1: |
-| 02-interrupts.gb | :+1: |
-| 03-op sp,hl.gb | :+1: |
-| 04-op r,imm.gb | :+1: |
-| 05-op rp.gb | :+1: |
-| 06-ld r,r.gb | :+1: |
-| 07-jr,jp,call,ret,rst.gb | :+1: |
-| 08-misc instrs.gb | :+1: |
-| 09-op r,r.gb | :+1: |
-| 10-bit ops.gb | :+1: |
-| 11-op a,(hl).gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/01-special.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/02-interrupts.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/03-op sp,hl.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/04-op r,imm.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/05-op rp.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/06-ld r,r.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/07-jr,jp,call,ret,rst.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/08-misc instrs.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/09-op r,r.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/10-bit ops.gb | :+1: |
+| /home/offtkp/Tests/blargg/cpu_instrs/individual/11-op a,(hl).gb | :+1: |
 -----
 **[Gekkio](https://github.com/Gekkio)'s tests:**    
+| Test | GameboyTKP |
+| -- | -- |
+| /home/offtkp/Tests/moon/acceptance/add_sp_e_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/bits/mem_oam.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/bits/reg_f.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/bits/unused_hwio-GS.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/boot_div-S.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_div-dmg0.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_div-dmgABCmgb.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_div2-S.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_hwio-S.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_hwio-dmg0.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_hwio-dmgABCmgb.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_regs-dmg0.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_regs-dmgABC.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/boot_regs-mgb.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_regs-sgb.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/boot_regs-sgb2.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/call_cc_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/call_cc_timing2.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/call_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/call_timing2.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/di_timing-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/div_timing.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/ei_sequence.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/ei_timing.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/halt_ime0_ei.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/halt_ime0_nointr_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/halt_ime1_timing.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/halt_ime1_timing2-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/if_ie_registers.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/instr/daa.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/interrupts/ie_push.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/intr_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/jp_cc_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/jp_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ld_hl_sp_e_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma/basic.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma/reg_read.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma/sources-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma_restart.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma_start.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/oam_dma_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/pop_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/hblank_ly_scx_timing-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_1_2_timing-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_0_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode0_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode0_timing_sprites.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode3_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_oam_ok_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/lcdon_timing-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/lcdon_write_timing-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/stat_irq_blocking.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/stat_lyc_onoff.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ppu/vblank_stat_intr-GS.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/push_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/rapid_di_ei.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/ret_cc_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/ret_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/reti_intr_timing.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/reti_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/rst_timing.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/serial/boot_sclk_align-dmgABCmgb.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/div_write.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/rapid_toggle.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim00.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim00_div_trigger.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim01.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim01_div_trigger.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim10.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim10_div_trigger.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim11.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/tim11_div_trigger.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tima_reload.gb | :+1: |
+| /home/offtkp/Tests/moon/acceptance/timer/tima_write_reloading.gb | :?: |
+| /home/offtkp/Tests/moon/acceptance/timer/tma_write_reloading.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_bank1.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_bank2.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_mode.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_ramg.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/multicart_rom_8Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/ram_256kb.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/ram_64kb.gb | :+1: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_16Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_1Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_2Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_4Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_512kb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_8Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_ramg.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_romb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_unused.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/ram.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_1Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_2Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_512kb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_16Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_1Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_2Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_32Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_4Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_512kb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_64Mb.gb | :?: |
+| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_8Mb.gb | :?: |
+| /home/offtkp/Tests/moon/madness/mgb_oam_dma_halt_sprites.gb | :?: |
+| /home/offtkp/Tests/moon/manual-only/sprite_priority.gb | :?: |
+| /home/offtkp/Tests/moon/misc/bits/unused_hwio-C.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_div-A.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_div-cgb0.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_div-cgbABCDE.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_hwio-C.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_regs-A.gb | :?: |
+| /home/offtkp/Tests/moon/misc/boot_regs-cgb.gb | :?: |
+| /home/offtkp/Tests/moon/misc/ppu/vblank_stat_intr-C.gb | :?: |
+| /home/offtkp/Tests/moon/utils/bootrom_dumper.gb | :?: |
+| /home/offtkp/Tests/moon/utils/dump_boot_hwio.gb | :?: |
+-----
 To generate these test results, use generate_test_results.sh in /gb_tkp/
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 68d5fcea52993a6f4532c6db50895ab714b2f87d..bbc75f6e8ae80a7dfd90df4fdbb5b425e144b861 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -30,7 +30,7 @@ namespace TKPEmu::Gameboy::Devices {
 				default: {
 					// TODO: better error or implement all cartridge types
 					std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
-					exit(1);
+					//exit(1);
 				}
 			}
 			is.close();

From 33d9537a0d6a7755728ed78a4d660d5fae5268a8 Mon Sep 17 00:00:00 2001
From: PARIS OPLOPOIOS <parisoplop@gmail.com>
Date: Fri, 17 Dec 2021 15:49:39 +0200
Subject: [PATCH] added pkgbuild

---
 TKPEmu/gb_tkp/gb_cartridge.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index bbc75f6e8ae80a7dfd90df4fdbb5b425e144b861..5220e43d2ef20e9f98a15b43481646d019ae7f8e 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -28,7 +28,7 @@ namespace TKPEmu::Gameboy::Devices {
 					break;
 				}
 				default: {
-					// TODO: better error or implement all cartridge types
+					// TODO: better error or implement all cartridge types, quit emulator instead of exiting
 					std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
 					//exit(1);
 				}

From cebce6e8207f786f2434f483fb53edb8a338762b Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 18 Dec 2021 12:31:04 +0200
Subject: [PATCH] some ifs removed

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 41 ++++++++++++++++++-----------------------
 1 file changed, 18 insertions(+), 23 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index dadd204e6a0cd666b2764870070d2bc664c8fd55..10738ab78ccaed5aecb2ae39ed2a3afddeae61fe 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -913,13 +913,9 @@ namespace TKPEmu::Gameboy::Devices {
 			PC += 2;
 	}
 	void CPU::JR8() {
-		int i = bus_->Read(PC);
-		if (i >= 0x80)
-			i = -((~i + 1) & 255);
-		PC++;
-		tTemp = 8;
-		PC += i;
-		tTemp += 4;
+		auto temp = bus_->Read(PC);
+		PC += 1 + ((temp ^ 0x80) - 0x80);
+		tTemp = 12;
 	}
 	void CPU::JRNZ8() {
 		int i = bus_->Read(PC);
@@ -933,25 +929,24 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 	}
 	void CPU::JRZ8() {
-		int i = bus_->Read(PC);
-		if (i >= 0x80)
-			i = -((~i + 1) & 255);
-		PC++;
-		tTemp = 8;
-		if ((F & 0x80) == 0x80) {
-			PC += i;
-			tTemp += 4;
+		if (F & FLAG_ZERO_MASK) {
+			auto temp = bus_->Read(PC);
+			PC += 1;
+			PC += (temp ^ 0x80) - 0x80;
+			tTemp = 12;
+		} else {
+			PC += 1;
+			tTemp = 8;
 		}
 	}
 	void CPU::JRNC8() {
-		int i = bus_->Read(PC);
-		if (i >= 0x80)
-			i = -((~i + 1) & 255);
-		PC++;
-		tTemp = 8;
-		if ((F & 0x10) == 0x00) {
-			PC += i;
-			tTemp += 4;
+		if (!(F & FLAG_CARRY_MASK)) {
+			auto temp = bus_->Read(PC);
+			PC += 1;
+			PC += ((temp ^ 0x80) - 0x80);
+			tTemp = 12;
+		} else {
+			tTemp = 8;
 		}
 	}
 	void CPU::JRC8() {

From fb00bd4aa8c8b887f5232f73901a570f3521adf4 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 18 Dec 2021 12:32:04 +0200
Subject: [PATCH] fix cpu bug

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 10738ab78ccaed5aecb2ae39ed2a3afddeae61fe..31e16fc26b6422ba258628d447e29349a9d2052d 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -946,6 +946,7 @@ namespace TKPEmu::Gameboy::Devices {
 			PC += ((temp ^ 0x80) - 0x80);
 			tTemp = 12;
 		} else {
+			PC += 1;
 			tTemp = 8;
 		}
 	}

From 13d7001fe1334b20e510f88b9a518709e374984a Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 18 Dec 2021 13:48:56 +0200
Subject: [PATCH] added more tests, cpu instruction changes

---
 TKPEmu/gb_tkp/TEST_RESULTS.md          | 168 ++++++++-------------------------
 TKPEmu/gb_tkp/gb_cpu.cpp               | 103 +++++++-------------
 TKPEmu/gb_tkp/gb_cpu.h                 |   2 +
 TKPEmu/gb_tkp/gb_romdata.cpp           |   2 +-
 TKPEmu/gb_tkp/generate_test_results.sh |   4 +-
 5 files changed, 78 insertions(+), 201 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index 6c012dbe5ded295b92d07203f29784e00bf2f7ca..747978e17fcc1e1f7c6c2cbcac8bbfbca997a951 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,137 +1,51 @@
-GameboyTKP test results generated by offtkp on Fri Dec 17 02:57:20 PM EET 2021.    
+GameboyTKP test results generated by offtkp on  18  2021 01:48:17  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/01-special.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/02-interrupts.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/03-op sp,hl.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/04-op r,imm.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/05-op rp.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/06-ld r,r.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/07-jr,jp,call,ret,rst.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/08-misc instrs.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/09-op r,r.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/10-bit ops.gb | :+1: |
-| /home/offtkp/Tests/blargg/cpu_instrs/individual/11-op a,(hl).gb | :+1: |
+| 01-special | :+1: |
+| 02-interrupts | :+1: |
+| 03-op sp,hl | :+1: |
+| 04-op r,imm | :+1: |
+| 05-op rp | :+1: |
+| 06-ld r,r | :+1: |
+| 07-jr,jp,call,ret,rst | :+1: |
+| 08-misc instrs | :+1: |
+| 09-op r,r | :+1: |
+| 10-bit ops | :+1: |
+| 11-op a,(hl) | :+1: |
+| instr_timing | :+1: |
 -----
 **[Gekkio](https://github.com/Gekkio)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
-| /home/offtkp/Tests/moon/acceptance/add_sp_e_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/bits/mem_oam.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/bits/reg_f.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/bits/unused_hwio-GS.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/boot_div-S.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_div-dmg0.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_div-dmgABCmgb.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_div2-S.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_hwio-S.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_hwio-dmg0.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_hwio-dmgABCmgb.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_regs-dmg0.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_regs-dmgABC.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/boot_regs-mgb.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_regs-sgb.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/boot_regs-sgb2.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/call_cc_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/call_cc_timing2.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/call_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/call_timing2.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/di_timing-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/div_timing.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/ei_sequence.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/ei_timing.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/halt_ime0_ei.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/halt_ime0_nointr_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/halt_ime1_timing.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/halt_ime1_timing2-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/if_ie_registers.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/instr/daa.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/interrupts/ie_push.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/intr_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/jp_cc_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/jp_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ld_hl_sp_e_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma/basic.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma/reg_read.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma/sources-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma_restart.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma_start.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/oam_dma_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/pop_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/hblank_ly_scx_timing-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_1_2_timing-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_0_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode0_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode0_timing_sprites.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_mode3_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/intr_2_oam_ok_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/lcdon_timing-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/lcdon_write_timing-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/stat_irq_blocking.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/stat_lyc_onoff.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ppu/vblank_stat_intr-GS.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/push_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/rapid_di_ei.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/ret_cc_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/ret_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/reti_intr_timing.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/reti_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/rst_timing.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/serial/boot_sclk_align-dmgABCmgb.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/div_write.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/rapid_toggle.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim00.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim00_div_trigger.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim01.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim01_div_trigger.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim10.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim10_div_trigger.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim11.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/tim11_div_trigger.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tima_reload.gb | :+1: |
-| /home/offtkp/Tests/moon/acceptance/timer/tima_write_reloading.gb | :?: |
-| /home/offtkp/Tests/moon/acceptance/timer/tma_write_reloading.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_bank1.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_bank2.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_mode.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/bits_ramg.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/multicart_rom_8Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/ram_256kb.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/ram_64kb.gb | :+1: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_16Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_1Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_2Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_4Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_512kb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc1/rom_8Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_ramg.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_romb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/bits_unused.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/ram.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_1Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_2Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc2/rom_512kb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_16Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_1Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_2Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_32Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_4Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_512kb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_64Mb.gb | :?: |
-| /home/offtkp/Tests/moon/emulator-only/mbc5/rom_8Mb.gb | :?: |
-| /home/offtkp/Tests/moon/madness/mgb_oam_dma_halt_sprites.gb | :?: |
-| /home/offtkp/Tests/moon/manual-only/sprite_priority.gb | :?: |
-| /home/offtkp/Tests/moon/misc/bits/unused_hwio-C.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_div-A.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_div-cgb0.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_div-cgbABCDE.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_hwio-C.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_regs-A.gb | :?: |
-| /home/offtkp/Tests/moon/misc/boot_regs-cgb.gb | :?: |
-| /home/offtkp/Tests/moon/misc/ppu/vblank_stat_intr-C.gb | :?: |
-| /home/offtkp/Tests/moon/utils/bootrom_dumper.gb | :?: |
-| /home/offtkp/Tests/moon/utils/dump_boot_hwio.gb | :?: |
+| acceptance/bits/mem_oam | :+1: |
+| acceptance/bits/reg_f | :+1: |
+| acceptance/bits/unused_hwio-GS | :+1: |
+| acceptance/boot_regs-dmgABC | :+1: |
+| acceptance/div_timing | :+1: |
+| acceptance/ei_sequence | :+1: |
+| acceptance/ei_timing | :+1: |
+| acceptance/halt_ime0_ei | :+1: |
+| acceptance/halt_ime1_timing | :+1: |
+| acceptance/instrs/daa | :+1: |
+| acceptance/oam_dma/reg_read | :+1: |
+| acceptance/rapid_di_ei | :+1: |
+| acceptance/reti_intr_timing | :+1: |
+| acceptance/timer/div_write | :+1: |
+| acceptance/timer/tim_00 | :+1: |
+| acceptance/timer/tim_10 | :+1: |
+| acceptance/timer/tim_11 | :+1: |
+| acceptance/timer/tima_reload | :+1: |
+| acceptance/timer/time_01 | :+1: |
+| emulator-only/mbc1/bits_bank1 | :+1: |
+| emulator-only/mbc1/bits_bank2 | :+1: |
+| emulator-only/mbc1/bits_mode | :+1: |
+| emulator-only/mbc1/bits_ramg | :+1: |
+| emulator-only/mbc1/ram_256kb | :+1: |
+| emulator-only/mbc1/ram_64kb | :+1: |
+| emulator-only/mbc1/rom_16MB | :+1: |
+| emulator-only/mbc1/rom_4MB | :+1: |
+| emulator-only/mbc1/rom_8MB | :+1: |
 -----
 To generate these test results, use generate_test_results.sh in /gb_tkp/
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 31e16fc26b6422ba258628d447e29349a9d2052d..6f82cc0dd348b8d93381166c710d4c412bd7339a 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -213,6 +213,26 @@ namespace TKPEmu::Gameboy::Devices {
 		reg = temp & 0xFF;
 		tTemp = 8;
 	}
+	void CPU::conditional_jump_rel(bool condition) {
+		if (condition) {
+			auto temp = bus_->Read(PC);
+			PC += 1;
+			PC += ((temp ^ 0x80) - 0x80);
+			tTemp = 12;
+		} else {
+			PC += 1;
+			tTemp = 8;
+		}
+	}
+	void CPU::conditional_jump(bool condition) {
+		tTemp = 12;
+		if (condition) {
+			PC = bus_->ReadL(PC);
+			tTemp = 16;
+		} else {
+			PC += 2;
+		}
+	}
 	void CPU::rst(RegisterType addr) {
 		SP -= 2;
 		bus_->WriteL(SP, PC);
@@ -868,98 +888,39 @@ namespace TKPEmu::Gameboy::Devices {
 		--SP;
 		tTemp = 8;
 	}
-	void CPU::JP16() {
-		PC = bus_->ReadL(PC);
-		tTemp = 16;
-	}
 	void CPU::JPHL() {
 		PC = (H << 8) | L;
 		tTemp = 4;
 	}
+	void CPU::JP16() {
+		conditional_jump(true);
+	}
 	void CPU::JPNZ16() {
-		tTemp = 12;
-		if ((F & 0x80) == 0x00) {
-			PC = bus_->ReadL(PC);
-			tTemp += 4;
-		}
-		else
-			PC += 2;
+		conditional_jump(!(F & FLAG_ZERO_MASK));
 	}
 	void CPU::JPZ16() {
-		tTemp = 12;
-		if ((F & 0x80) == 0x80) {
-			PC = bus_->ReadL(PC);
-			tTemp += 4;
-		}
-		else
-			PC += 2;
+		conditional_jump(F & FLAG_ZERO_MASK);
 	}
 	void CPU::JPNC16() {
-		tTemp = 12;
-		if ((F & 0x10) == 0x00) {
-			PC = bus_->ReadL(PC);
-			tTemp += 4;
-		}
-		else
-			PC += 2;
+		conditional_jump(!(F & FLAG_CARRY_MASK));
 	}
 	void CPU::JPC16() {
-		tTemp = 12;
-		if ((F & 0x10) == 0x10) {
-			PC = bus_->ReadL(PC);
-			tTemp += 4;
-		}
-		else
-			PC += 2;
+		conditional_jump(F & FLAG_CARRY_MASK);
 	}
 	void CPU::JR8() {
-		auto temp = bus_->Read(PC);
-		PC += 1 + ((temp ^ 0x80) - 0x80);
-		tTemp = 12;
+		conditional_jump_rel(true);
 	}
 	void CPU::JRNZ8() {
-		int i = bus_->Read(PC);
-		PC++;
-		if ((F & (FLAG_ZERO_MASK)) == 0) {
-			PC += ((i ^ 0x80) - 0x80);
-			tTemp = 12;
-		}
-		else {
-			tTemp = 8;
-		}
+		conditional_jump_rel(!(F & FLAG_ZERO_MASK));
 	}
 	void CPU::JRZ8() {
-		if (F & FLAG_ZERO_MASK) {
-			auto temp = bus_->Read(PC);
-			PC += 1;
-			PC += (temp ^ 0x80) - 0x80;
-			tTemp = 12;
-		} else {
-			PC += 1;
-			tTemp = 8;
-		}
+		conditional_jump_rel(F & FLAG_ZERO_MASK);
 	}
 	void CPU::JRNC8() {
-		if (!(F & FLAG_CARRY_MASK)) {
-			auto temp = bus_->Read(PC);
-			PC += 1;
-			PC += ((temp ^ 0x80) - 0x80);
-			tTemp = 12;
-		} else {
-			PC += 1;
-			tTemp = 8;
-		}
+		conditional_jump_rel(!(F & FLAG_CARRY_MASK));
 	}
 	void CPU::JRC8() {
-		int i = bus_->Read(PC);
-		if (i >= 0x80)
-			i = -((~i + 1) & 255);
-		PC++;
-		tTemp = 8;
-		if ((F & 0x10) == 0x10) {
-			PC += i;
-			tTemp += 4;
-		}
+		conditional_jump_rel(F & FLAG_CARRY_MASK);
 	}
 	void CPU::ANDA() {
 		reg_and(A);
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 0ead26f0e459600d50286bc2918e0ce07a9daf68..1f79149cd7becf5da4146f736138f9daa28da362 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -85,6 +85,8 @@ namespace TKPEmu::Gameboy::Devices {
 		void bit_sl(RegisterType& reg);
 		void bit_sr(RegisterType& reg);
 		void bit_srl(RegisterType& reg);
+		void conditional_jump_rel(bool condition);
+		void conditional_jump(bool condition);
 		void rst(RegisterType addr);
 		void handle_interrupts();
 		void execute_interrupt(int bit);
diff --git a/TKPEmu/gb_tkp/gb_romdata.cpp b/TKPEmu/gb_tkp/gb_romdata.cpp
index a95c4dfffb7f9375fa08df0c48d9eb85018e8c92..cfb5413def644a8bb72e2470d5f8caa38d439639 100644
--- a/TKPEmu/gb_tkp/gb_romdata.cpp
+++ b/TKPEmu/gb_tkp/gb_romdata.cpp
@@ -14,7 +14,7 @@ namespace TKPEmu::Applications {
         static bool hashed = false;
         static std::string hash = "?";
         static std::string result = "?";
-        if (!hashed && gb_ptr->Paused) {
+        if (gb_ptr->Paused) {
             hashed = true;
             hash = gb_ptr->GetScreenshotHash();
             result = "{ \"" + gb_ptr->RomHash + "\", { " + std::to_string(gb_ptr->GetCPU().TotalClocks) + ", \"" + hash + "\" } },";
diff --git a/TKPEmu/gb_tkp/generate_test_results.sh b/TKPEmu/gb_tkp/generate_test_results.sh
index 8962ae0f61bdac6d4b02906b5382275aa7a4739f..5a9bdedbadbb5bf743b2aff6b63893bda4bdc8cc 100755
--- a/TKPEmu/gb_tkp/generate_test_results.sh
+++ b/TKPEmu/gb_tkp/generate_test_results.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 if (( $# != 3 )); then
-    >&2 echo "Correct syntax: generate_test_results (TKPEmu path) (blargg individual roms directory) (mooneye-gb tests directory)"
+    >&2 echo "Correct syntax: generate_test_results (TKPEmu path) (blargg tests directory) (mooneye-gb tests directory)"
     exit
 fi
 
@@ -17,7 +17,7 @@ echo "-----" >> $outf
 echo "**[Blargg](https://github.com/gblargg)'s tests:**    " >> $outf
 echo "Testing blargg directory $blargg"
 # Generate blargg tests
-$emu -T $blargg -p -g -G $outf
+$emu -T $blargg -r -p -g -G $outf
 echo "-----" >> $outf
 echo "**[Gekkio](https://github.com/Gekkio)'s tests:**    " >> $outf
 echo "Testing mooneye directory $mooneye"

From 3fa9243bdad2498060471f723a4a432ac1563f77 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 18 Dec 2021 14:04:25 +0200
Subject: [PATCH] Moved testmap on seperate cpp file

---
 TKPEmu/gb_tkp/TEST_RESULTS.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index 747978e17fcc1e1f7c6c2cbcac8bbfbca997a951..00d02e4d1f70c2d4afdda699f6e6c0883c4f2060 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  18  2021 01:48:17  EET.    
+GameboyTKP test results generated by offtkp on  18  2021 02:03:18  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
@@ -34,10 +34,10 @@ GameboyTKP test results generated by offtkp on  18  2021 01:48:17 
 | acceptance/reti_intr_timing | :+1: |
 | acceptance/timer/div_write | :+1: |
 | acceptance/timer/tim_00 | :+1: |
+| acceptance/timer/tim_01 | :+1: |
 | acceptance/timer/tim_10 | :+1: |
 | acceptance/timer/tim_11 | :+1: |
 | acceptance/timer/tima_reload | :+1: |
-| acceptance/timer/time_01 | :+1: |
 | emulator-only/mbc1/bits_bank1 | :+1: |
 | emulator-only/mbc1/bits_bank2 | :+1: |
 | emulator-only/mbc1/bits_mode | :+1: |

From 9f557c798eaba8b9e452441e2d96d8d572c4c4ee Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sat, 18 Dec 2021 14:29:11 +0200
Subject: [PATCH] fixed some warnings

---
 TKPEmu/gb_tkp/gameboy.cpp        | 26 +++++++++++++-------------
 TKPEmu/gb_tkp/gb_cartridge.cpp   |  8 ++++----
 TKPEmu/gb_tkp/gb_tracelogger.cpp |  2 --
 3 files changed, 17 insertions(+), 19 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 20943125dd28d5a3a2d952068bdfd1d8d1464005..2357acc2870b006e962ac65b01fec2fe5efae742 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -55,55 +55,55 @@ namespace TKPEmu::Gameboy {
 					break;
 				}
 				case LogType::A: {
-					*ofstream_ptr_ << "A:" << std::setw(2) << std::hex << (int)cpu_.A;
+					*ofstream_ptr_ << "A:" << std::setw(2) << std::hex << static_cast<int>(cpu_.A);
 					break;
 				}
 				case LogType::B: {
-					*ofstream_ptr_ << "B:" << std::setw(2) << std::hex << (int)cpu_.B;
+					*ofstream_ptr_ << "B:" << std::setw(2) << std::hex << static_cast<int>(cpu_.B);
 					break;
 				}
 				case LogType::C: {
-					*ofstream_ptr_ << "C:" << std::setw(2) <<  std::hex << (int)cpu_.C;
+					*ofstream_ptr_ << "C:" << std::setw(2) <<  std::hex << static_cast<int>(cpu_.C);
 					break;
 				}
 				case LogType::D: {
-					*ofstream_ptr_ << "D:" << std::setw(2) << std::hex << (int)cpu_.D;
+					*ofstream_ptr_ << "D:" << std::setw(2) << std::hex << static_cast<int>(cpu_.D);
 					break;
 				}
 				case LogType::E: {
-					*ofstream_ptr_ << "E:" << std::setw(2) << std::hex << (int)cpu_.A;
+					*ofstream_ptr_ << "E:" << std::setw(2) << std::hex << static_cast<int>(cpu_.A);
 					break;
 				}
 				case LogType::F: {
-					*ofstream_ptr_ << "F:" <<  std::setw(2) << std::hex << (int)cpu_.F;
+					*ofstream_ptr_ << "F:" <<  std::setw(2) << std::hex << static_cast<int>(cpu_.F);
 					break;
 				}
 				case LogType::H: {
-					*ofstream_ptr_ << "H:" << std::setw(2) << std::hex << (int)cpu_.H;
+					*ofstream_ptr_ << "H:" << std::setw(2) << std::hex << static_cast<int>(cpu_.H);
 					break;
 				}
 				case LogType::L: {
-					*ofstream_ptr_ << "L:" << std::setw(2) << std::hex << (int)cpu_.L;
+					*ofstream_ptr_ << "L:" << std::setw(2) << std::hex << static_cast<int>(cpu_.L);
 					break;
 				}
 				case LogType::LY: {
-					*ofstream_ptr_ << "LY:" << std::setw(2) << std::hex << (int)cpu_.LY;
+					*ofstream_ptr_ << "LY:" << std::setw(2) << std::hex << static_cast<int>(cpu_.LY);
 					break;
 				}
 				case LogType::IF: {
-					*ofstream_ptr_ << "IF:" << std::setw(2) << std::hex << (int)cpu_.IF;
+					*ofstream_ptr_ << "IF:" << std::setw(2) << std::hex << static_cast<int>(cpu_.IF);
 					break;
 				}
 				case LogType::IE: {
-					*ofstream_ptr_ << "IE:" << std::setw(2) << std::hex << (int)cpu_.IE;
+					*ofstream_ptr_ << "IE:" << std::setw(2) << std::hex << static_cast<int>(cpu_.IE);
 					break;
 				}
 				case LogType::IME: {
-					*ofstream_ptr_ << "IME:" << (int)cpu_.ime_;
+					*ofstream_ptr_ << "IME:" << static_cast<int>(cpu_.ime_);
 					break;
 				}
 				case LogType::HALT: {
-					*ofstream_ptr_ << "HALT:" << (int)cpu_.halt_;
+					*ofstream_ptr_ << "HALT:" << static_cast<int>(cpu_.halt_);
 					break;
 				}
 			}
diff --git a/TKPEmu/gb_tkp/gb_cartridge.cpp b/TKPEmu/gb_tkp/gb_cartridge.cpp
index 5220e43d2ef20e9f98a15b43481646d019ae7f8e..a7556ec8d8633dfe318b948bef668f34e41c7f2b 100644
--- a/TKPEmu/gb_tkp/gb_cartridge.cpp
+++ b/TKPEmu/gb_tkp/gb_cartridge.cpp
@@ -8,7 +8,7 @@ namespace TKPEmu::Gameboy::Devices {
 		is.open(fileName, std::ios::binary);
 		if (is.is_open()) {
 			is.seekg(ENTRY_POINT, std::ios_base::beg);
-			is.read((char*)&header_, sizeof(Header));
+			is.read(reinterpret_cast<char*>(&header_), sizeof(Header));
 			loaded = true;
 			is.seekg(0, std::ios_base::beg);
 			auto ct = GetCartridgeType();
@@ -23,13 +23,13 @@ namespace TKPEmu::Gameboy::Devices {
 					auto sz = GetRomSize();
 					romBanks.resize(sz);
 					for (int i = 0; i < sz; i++) {
-						is.read((char*)(&romBanks[i]), sizeof(uint8_t) * 0x4000);
+						is.read(reinterpret_cast<char*>(&romBanks[i]), sizeof(uint8_t) * 0x4000);
 					}
 					break;
 				}
 				default: {
 					// TODO: better error or implement all cartridge types, quit emulator instead of exiting
-					std::cerr << "Error: Cartridge type not implemented - " << (int)ct << std::endl;
+					std::cerr << "Error: Cartridge type not implemented - " << static_cast<int>(ct) << std::endl;
 					//exit(1);
 				}
 			}
@@ -42,7 +42,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	CartridgeType Cartridge::GetCartridgeType() const {
 		if (loaded) {
-			return (CartridgeType)header_.cartridgeType;
+			return static_cast<CartridgeType>(header_.cartridgeType);
 		}
 		return CartridgeType::ERROR;
 	}
diff --git a/TKPEmu/gb_tkp/gb_tracelogger.cpp b/TKPEmu/gb_tkp/gb_tracelogger.cpp
index bfce6a4ed1a17642260d36ae6a0a6425247cd8d3..87ab333aef6d293c8d050bb5e342c18685679173 100644
--- a/TKPEmu/gb_tkp/gb_tracelogger.cpp
+++ b/TKPEmu/gb_tkp/gb_tracelogger.cpp
@@ -19,7 +19,6 @@ namespace TKPEmu::Applications {
     }
 	void GameboyTracelogger::v_draw() {
         static bool path_changed = false;
-        static bool file_exists = false;
         static bool overwrite = false;
         if (is_logging_) {
             push_disabled();
@@ -43,7 +42,6 @@ namespace TKPEmu::Applications {
             if (std::filesystem::is_directory(path_buf_)) {
                 std::cerr << "Error: Path is directory" << std::endl;
             } else if (!overwrite && std::filesystem::exists(path_buf_)) {
-                file_exists = true;
                 // TODO: get result of "Overwrite" and act accordingly
                 ImGui::OpenPopup("Overwrite?");
             } else {

From ea254edf5b3597f734e9d5fdf0174bbedc8eafc5 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 12:06:47 +0200
Subject: [PATCH] halt fixes

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 6f82cc0dd348b8d93381166c710d4c412bd7339a..d0ba6201aed18278704e4e73a1754ae742dea5f9 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1327,10 +1327,10 @@ namespace TKPEmu::Gameboy::Devices {
 			std::cout << "halt bug" << std::endl;
 			halt_ = false;
 		}
-		if (ime_scheduled_) {
-			ime_ = true;
-			ime_scheduled_ = false;
-		}
+		// if (ime_scheduled_) {
+		// 	ime_ = true;
+		// 	ime_scheduled_ = false;
+		// }
 		tTemp = 4;
 	}
 	void CPU::XXX() {
@@ -2261,6 +2261,7 @@ namespace TKPEmu::Gameboy::Devices {
 			ime_scheduled_ = false;
 		}
 		if (halt_) {
+			TClock += 4;
 			return 4;
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
@@ -2282,7 +2283,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}	
 			} else {
 				if (halt_) {
-					halt_ = false;
+					//halt_ = false;
 					tTemp = 4;
 					return;
 				}

From d97216cec60ebf1e4f8c8218ccfdc01fd2b2ec63 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 14:18:39 +0200
Subject: [PATCH] stable

---
 TKPEmu/gb_tkp/gameboy.cpp         |  4 +++-
 TKPEmu/gb_tkp/gb_cpu.cpp          | 10 +---------
 TKPEmu/gb_tkp/gb_disassembler.cpp |  2 ++
 3 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index 2357acc2870b006e962ac65b01fec2fe5efae742..b0dd6a8ce6237e8f1f69a876f70adbe9241c1324 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -36,6 +36,7 @@ namespace TKPEmu::Gameboy {
 	void Gameboy::v_log_state() {
 		*ofstream_ptr_ << std::setfill('0');
 		int inst = bus_.ReadSafe(cpu_.PC);
+		std::cout << std::hex << (int)cpu_.PC << " " << std::hex << inst << std::endl;
 		for (const auto& t : *log_types_ptr_) {
 			switch (t) {
 				case LogType::InstrName: {
@@ -223,7 +224,8 @@ namespace TKPEmu::Gameboy {
 				}
 			}
 			ppu_.Update(clk);
-			log_state();
+			if (!cpu_.halt_)
+				log_state();
 		} else {
 			auto end = std::chrono::system_clock::now();
 			auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(end - frame_start).count();
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index d0ba6201aed18278704e4e73a1754ae742dea5f9..775293d87c99790e99fba3ffad0b84530254b69f 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -1327,10 +1327,6 @@ namespace TKPEmu::Gameboy::Devices {
 			std::cout << "halt bug" << std::endl;
 			halt_ = false;
 		}
-		// if (ime_scheduled_) {
-		// 	ime_ = true;
-		// 	ime_scheduled_ = false;
-		// }
 		tTemp = 4;
 	}
 	void CPU::XXX() {
@@ -2282,11 +2278,7 @@ namespace TKPEmu::Gameboy::Devices {
 					}
 				}	
 			} else {
-				if (halt_) {
-					//halt_ = false;
-					tTemp = 4;
-					return;
-				}
+				halt_ = false;
 			}
 		}
 	}
diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 565f141f99076697f90dd8582caa43aa78155b9a..4c2aee025164adb166c46a756579733737328620 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -1,4 +1,5 @@
 #include "gb_disassembler.h"
+#include <iostream>
 namespace TKPEmu::Applications {
     GameboyDisassembler::GameboyDisassembler(std::string menu_title, std::string window_title) : IMApplication(menu_title, window_title) {
         sel_map_.resize(0x10000);
@@ -280,6 +281,7 @@ namespace TKPEmu::Applications {
                 ImGui::Text("DE: %d,%d", t.D, t.E); ImGui::SameLine(); ImGui::Text("IE: %d", t.IE);
                 ImGui::Text("HL: %d,%d", t.H, t.L); ImGui::SameLine(); ImGui::Text("IF: %d", t.IF);
             }
+            ImGui::Text("HALT: %lu", t.halt_); ImGui::SameLine(); ImGui::Text("IME: %lu", t.ime_);
             ImGui::Text("Clocks: %lu", t.TotalClocks);
             ImGui::Checkbox("Hex", &use_hex);
             ImGui::EndChild();

From 194ef95b14521d3d5ec02500b477cd681060bc75 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 20:18:50 +0200
Subject: [PATCH] fix potential crash

---
 TKPEmu/gb_tkp/gb_disassembler.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_disassembler.cpp b/TKPEmu/gb_tkp/gb_disassembler.cpp
index 4c2aee025164adb166c46a756579733737328620..3246159cc48c53b204c6a00b66d25b6f1044f88b 100644
--- a/TKPEmu/gb_tkp/gb_disassembler.cpp
+++ b/TKPEmu/gb_tkp/gb_disassembler.cpp
@@ -124,7 +124,10 @@ namespace TKPEmu::Applications {
                     }
                     for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++) {
                         bool is_skipped = false;
-                        DisInstr ins = gameboy->GetInstruction(row_n);
+                        DisInstr ins(0, 0, 0);
+                        if (gameboy) {
+                            ins = gameboy->GetInstruction(row_n);
+                        }
                         if (skip == 0) {
                             skip += ins.ParamSize;
                             if (row_n == 0) 

From cba20cc5f91f486f45a7a420e65f01939acc048c Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 20:19:17 +0200
Subject: [PATCH] update before changing ppu

---
 TKPEmu/gb_tkp/gb_ppu.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index c47fcc9e5d190e718e40ba9fba96ed4249f4e32c..154130359466c1f97c19930cb12a8ee10a6fa2c8 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -20,7 +20,7 @@ namespace TKPEmu::Gameboy::Devices {
 				if (LY == 153) {
 					next_stat_mode = 2;
 					LY = -1;
-					clock_ %= FRAME_CYCLES;
+					clock_ = FRAME_CYCLES;
 					clock_target_ = FRAME_CYCLES;
 				}
 				IF |= set_mode(next_stat_mode);
@@ -29,6 +29,7 @@ namespace TKPEmu::Gameboy::Devices {
 					clock_target_ += 80;
 					next_stat_mode = 3;
 					LY += 1;
+					// possible bug
 					IF |= update_lyc();
 				}
 				else if (mode == 3) {

From 0196100e53ae8568772475d80a842f5841c81e1a Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 21:19:32 +0200
Subject: [PATCH] passing read_timing and write_timing

---
 TKPEmu/gb_tkp/TEST_RESULTS.md | 26 ++++++++++---------
 TKPEmu/gb_tkp/gameboy.cpp     |  9 +++----
 TKPEmu/gb_tkp/gameboy.h       |  2 +-
 TKPEmu/gb_tkp/gb_cpu.cpp      | 58 ++++++++++++++++++++++++++++++++-----------
 TKPEmu/gb_tkp/gb_cpu.h        | 10 +++++++-
 5 files changed, 72 insertions(+), 33 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index 00d02e4d1f70c2d4afdda699f6e6c0883c4f2060..2cc12383c9e693eccafb953397fd430598043886 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,20 +1,22 @@
-GameboyTKP test results generated by offtkp on  18  2021 02:03:18  EET.    
+GameboyTKP test results generated by offtkp on  19  2021 09:17:55  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
-| 01-special | :+1: |
-| 02-interrupts | :+1: |
-| 03-op sp,hl | :+1: |
-| 04-op r,imm | :+1: |
-| 05-op rp | :+1: |
-| 06-ld r,r | :+1: |
-| 07-jr,jp,call,ret,rst | :+1: |
-| 08-misc instrs | :+1: |
-| 09-op r,r | :+1: |
-| 10-bit ops | :+1: |
-| 11-op a,(hl) | :+1: |
+| cpu_instrs/01-special | :+1: |
+| cpu_instrs/03-op sp,hl | :+1: |
+| cpu_instrs/04-op r,imm | :+1: |
+| cpu_instrs/05-op rp | :+1: |
+| cpu_instrs/06-ld r,r | :+1: |
+| cpu_instrs/07-jr,jp,call,ret,rst | :+1: |
+| cpu_instrs/08-misc instrs | :+1: |
+| cpu_instrs/09-op r,r | :+1: |
+| cpu_instrs/10-bit ops | :+1: |
+| cpu_instrs/11-op a,(hl) | :+1: |
+| cpu_instrs02-interrupts | :+1: |
 | instr_timing | :+1: |
+| mem_timing/01-read_timing | :+1: |
+| mem_timing/02-write_timing | :+1: |
 -----
 **[Gekkio](https://github.com/Gekkio)'s tests:**    
 | Test | GameboyTKP |
diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index b0dd6a8ce6237e8f1f69a876f70adbe9241c1324..c00074c8ef2b38c641bd452145c3feda8f8b6738 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -9,9 +9,9 @@
 namespace TKPEmu::Gameboy {
 	Gameboy::Gameboy() : 
 		bus_(Instructions),
-		cpu_(&bus_),
 		ppu_(&bus_, &DrawMutex),
 		timer_(&bus_),
+		cpu_(&bus_, &ppu_, &timer_),
 		joypad_(bus_.GetReference(addr_joy)),
 		interrupt_flag_(bus_.GetReference(addr_if))
 	{}
@@ -207,20 +207,19 @@ namespace TKPEmu::Gameboy {
 		ppu_.Reset();
 	}
 	void Gameboy::update() {
-		static bool skip_next = false;
 		if ((cpu_.TClock / 2) < cpu_.MaxCycles || FastMode) {
 			if (cpu_.PC == 0x100) {
 				bus_.BiosEnabled = false;
 			}
 			uint8_t old_if = interrupt_flag_;
 			int clk = 0;
-			if (!skip_next)
+			if (!cpu_.skip_next_)
 				clk = cpu_.Update();	
-			skip_next = false;
+			cpu_.skip_next_ = false;
 			if (timer_.Update(clk, old_if)) {
 				if (cpu_.halt_) {
 					cpu_.halt_ = false;
-					skip_next = true;
+					cpu_.skip_next_ = true;
 				}
 			}
 			ppu_.Update(clk);
diff --git a/TKPEmu/gb_tkp/gameboy.h b/TKPEmu/gb_tkp/gameboy.h
index e82e080f354c0899ba579495b7b4b3f1bff56324..d52d1e965a3d2fad24ee59297d8b9a35a7dc0023 100644
--- a/TKPEmu/gb_tkp/gameboy.h
+++ b/TKPEmu/gb_tkp/gameboy.h
@@ -44,9 +44,9 @@ namespace TKPEmu::Gameboy {
 		std::vector<DisInstr> Instructions{};
 	private:
 		Bus bus_;
-		CPU cpu_;
 		PPU ppu_;
 		Timer timer_;
+		CPU cpu_;
 		GameboyKeys direction_keys_;
 		GameboyKeys action_keys_;
 		uint8_t& joypad_, &interrupt_flag_;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 775293d87c99790e99fba3ffad0b84530254b69f..03349952365e07501f69634e145eb1ec0c334552 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2,7 +2,10 @@
 #include <stdexcept>
 #include <iostream>
 namespace TKPEmu::Gameboy::Devices {
-	CPU::CPU(Bus* bus) : bus_(bus),
+	CPU::CPU(Bus* bus, PPU* ppu, Timer* timer) :
+		bus_(bus),
+		ppu_(ppu),
+		timer_(timer),
 		IF(bus->GetReference(0xFF0F)),
 		IE(bus->GetReference(0xFFFF)),
 		LY(bus->GetReference(0xFF44)),
@@ -762,7 +765,7 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::LDHL8() {
-		bus_->Write((H << 8) | L, bus_->Read(PC));
+		write((H << 8) | L, bus_->Read(PC));
 		PC++;
 		tTemp = 12;
 	}
@@ -775,12 +778,14 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::LD16A() {
-		bus_->Write(bus_->ReadL(PC), A);
+		delay();
+		write(bus_->ReadL(PC), A);
 		PC += 2;
 		tTemp = 16;
 	}
 	void CPU::LDA16() {
-		A = bus_->Read(bus_->ReadL(PC));
+		delay();
+		A = read(bus_->ReadL(PC));
 		PC += 2;
 		tTemp = 16;
 	}
@@ -1284,12 +1289,12 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 12;
 	}
 	void CPU::LDHA8() {
-		A = bus_->Read(0xFF00 + bus_->Read(PC));
+		A = read(0xFF00 + bus_->Read(PC));
 		PC++;
 		tTemp = 12;
 	}
 	void CPU::LDH8A() {
-		bus_->Write(0xFF00 + bus_->Read(PC), A);
+		write(0xFF00 + bus_->Read(PC), A);
 		PC++;
 		tTemp = 12;
 	}
@@ -1617,7 +1622,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 0);
 	}
 	void CPU::BIT0M() {
-		bit_ch(bus_->Read((H << 8) | L), 0);
+		bit_ch(read((H << 8) | L), 0);
 		tTemp = 12;
 	}
 	void CPU::BIT1B() {
@@ -1642,7 +1647,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 1);
 	}
 	void CPU::BIT1M() {
-		bit_ch(bus_->Read((H << 8) | L), 1);
+		bit_ch(read((H << 8) | L), 1);
 		tTemp = 12;
 	}
 	void CPU::BIT2B() {
@@ -1667,7 +1672,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 2);
 	}
 	void CPU::BIT2M() {
-		bit_ch(bus_->Read((H << 8) | L), 2);
+		bit_ch(read((H << 8) | L), 2);
 		tTemp = 12;
 	}
 	void CPU::BIT3B() {
@@ -1692,7 +1697,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 3);
 	}
 	void CPU::BIT3M() {
-		bit_ch(bus_->Read((H << 8) | L), 3);
+		bit_ch(read((H << 8) | L), 3);
 		tTemp = 12;
 	}
 	void CPU::BIT4B() {
@@ -1717,7 +1722,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 4);
 	}
 	void CPU::BIT4M() {
-		bit_ch(bus_->Read((H << 8) | L), 4);
+		bit_ch(read((H << 8) | L), 4);
 		tTemp = 12;
 	}
 	void CPU::BIT5B() {
@@ -1742,7 +1747,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 5);
 	}
 	void CPU::BIT5M() {
-		bit_ch(bus_->Read((H << 8) | L), 5);
+		bit_ch(read((H << 8) | L), 5);
 		tTemp = 12;
 	}
 	void CPU::BIT6B() {
@@ -1767,7 +1772,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 6);
 	}
 	void CPU::BIT6M() {
-		bit_ch(bus_->Read((H << 8) | L), 6);
+		bit_ch(read((H << 8) | L), 6);
 		tTemp = 12;
 	}
 	void CPU::BIT7B() {
@@ -1792,7 +1797,7 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_ch(A, 7);
 	}
 	void CPU::BIT7M() {
-		bit_ch(bus_->Read((H << 8) | L), 7);
+		bit_ch(read((H << 8) | L), 7);
 		tTemp = 12;
 	}
 	void CPU::RES0B(){
@@ -2251,6 +2256,8 @@ namespace TKPEmu::Gameboy::Devices {
 		JOYP = 0b1110'1111;
 	}
 	int CPU::Update() {
+		tTemp = 0;
+		tRemove = 0;
 		handle_interrupts();
 		if (ime_scheduled_) {
 			ime_ = true;
@@ -2262,6 +2269,11 @@ namespace TKPEmu::Gameboy::Devices {
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
 		TClock += tTemp;
+		if (tTemp >= tRemove) {
+			tTemp -= tRemove;
+		} else {
+			tTemp = 0;
+		}
 		TotalClocks += 1;
 		return tTemp;
 	}
@@ -2294,4 +2306,22 @@ namespace TKPEmu::Gameboy::Devices {
 			tTemp = 24;
 		}
 	}
+	uint8_t CPU::read(uint16_t addr) {
+		delay();
+		return bus_->Read(addr);
+	}
+	void CPU::write(uint16_t addr, uint8_t val) {
+		delay();
+		bus_->Write(addr, val);
+	}
+	void CPU::delay() {
+		tRemove += 4;
+		if (timer_->Update(4, IF)) {
+			if (halt_) {
+				halt_ = false;
+				skip_next_ = true;
+			}
+		}
+		ppu_->Update(4);
+	}
 }
diff --git a/TKPEmu/gb_tkp/gb_cpu.h b/TKPEmu/gb_tkp/gb_cpu.h
index 1f79149cd7becf5da4146f736138f9daa28da362..bd7cc5c4710aa95559c965aed1b2913687b4c15e 100644
--- a/TKPEmu/gb_tkp/gb_cpu.h
+++ b/TKPEmu/gb_tkp/gb_cpu.h
@@ -8,14 +8,18 @@
 #include <fstream>
 #include "gb_bus.h"
 #include "gb_ppu.h"
+#include "gb_timer.h"
 #include "gb_addresses.h"
 #include "../include/disassembly_instr.h"
 namespace TKPEmu::Gameboy::Devices {
 	class CPU {
 	private:
 		Bus* bus_;
+		PPU* ppu_;
+		Timer* timer_;
 		bool ime_scheduled_ = false;
 		int tTemp = 0;
+		int tRemove = 0;
 		int div_reset_index_ = -1;
 		int old_tac_ = 0;
 		int tac_index_ = 0x1000;
@@ -85,6 +89,9 @@ namespace TKPEmu::Gameboy::Devices {
 		void bit_sl(RegisterType& reg);
 		void bit_sr(RegisterType& reg);
 		void bit_srl(RegisterType& reg);
+		uint8_t read(uint16_t addr);
+		void write(uint16_t addr, uint8_t val);
+		void delay();
 		void conditional_jump_rel(bool condition);
 		void conditional_jump(bool condition);
 		void rst(RegisterType addr);
@@ -94,9 +101,10 @@ namespace TKPEmu::Gameboy::Devices {
 		int get_clk_freq();
 
 	public:
-		CPU(Bus* bus);
+		CPU(Bus* bus, PPU* ppu, Timer* timer);
 		bool halt_ = false;
 		bool ime_ = false;
+		bool skip_next_ = false;
 		struct Instruction {
 			std::string name;
 			void(CPU::* op)() = nullptr;

From 13cc4158cf2ba08186d6aa3e4c0e48ea1c052a4d Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 22:20:25 +0200
Subject: [PATCH] fixed dma, passing oam_dma tests: basic reg_read

---
 TKPEmu/gb_tkp/TEST_RESULTS.md |  3 ++-
 TKPEmu/gb_tkp/gameboy.cpp     |  2 +-
 TKPEmu/gb_tkp/gb_bus.cpp      | 30 +++++++++---------------------
 TKPEmu/gb_tkp/gb_bus.h        | 10 +---------
 TKPEmu/gb_tkp/gb_ppu.cpp      |  8 ++++----
 5 files changed, 17 insertions(+), 36 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index 2cc12383c9e693eccafb953397fd430598043886..acc20c17384eb69da33803d6eedd4a2615e23d8e 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  19  2021 09:17:55  EET.    
+GameboyTKP test results generated by offtkp on  19  2021 10:19:51  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
@@ -32,6 +32,7 @@ GameboyTKP test results generated by offtkp on  19  2021 09:17:55 
 | acceptance/halt_ime1_timing | :+1: |
 | acceptance/instrs/daa | :+1: |
 | acceptance/oam_dma/reg_read | :+1: |
+| acceptance/omad_dma/basic | :+1: |
 | acceptance/rapid_di_ei | :+1: |
 | acceptance/reti_intr_timing | :+1: |
 | acceptance/timer/div_write | :+1: |
diff --git a/TKPEmu/gb_tkp/gameboy.cpp b/TKPEmu/gb_tkp/gameboy.cpp
index c00074c8ef2b38c641bd452145c3feda8f8b6738..86d0600c62f1a973c754990c7f74be4ee83cef63 100644
--- a/TKPEmu/gb_tkp/gameboy.cpp
+++ b/TKPEmu/gb_tkp/gameboy.cpp
@@ -187,7 +187,7 @@ namespace TKPEmu::Gameboy {
 					Step.wait(false);
 					Step.store(false);
 					update();
-					InstructionBreak.store(cpu_.PC);
+					//InstructionBreak.store(cpu_.PC);
 				}
 			}
 		};
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 9f170a2ae7a67815bdadbbaebe5123d6fa0dc869..c3dbba5e0f1456f6d2030438c76b091a02921189 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -186,7 +186,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				else if (address <= 0xFE9F) {
 					// OAM
-					return oam_[address & 0x9F];
+					return oam_[address & 0xFF];
 				}
 				else if (address <= 0xFEFF) {
 					// TODO: check if this is actually unused area
@@ -228,11 +228,11 @@ namespace TKPEmu::Gameboy::Devices {
 		for (const auto& m : vram_) {
 			s << std::hex << std::setfill('0') << std::setw(2) << m;
 		}
-		for (const auto& m : OAM) {
-			s << std::hex << std::setfill('0') << std::setw(2) << m.flags;
-			s << std::hex << std::setfill('0') << std::setw(2) << m.tile_index;
-			s << std::hex << std::setfill('0') << std::setw(2) << m.x_pos;
-			s << std::hex << std::setfill('0') << std::setw(2) << m.y_pos;
+		for (int i = 0; i < oam_.size(); i += 4) {
+			s << std::hex << std::setfill('0') << std::setw(2) << oam_[i + 3];
+			s << std::hex << std::setfill('0') << std::setw(2) << oam_[i + 2];
+			s << std::hex << std::setfill('0') << std::setw(2) << oam_[i + 1];
+			s << std::hex << std::setfill('0') << std::setw(2) << oam_[i];
 		}
 		return std::move(s.str());
 	}
@@ -267,17 +267,10 @@ namespace TKPEmu::Gameboy::Devices {
 				case addr_dma: {
 					// DMA transfer, load oam up.
 					uint16_t dma_addr = data << 8;
-					for (int i = 0; i <= (0x9F - 4); i += 4) {
+					for (int i = 0; i < oam_.size(); i++) {
 						uint16_t source = dma_addr | i;
 						// Each sprite is 4 bytes, so the array has size of 160/4 = 40 
-						oam_[i]         = ReadSafe(source);
-						oam_[i + 1]     = ReadSafe(source + 1);
-						oam_[i + 2]     = ReadSafe(source + 2);
-						oam_[i + 3]     = ReadSafe(source + 3);
-						OAM[i / 4].y_pos      = oam_[i];
-						OAM[i / 4].x_pos      = oam_[i + 1];
-						OAM[i / 4].tile_index = oam_[i + 2];
-						OAM[i / 4].flags      = oam_[i + 3];
+						oam_[i] = ReadSafe(source);	
 					}
 					break;
 				}
@@ -360,12 +353,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 			}
 			if (address >= 0xFE00 && address <= 0xFE9F) {
-				switch (address % 4) { 
-					case 0: OAM[(address & 0xFF) / 4].y_pos      = data; break;
-					case 1: OAM[(address & 0xFF) / 4].x_pos      = data; break;
-					case 2: OAM[(address & 0xFF) / 4].tile_index = data; break;
-					case 3: OAM[(address & 0xFF) / 4].flags      = data; break;
-				}
+				oam_[address & 0xFF] = data;
 			}
 			if (address == 0xFFFF) {
 			}
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index 17463b7932dc74b8a05d9c0ea5a3bfa8f38928a1..f13d4fe9db78580663952e156be6198b4e2d2078 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -17,12 +17,6 @@ namespace TKPEmu::Gameboy::Devices {
         using RomBank = std::array<uint8_t, 0x4000>;
         using CartridgeType = TKPEmu::Gameboy::Devices::CartridgeType;
     public:
-        struct Sprite {
-            uint8_t y_pos = 0;
-            uint8_t x_pos = 0;
-            uint8_t tile_index = 0;
-            uint8_t flags = 0;
-        };
         bool BiosEnabled = true;
         uint8_t logo[0x30] = {
             // Every 2 bytes is an 8x8 tile. If you convert the hex to binary, each bit is a 2x2 pixel
@@ -70,14 +64,13 @@ namespace TKPEmu::Gameboy::Devices {
         std::array<uint8_t, 4> BGPalette{};
         std::array<uint8_t, 4> OBJ0Palette{};
         std::array<uint8_t, 4> OBJ1Palette{};
-        // TODO: remove big OAM
-        std::array<Sprite, 40> OAM;
         bool DIVReset = false;
         bool TACChanged = false;
         bool WriteToVram = false;
         uint8_t NextMode = 0;
         uint8_t DirectionKeys = 0b1110'1111;
         uint8_t ActionKeys = 0b1101'1111;
+        std::array<uint8_t, 0xA0> oam_{};
     private:
         bool ram_enabled_ = false;
         bool rtc_enabled_ = false;
@@ -90,7 +83,6 @@ namespace TKPEmu::Gameboy::Devices {
         std::vector<RamBank> ram_banks_;
         std::vector<RomBank> rom_banks_;
         std::unique_ptr<Cartridge> cartridge_;
-        std::array<uint8_t, 0xA0> oam_{};
         std::array<uint8_t, 0x100> hram_{};
         std::array<uint8_t, 0x2000> eram_default_{};
         std::array<uint8_t, 0x2000> wram_{};
diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index 154130359466c1f97c19930cb12a8ee10a6fa2c8..cd9a6dcb286ba6d7a2421c398a909541f3c8b5a7 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -221,10 +221,10 @@ namespace TKPEmu::Gameboy::Devices {
 			use8x16 = true;
 
 		for (int sprite = 0; sprite < 40; sprite++) {
-			uint8_t positionY = bus_->OAM[sprite].y_pos - 16;
-			uint8_t positionX = bus_->OAM[sprite].x_pos - 8;
-			uint8_t tileLoc = bus_->OAM[sprite].tile_index;
-			uint8_t attributes = bus_->OAM[sprite].flags;
+			uint8_t positionY = bus_->oam_[sprite] - 16;
+			uint8_t positionX = bus_->oam_[sprite + 1] - 8;
+			uint8_t tileLoc = bus_->oam_[sprite + 2];
+			uint8_t attributes = bus_->oam_[sprite + 3];
 
 			bool yFlip = attributes & 0b1000000;
 			bool xFlip = attributes & 0b100000;

From 0ada106e1441960b44ad6147615795c4354c25ad Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 22:21:31 +0200
Subject: [PATCH] fixed typo in results

---
 TKPEmu/gb_tkp/TEST_RESULTS.md | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index acc20c17384eb69da33803d6eedd4a2615e23d8e..b02d9642df8d47dd0732b10c482fc883feed12fd 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  19  2021 10:19:51  EET.    
+GameboyTKP test results generated by offtkp on  19  2021 10:21:16  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
@@ -31,8 +31,8 @@ GameboyTKP test results generated by offtkp on  19  2021 10:19:51 
 | acceptance/halt_ime0_ei | :+1: |
 | acceptance/halt_ime1_timing | :+1: |
 | acceptance/instrs/daa | :+1: |
+| acceptance/oam_dma/basic | :+1: |
 | acceptance/oam_dma/reg_read | :+1: |
-| acceptance/omad_dma/basic | :+1: |
 | acceptance/rapid_di_ei | :+1: |
 | acceptance/reti_intr_timing | :+1: |
 | acceptance/timer/div_write | :+1: |

From c5907e099d74f1351f185d1023138cc43459d701 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 22:26:46 +0200
Subject: [PATCH] fix graphical bug

---
 TKPEmu/gb_tkp/gb_ppu.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_ppu.cpp b/TKPEmu/gb_tkp/gb_ppu.cpp
index cd9a6dcb286ba6d7a2421c398a909541f3c8b5a7..0ce840169d6558e3d0de4f1890516297219fc541 100644
--- a/TKPEmu/gb_tkp/gb_ppu.cpp
+++ b/TKPEmu/gb_tkp/gb_ppu.cpp
@@ -221,10 +221,10 @@ namespace TKPEmu::Gameboy::Devices {
 			use8x16 = true;
 
 		for (int sprite = 0; sprite < 40; sprite++) {
-			uint8_t positionY = bus_->oam_[sprite] - 16;
-			uint8_t positionX = bus_->oam_[sprite + 1] - 8;
-			uint8_t tileLoc = bus_->oam_[sprite + 2];
-			uint8_t attributes = bus_->oam_[sprite + 3];
+			uint8_t positionY = bus_->oam_[sprite * 4] - 16;
+			uint8_t positionX = bus_->oam_[sprite * 4 + 1] - 8;
+			uint8_t tileLoc = bus_->oam_[sprite * 4 + 2];
+			uint8_t attributes = bus_->oam_[sprite * 4 + 3];
 
 			bool yFlip = attributes & 0b1000000;
 			bool xFlip = attributes & 0b100000;

From c006cdef3007618bf2f1a01f1f2d94a255a06ccd Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 22:36:39 +0200
Subject: [PATCH] pop_timing (pop bc) pass

---
 TKPEmu/gb_tkp/gb_bus.cpp | 1 +
 TKPEmu/gb_tkp/gb_cpu.cpp | 3 ++-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index c3dbba5e0f1456f6d2030438c76b091a02921189..ce12a918b1368581b9402709e9e9d77b96ca21a8 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -266,6 +266,7 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				case addr_dma: {
 					// DMA transfer, load oam up.
+					std::cout << "dma transfer" << std::endl;
 					uint16_t dma_addr = data << 8;
 					for (int i = 0; i < oam_.size(); i++) {
 						uint16_t source = dma_addr | i;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 03349952365e07501f69634e145eb1ec0c334552..976d7f6b6135841f673f2daeb5894dcaed650ee2 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -441,8 +441,9 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 16;
 	}
 	void CPU::POPBC() {
-		B = bus_->Read(SP + 1);
 		C = bus_->Read(SP);
+		B = read(SP + 1);
+		delay();
 		SP += 2;
 		tTemp = 12;
 	}

From 8ce6e1d61d9de657f9b02a1141fc4455a2c846c6 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Sun, 19 Dec 2021 23:39:42 +0200
Subject: [PATCH] pass oam_dma_timing and oam_dma_restart

---
 TKPEmu/gb_tkp/gb_bus.cpp | 49 +++++++++++++++++++++++++++++++++++-------------
 TKPEmu/gb_tkp/gb_bus.h   |  5 +++++
 TKPEmu/gb_tkp/gb_cpu.cpp |  9 +++++----
 3 files changed, 46 insertions(+), 17 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index ce12a918b1368581b9402709e9e9d77b96ca21a8..36e1f6db561eca670973cef28f7e452fc3437844 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -186,6 +186,10 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				else if (address <= 0xFE9F) {
 					// OAM
+					if (dma_transfer_) {
+						unused_mem_area_ = 0xFF;
+						return unused_mem_area_;
+					}
 					return oam_[address & 0xFF];
 				}
 				else if (address <= 0xFEFF) {
@@ -266,13 +270,11 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				case addr_dma: {
 					// DMA transfer, load oam up.
-					std::cout << "dma transfer" << std::endl;
-					uint16_t dma_addr = data << 8;
-					for (int i = 0; i < oam_.size(); i++) {
-						uint16_t source = dma_addr | i;
-						// Each sprite is 4 bytes, so the array has size of 160/4 = 40 
-						oam_[i] = ReadSafe(source);	
-					}
+					std::cout << "dma transfer:" << std::hex << (int)data << std::endl;
+					dma_transfer_ = true;
+					dma_setup_ = true;
+					dma_index_ = 0;
+					dma_offset_ = data << 8;
 					break;
 				}
 				case addr_lcd: {
@@ -356,8 +358,6 @@ namespace TKPEmu::Gameboy::Devices {
 			if (address >= 0xFE00 && address <= 0xFE9F) {
 				oam_[address & 0xFF] = data;
 			}
-			if (address == 0xFFFF) {
-			}
 			redirect_address(address) = data;
 		}
 	}
@@ -373,11 +373,11 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void Bus::SoftReset() {
 		for (auto& ram : ram_banks_) {
-			ram.fill(0);
+			ram.fill(0xFF);
 		}
-		hram_.fill(0);
-		oam_.fill(0);
-		vram_.fill(0);
+		hram_.fill(0xFF);
+		oam_.fill(0xFF);
+		vram_.fill(0xFF);
 		selected_rom_bank_ = 1;
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;
@@ -391,4 +391,27 @@ namespace TKPEmu::Gameboy::Devices {
 		cartridge_->Load(fileName, rom_banks_, ram_banks_);
 		rom_banks_size_ = cartridge_->GetRomSize();
 	}
+	void Bus::TransferDMA(uint8_t clk) {
+		if (dma_transfer_) {
+			int times = clk / 4;
+			if (dma_setup_) {
+				// We need 1 clock to setup dma
+				times -= 1;
+				dma_setup_ = false;
+			}
+			for (int i = 0; i < times; ++i) {
+				auto index = dma_index_ + i;
+				if (index < oam_.size() + 1) {
+					if (index < oam_.size()) {
+						uint16_t source = dma_offset_ | index;
+						oam_[index] = ReadSafe(source);	
+					}
+				} else {
+					dma_transfer_ = false;
+					return;
+				}
+			}
+			dma_index_ += times;
+		}
+	}
 }
diff --git a/TKPEmu/gb_tkp/gb_bus.h b/TKPEmu/gb_tkp/gb_bus.h
index f13d4fe9db78580663952e156be6198b4e2d2078..2b2e405e78ccb3f17c99745bc818c507b32bb1b4 100644
--- a/TKPEmu/gb_tkp/gb_bus.h
+++ b/TKPEmu/gb_tkp/gb_bus.h
@@ -55,6 +55,7 @@ namespace TKPEmu::Gameboy::Devices {
         uint8_t& GetReference(uint16_t address);
         void Write(uint16_t address, uint8_t data);
         void WriteL(uint16_t address, uint16_t data);
+        void TransferDMA(uint8_t clk);
         void Reset();
         void SoftReset();
         Cartridge* GetCartridge() ;
@@ -79,6 +80,10 @@ namespace TKPEmu::Gameboy::Devices {
         uint8_t rom_banks_size_ = 2;
         bool banking_mode_ = false;
         bool action_key_mode_ = false;
+        bool dma_transfer_ = false;
+        bool dma_setup_ = false;
+        size_t dma_index_ = 0;
+        uint16_t dma_offset_ = 0;
         uint8_t unused_mem_area_ = 0;
         std::vector<RamBank> ram_banks_;
         std::vector<RomBank> rom_banks_;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index 976d7f6b6135841f673f2daeb5894dcaed650ee2..dc8ba3038bb5766f2fa64714ee55511f169b8993 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -456,18 +456,18 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::POPDE() {
 		E = bus_->Read(SP);
-		D = bus_->Read(SP + 1);
+		D = read(SP + 1);
+		delay();
 		SP += 2;
 		tTemp = 12;
 	}
 	void CPU::POPHL() {
 		L = bus_->Read(SP);
-		H = bus_->Read(SP + 1);
+		H = read(SP + 1);
+		delay();
 		SP += 2;
 		tTemp = 12;
 	}
-
-
 	void CPU::LDABC() {
 		int addr = C | (B << 8);
 		A = bus_->Read(addr);
@@ -2269,6 +2269,7 @@ namespace TKPEmu::Gameboy::Devices {
 			return 4;
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
+		bus_->TransferDMA(tTemp);
 		TClock += tTemp;
 		if (tTemp >= tRemove) {
 			tTemp -= tRemove;

From 349f2e601b08a2cb7bda9e2328e7b1f8b5b4cc4c Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 20 Dec 2021 00:24:31 +0200
Subject: [PATCH] fixed bug wrong startup regs

---
 TKPEmu/gb_tkp/gb_bus.cpp | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 36e1f6db561eca670973cef28f7e452fc3437844..37049cd5f86fe83c70edcde86db14258c56c55bf 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -269,8 +269,6 @@ namespace TKPEmu::Gameboy::Devices {
 					break;
 				}
 				case addr_dma: {
-					// DMA transfer, load oam up.
-					std::cout << "dma transfer:" << std::hex << (int)data << std::endl;
 					dma_transfer_ = true;
 					dma_setup_ = true;
 					dma_index_ = 0;
@@ -373,11 +371,11 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void Bus::SoftReset() {
 		for (auto& ram : ram_banks_) {
-			ram.fill(0xFF);
+			ram.fill(0);
 		}
-		hram_.fill(0xFF);
-		oam_.fill(0xFF);
-		vram_.fill(0xFF);
+		hram_.fill(0);
+		oam_.fill(0);
+		vram_.fill(0);
 		selected_rom_bank_ = 1;
 		selected_ram_bank_ = 0;
 		BiosEnabled = true;

From a2915d8be8ce1acbd88ff5bbafdf9a0155de083c Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 20 Dec 2021 00:27:12 +0200
Subject: [PATCH] fix result hash

---
 TKPEmu/gb_tkp/TEST_RESULTS.md | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index b02d9642df8d47dd0732b10c482fc883feed12fd..f0296d0ab02bda0d2304f97657b70375209dd7db 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  19  2021 10:21:16  EET.    
+GameboyTKP test results generated by offtkp on  20  2021 12:26:40  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
@@ -33,6 +33,9 @@ GameboyTKP test results generated by offtkp on  19  2021 10:21:16 
 | acceptance/instrs/daa | :+1: |
 | acceptance/oam_dma/basic | :+1: |
 | acceptance/oam_dma/reg_read | :+1: |
+| acceptance/oam_dma_restart | :+1: |
+| acceptance/oam_dma_timing | :+1: |
+| acceptance/pop_timing | :+1: |
 | acceptance/rapid_di_ei | :+1: |
 | acceptance/reti_intr_timing | :+1: |
 | acceptance/timer/div_write | :+1: |

From 7f719a2dc285dae2ad01adebea96fda50f91a497 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 20 Dec 2021 00:46:19 +0200
Subject: [PATCH] stable oam test pass

---
 TKPEmu/gb_tkp/TEST_RESULTS.md |  2 +-
 TKPEmu/gb_tkp/gb_bus.cpp      | 12 ++----------
 TKPEmu/gb_tkp/gb_cpu.cpp      |  5 ++---
 3 files changed, 5 insertions(+), 14 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index f0296d0ab02bda0d2304f97657b70375209dd7db..321b22838b7e10de2ede6ca1b82b505194ebcc30 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  20  2021 12:26:40  EET.    
+GameboyTKP test results generated by offtkp on  20  2021 12:45:53  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
diff --git a/TKPEmu/gb_tkp/gb_bus.cpp b/TKPEmu/gb_tkp/gb_bus.cpp
index 37049cd5f86fe83c70edcde86db14258c56c55bf..def26ac24d52c04a55277e8df400e6dd1ada8a28 100644
--- a/TKPEmu/gb_tkp/gb_bus.cpp
+++ b/TKPEmu/gb_tkp/gb_bus.cpp
@@ -270,7 +270,6 @@ namespace TKPEmu::Gameboy::Devices {
 				}
 				case addr_dma: {
 					dma_transfer_ = true;
-					dma_setup_ = true;
 					dma_index_ = 0;
 					dma_offset_ = data << 8;
 					break;
@@ -392,18 +391,11 @@ namespace TKPEmu::Gameboy::Devices {
 	void Bus::TransferDMA(uint8_t clk) {
 		if (dma_transfer_) {
 			int times = clk / 4;
-			if (dma_setup_) {
-				// We need 1 clock to setup dma
-				times -= 1;
-				dma_setup_ = false;
-			}
 			for (int i = 0; i < times; ++i) {
 				auto index = dma_index_ + i;
 				if (index < oam_.size() + 1) {
-					if (index < oam_.size()) {
-						uint16_t source = dma_offset_ | index;
-						oam_[index] = ReadSafe(source);	
-					}
+					uint16_t source = dma_offset_ | index;
+					oam_[index] = ReadSafe(source);	
 				} else {
 					dma_transfer_ = false;
 					return;
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index dc8ba3038bb5766f2fa64714ee55511f169b8993..b74cb1699df5bbdc184a743e38d75583a9b0a8fe 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -418,8 +418,6 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::CPAL() {
 		reg_cmp(L);
 	}
-
-
 	void CPU::PUSHBC() {
 		SP -= 2;
 		bus_->WriteL(SP, (B << 8) | C);
@@ -2269,13 +2267,13 @@ namespace TKPEmu::Gameboy::Devices {
 			return 4;
 		}
 		(this->*Instructions[bus_->Read(PC++)].op)();
-		bus_->TransferDMA(tTemp);
 		TClock += tTemp;
 		if (tTemp >= tRemove) {
 			tTemp -= tRemove;
 		} else {
 			tTemp = 0;
 		}
+		bus_->TransferDMA(tTemp);
 		TotalClocks += 1;
 		return tTemp;
 	}
@@ -2318,6 +2316,7 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::delay() {
 		tRemove += 4;
+		bus_->TransferDMA(4);
 		if (timer_->Update(4, IF)) {
 			if (halt_) {
 				halt_ = false;

From 3ead36017e625dbfe29a43f9c20154c3bf5cdce2 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 20 Dec 2021 01:43:53 +0200
Subject: [PATCH] passed all mem_timing tests and some other timing tests fixes
 #18

---
 TKPEmu/gb_tkp/TEST_RESULTS.md |   9 +++-
 TKPEmu/gb_tkp/gb_cpu.cpp      | 117 +++++++++++++++++++++++-------------------
 2 files changed, 72 insertions(+), 54 deletions(-)

diff --git a/TKPEmu/gb_tkp/TEST_RESULTS.md b/TKPEmu/gb_tkp/TEST_RESULTS.md
index 321b22838b7e10de2ede6ca1b82b505194ebcc30..7b58fc38bda78377a1e4ecc03bc61aed599cea8d 100644
--- a/TKPEmu/gb_tkp/TEST_RESULTS.md
+++ b/TKPEmu/gb_tkp/TEST_RESULTS.md
@@ -1,4 +1,4 @@
-GameboyTKP test results generated by offtkp on  20  2021 12:45:53  EET.    
+GameboyTKP test results generated by offtkp on  20  2021 01:42:52  EET.    
 -----
 **[Blargg](https://github.com/gblargg)'s tests:**    
 | Test | GameboyTKP |
@@ -17,10 +17,12 @@ GameboyTKP test results generated by offtkp on  20  2021 12:45:53 
 | instr_timing | :+1: |
 | mem_timing/01-read_timing | :+1: |
 | mem_timing/02-write_timing | :+1: |
+| mem_timing/03-modify_timing | :+1: |
 -----
 **[Gekkio](https://github.com/Gekkio)'s tests:**    
 | Test | GameboyTKP |
 | -- | -- |
+| acceptance/add_sp_e_timing | :+1: |
 | acceptance/bits/mem_oam | :+1: |
 | acceptance/bits/reg_f | :+1: |
 | acceptance/bits/unused_hwio-GS | :+1: |
@@ -31,13 +33,18 @@ GameboyTKP test results generated by offtkp on  20  2021 12:45:53 
 | acceptance/halt_ime0_ei | :+1: |
 | acceptance/halt_ime1_timing | :+1: |
 | acceptance/instrs/daa | :+1: |
+| acceptance/jp_timing | :+1: |
+| acceptance/ld_hl_sp_e_timing | :+1: |
 | acceptance/oam_dma/basic | :+1: |
 | acceptance/oam_dma/reg_read | :+1: |
 | acceptance/oam_dma_restart | :+1: |
 | acceptance/oam_dma_timing | :+1: |
 | acceptance/pop_timing | :+1: |
 | acceptance/rapid_di_ei | :+1: |
+| acceptance/ret_cc_timing | :+1: |
+| acceptance/ret_timing | :+1: |
 | acceptance/reti_intr_timing | :+1: |
+| acceptance/reti_timing | :+1: |
 | acceptance/timer/div_write | :+1: |
 | acceptance/timer/tim_00 | :+1: |
 | acceptance/timer/tim_01 | :+1: |
diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index b74cb1699df5bbdc184a743e38d75583a9b0a8fe..f1460d5fca132b8514453af742e10887b7d41f08 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -230,6 +230,7 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::conditional_jump(bool condition) {
 		tTemp = 12;
 		if (condition) {
+			delay();
 			PC = bus_->ReadL(PC);
 			tTemp = 16;
 		} else {
@@ -430,6 +431,8 @@ namespace TKPEmu::Gameboy::Devices {
 	}
 	void CPU::PUSHDE() {
 		SP -= 2;
+		//write(SP + 1, D);
+		//write(SP, E);
 		bus_->WriteL(SP, (D << 8) | E);
 		tTemp = 16;
 	}
@@ -836,7 +839,7 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::INCHLR() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_inc(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 12;
 	}
 	void CPU::DECA() {
@@ -863,7 +866,7 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::DECHLR() {
 		uint8_t t = bus_->Read((H << 8) | L);
 		reg_dec(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 12;
 	}
 	void CPU::INCBC() {
@@ -1026,12 +1029,14 @@ namespace TKPEmu::Gameboy::Devices {
 		PC++;
 	}
 	void CPU::RET() {
+		delay();
 		PC = bus_->ReadL(SP);
 		SP += 2;
 		tTemp = 16;
 	}
 	void CPU::RETI() {
 		ime_ = true;
+		delay();
 		PC = bus_->ReadL(SP);
 		SP += 2;
 		tTemp = 16;
@@ -1039,6 +1044,8 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::RETNZ() {
 		tTemp = 8;
 		if ((F & 0x80) == 0x00) {
+			delay();
+			delay();
 			PC = bus_->ReadL(SP);
 			SP += 2;
 			tTemp += 12;
@@ -1047,6 +1054,8 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::RETZ() {
 		tTemp = 8;
 		if ((F & 0x80) == 0x80) {
+			delay();
+			delay();
 			PC = bus_->ReadL(SP);
 			SP += 2;
 			tTemp += 12;
@@ -1055,6 +1064,8 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::RETNC() {
 		tTemp = 8;
 		if ((F & 0x10) == 0x00) {
+			delay();
+			delay();
 			PC = bus_->ReadL(SP);
 			SP += 2;
 			tTemp += 12;
@@ -1063,6 +1074,8 @@ namespace TKPEmu::Gameboy::Devices {
 	void CPU::RETC() {
 		tTemp = 8;
 		if ((F & 0x10) == 0x10) {
+			delay();
+			delay();
 			PC = bus_->ReadL(SP);
 			SP += 2;
 			tTemp += 12;
@@ -1400,13 +1413,13 @@ namespace TKPEmu::Gameboy::Devices {
 		tTemp = 8;
 	}
 	void CPU::RLCHL() {
-		int i = bus_->Read((H << 8) | L);
+		int i = read((H << 8) | L);
 		int ci = (i & 0x80) ? 1 : 0;
 		int co = (i & 0x80) ? 0x10 : 0;
 		i = (i << 1) + ci;
 		i &= 0xFF;
 		F = (i) ? 0 : 0x80;
-		bus_->Write((H << 8) | L, i);
+		write((H << 8) | L, i);
 		F = (F & 0xEF) + co;
 		tTemp = 16;
 	}
@@ -1432,9 +1445,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_rrc(A);
 	}
 	void CPU::RRCHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_rrc(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::RLB() {
@@ -1459,9 +1472,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_rl(A);
 	}
 	void CPU::RLHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_rl(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::RRB() {
@@ -1486,9 +1499,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_rr(A);
 	}
 	void CPU::RRHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_rr(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::SLAB() {
@@ -1510,9 +1523,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_sl(L);
 	}
 	void CPU::SLAHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_sl(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::SLAA() {
@@ -1537,9 +1550,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_sr(L);
 	}
 	void CPU::SRAHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_sr(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::SRAA() {
@@ -1564,9 +1577,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_swap(L);
 	}
 	void CPU::SWAPHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_swap(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::SWAPA() {
@@ -1591,9 +1604,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_srl(L);
 	}
 	void CPU::SRLHL() {
-		uint8_t t = bus_->Read((H << 8) | L);
+		uint8_t t = read((H << 8) | L);
 		bit_srl(t);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp = 16;
 	}
 	void CPU::SRLA() {
@@ -1818,9 +1831,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 0);
 	}
 	void CPU::RES0HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 0);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES0A() {
@@ -1845,9 +1858,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 1);
 	}
 	void CPU::RES1HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 1);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES1A() {
@@ -1872,9 +1885,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 2);
 	}
 	void CPU::RES2HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 2);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES2A() {
@@ -1899,9 +1912,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 3);
 	}
 	void CPU::RES3HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 3);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES3A() {
@@ -1926,9 +1939,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 4);
 	}
 	void CPU::RES4HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 4);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES4A() {
@@ -1953,9 +1966,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 5);
 	}
 	void CPU::RES5HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 5);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES5A() {
@@ -1980,9 +1993,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 6);
 	}
 	void CPU::RES6HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 6);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES6A() {
@@ -2007,9 +2020,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_res(L, 7);
 	}
 	void CPU::RES7HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_res(t, 7);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::RES7A() {
@@ -2034,9 +2047,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 0);
 	}
 	void CPU::SET0HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 0);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET0A() {
@@ -2061,9 +2074,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 1);
 	}
 	void CPU::SET1HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 1);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET1A() {
@@ -2088,9 +2101,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 2);
 	}
 	void CPU::SET2HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 2);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET2A() {
@@ -2115,9 +2128,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 3);
 	}
 	void CPU::SET3HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 3);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET3A() {
@@ -2142,9 +2155,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 4);
 	}
 	void CPU::SET4HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 4);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET4A() {
@@ -2169,9 +2182,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 5);
 	}
 	void CPU::SET5HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 5);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET5A() {
@@ -2196,9 +2209,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 6);
 	}
 	void CPU::SET6HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 6);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET6A() {
@@ -2223,9 +2236,9 @@ namespace TKPEmu::Gameboy::Devices {
 		bit_set(L, 7);
 	}
 	void CPU::SET7HL() {
-		auto t = bus_->Read((H << 8) | L);
+		auto t = read((H << 8) | L);
 		bit_set(t, 7);
-		bus_->Write((H << 8) | L, t);
+		write((H << 8) | L, t);
 		tTemp += 8;
 	}
 	void CPU::SET7A() {
@@ -2298,9 +2311,7 @@ namespace TKPEmu::Gameboy::Devices {
 		ime_ = false;
 		ime_scheduled_ = false;
 		IF &= ~(1U << bit);
-		SP -= 2;
-		bus_->WriteL(SP, PC);
-		PC = 0x40 + bit * 0x8;
+		rst(0x40 + bit * 0x8);
 		tTemp = 20;
 		if (halt_) {
 			tTemp = 24;

From eb573750a4fe5f7aa57912acc2d41d8f1ce87657 Mon Sep 17 00:00:00 2001
From: OFFTKP <parisoplop@gmail.com>
Date: Mon, 20 Dec 2021 01:48:43 +0200
Subject: [PATCH] documenting delay func

---
 TKPEmu/gb_tkp/gb_cpu.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/TKPEmu/gb_tkp/gb_cpu.cpp b/TKPEmu/gb_tkp/gb_cpu.cpp
index f1460d5fca132b8514453af742e10887b7d41f08..228cbae78c5bba7b80c7f41837abb63650d94bf7 100644
--- a/TKPEmu/gb_tkp/gb_cpu.cpp
+++ b/TKPEmu/gb_tkp/gb_cpu.cpp
@@ -2317,14 +2317,19 @@ namespace TKPEmu::Gameboy::Devices {
 			tTemp = 24;
 		}
 	}
+	// Delayed read function
 	uint8_t CPU::read(uint16_t addr) {
 		delay();
 		return bus_->Read(addr);
 	}
+	// Delayed write function
 	void CPU::write(uint16_t addr, uint8_t val) {
 		delay();
 		bus_->Write(addr, val);
 	}
+	/// Function that updates the dma/timer/ppu mid instruction
+	/// Tests like mem_timing and gekkio acceptance tests check dma/timer values mid instruction
+	/// The first read/write function of each instruction does not seem to need to be delayed
 	void CPU::delay() {
 		tRemove += 4;
 		bus_->TransferDMA(4);
